<!DOCTYPE html><!DOCTYPE html>

<html lang="en"><html lang="en">

  <head>  <head>

    <meta charset="UTF-8" />    <meta charset="UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Sharkoder - GPU Video Encoder</title>    <title>Sharkoder - GPU Video Encoder</title>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>

    <!-- React 18 -->    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>    <script src="https://cdn.tailwindcss.com"></script>

    <style>

    <!-- Babel for JSX transpiling -->      body {

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>        margin: 0;

        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;

    <!-- Tailwind CSS -->        background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 50%, #5b21b6 100%);

    <script src="https://cdn.tailwindcss.com"></script>        color: #f8fafc;

        overflow: hidden;

    <style>      }

      body {

        margin: 0;      .bg-glass {

        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;        background: rgba(255, 255, 255, 0.1);

        background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 50%, #5b21b6 100%);        backdrop-filter: blur(10px);

        color: #f8fafc;        border: 1px solid rgba(255, 255, 255, 0.2);

        overflow: hidden;      }

      }

      .scrollbar-thin {

      .bg-glass {        scrollbar-width: thin;

        background: rgba(255, 255, 255, 0.1);        scrollbar-color: rgba(255, 255, 255, 0.3) transparent;

        backdrop-filter: blur(10px);      }

        border: 1px solid rgba(255, 255, 255, 0.2);

      }      .scrollbar-thin::-webkit-scrollbar {

        width: 8px;

      .scrollbar-thin {      }

        scrollbar-width: thin;

        scrollbar-color: rgba(255, 255, 255, 0.3) transparent;      .scrollbar-thin::-webkit-scrollbar-track {

      }        background: transparent;

      }

      .scrollbar-thin::-webkit-scrollbar {

        width: 8px;      .scrollbar-thin::-webkit-scrollbar-thumb {

      }        background: rgba(255, 255, 255, 0.3);

        border-radius: 4px;

      .scrollbar-thin::-webkit-scrollbar-track {      }

        background: transparent;

      }      .scrollbar-thin::-webkit-scrollbar-thumb:hover {

        background: rgba(255, 255, 255, 0.5);

      .scrollbar-thin::-webkit-scrollbar-thumb {      }

        background: rgba(255, 255, 255, 0.3);

        border-radius: 4px;      .status-waiting {

      }        background-color: rgb(107 114 128);

      }

      .scrollbar-thin::-webkit-scrollbar-thumb:hover {      .status-downloading {

        background: rgba(255, 255, 255, 0.5);        background-color: rgb(59 130 246);

      }      }

      .status-ready_encode {

      /* Status badge colors */        background-color: rgb(96 165 250);

      .status-waiting {      }

        background-color: rgb(107 114 128);      .status-encoding {

      }        background-color: rgb(234 179 8);

      .status-downloading {      }

        background-color: rgb(59 130 246);      .status-awaiting_approval {

      }        background-color: rgb(251 146 60);

      .status-ready_encode {        animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;

        background-color: rgb(96 165 250);      }

      }      .status-ready_upload {

      .status-encoding {        background-color: rgb(192 132 252);

        background-color: rgb(234 179 8);      }

      }      .status-uploading {

      .status-awaiting_approval {        background-color: rgb(168 85 247);

        background-color: rgb(251 146 60);      }

        animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;      .status-completed {

      }        background-color: rgb(34 197 94);

      .status-ready_upload {      }

        background-color: rgb(192 132 252);      .status-failed {

      }        background-color: rgb(239 68 68);

      .status-uploading {      }

        background-color: rgb(168 85 247);      .status-paused {

      }        background-color: rgb(249 115 22);

      .status-completed {      }

        background-color: rgb(34 197 94);

      }      .glow-effect {

      .status-failed {        box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);

        background-color: rgb(239 68 68);      }

      }

      .status-paused {      .btn-primary {

        background-color: rgb(249 115 22);        background-color: rgb(37 99 235);

      }        color: white;

        padding: 0.5rem 1rem;

      .glow-effect {        border-radius: 0.5rem;

        box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);        transition: background-color 0.2s;

      }        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);

        border: none;

      /* Button styles */        cursor: pointer;

      .btn-primary {      }

        background-color: rgb(37 99 235);

        color: white;      .btn-primary:hover {

        padding: 0.5rem 1rem;        background-color: rgb(29 78 216);

        border-radius: 0.5rem;      }

        transition: background-color 0.2s;

        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);      .btn-secondary {

        border: none;        background-color: rgb(75 85 99);

        cursor: pointer;        color: white;

      }        padding: 0.25rem 0.75rem;

        border-radius: 0.25rem;

      .btn-primary:hover {        transition: background-color 0.2s;

        background-color: rgb(29 78 216);        border: none;

      }        cursor: pointer;

      }

      .btn-secondary {

        background-color: rgb(75 85 99);      .btn-secondary:hover {

        color: white;        background-color: rgb(55 65 81);

        padding: 0.5rem 1rem;      }

        border-radius: 0.5rem;

        transition: background-color 0.2s;      .btn-danger {

        border: none;        background-color: rgb(220 38 38);

        cursor: pointer;        color: white;

      }        padding: 0.25rem 0.75rem;

        border-radius: 0.25rem;

      .btn-secondary:hover {        transition: background-color 0.2s;

        background-color: rgb(55 65 81);        border: none;

      }        cursor: pointer;

      }

      .btn-success {

        background-color: rgb(34 197 94);      .btn-danger:hover {

        color: white;        background-color: rgb(185 28 28);

        padding: 0.5rem 1rem;      }

        border-radius: 0.5rem;

        transition: background-color 0.2s;      .btn-success {

        border: none;        background-color: rgb(22 163 74);

        cursor: pointer;        color: white;

      }        padding: 0.25rem 0.75rem;

        border-radius: 0.25rem;

      .btn-success:hover {        transition: background-color 0.2s;

        background-color: rgb(22 163 74);        border: none;

      }        cursor: pointer;

      }

      .btn-danger {

        background-color: rgb(239 68 68);      .btn-success:hover {

        color: white;        background-color: rgb(21 128 61);

        padding: 0.5rem 1rem;      }

        border-radius: 0.5rem;

        transition: background-color 0.2s;      .btn-warning {

        border: none;        background-color: rgb(234 179 8);

        cursor: pointer;        color: white;

      }        padding: 0.25rem 0.75rem;

        border-radius: 0.25rem;

      .btn-danger:hover {        transition: background-color 0.2s;

        background-color: rgb(220 38 38);        border: none;

      }        cursor: pointer;

      }

      /* Loading animation */

      @keyframes pulse {      .btn-warning:hover {

        0%,        background-color: rgb(202 138 4);

        100% {      }

          opacity: 1;

        }      .encoder-info-panel {

        50% {        background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(139, 92, 246, 0.1));

          opacity: 0.5;        border: 1px solid rgba(59, 130, 246, 0.3);

        }        border-radius: 0.5rem;

      }        padding: 0.75rem;

        margin-bottom: 1rem;

      #initial-loader {      }

        position: fixed;

        top: 0;      .encoder-badge {

        left: 0;        display: inline-flex;

        width: 100%;        align-items: center;

        height: 100%;        padding: 0.25rem 0.75rem;

        background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 50%, #5b21b6 100%);        border-radius: 9999px;

        display: flex;        font-size: 0.75rem;

        justify-content: center;        font-weight: 600;

        align-items: center;        margin-right: 0.5rem;

        z-index: 9999;      }

      }

    </style>      .encoder-badge-gpu {

  </head>        background-color: rgba(34, 197, 94, 0.2);

  <body>        color: rgb(134, 239, 172);

    <!-- Initial HTML loader (hidden when React loads) -->        border: 1px solid rgba(34, 197, 94, 0.4);

    <div id="initial-loader">      }

      <div class="text-center">

        <img src="../assets/icon.png" alt="Sharkoder" class="w-24 h-24 mx-auto mb-4 animate-pulse" />      .encoder-badge-cpu {

        <div class="text-2xl font-bold">Loading Sharkoder...</div>        background-color: rgba(234, 179, 8, 0.2);

        <div class="text-gray-400 mt-2">Initializing React application</div>        color: rgb(253, 224, 71);

      </div>        border: 1px solid rgba(234, 179, 8, 0.4);

    </div>      }



    <!-- React root -->      .encoder-param {

    <div id="root"></div>        display: inline-flex;

        align-items: center;

    <!-- Main application (React + all components) -->        padding: 0.25rem 0.5rem;

    <script type="text/babel" src="./app.js"></script>        background-color: rgba(75, 85, 99, 0.3);

  </body>        border-radius: 0.25rem;

</html>        font-size: 0.75rem;

        margin-right: 0.5rem;
        margin-bottom: 0.25rem;
      }

      .encoder-param-label {
        color: rgb(156, 163, 175);
        margin-right: 0.25rem;
      }

      .encoder-param-value {
        color: rgb(229, 231, 235);
        font-weight: 600;
      }

      /* Loading Animation */
      .loading-screen {
        position: fixed;
        inset: 0;
        background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 50%, #5b21b6 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        animation: fadeScreen 3s ease-in-out infinite;
      }

      @keyframes fadeScreen {
        0%,
        100% {
          opacity: 0.95;
        }
        50% {
          opacity: 1;
        }
      }

      .shark-icon {
        width: 128px;
        height: 128px;
        animation: zoomPulse 2s ease-in-out infinite;
        filter: drop-shadow(0 10px 30px rgba(59, 130, 246, 0.5));
      }

      .shark-icon img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      @keyframes zoomPulse {
        0%,
        100% {
          transform: scale(1);
          opacity: 0.8;
        }
        50% {
          transform: scale(1.15);
          opacity: 1;
        }
      }

      .loading-dots {
        display: flex;
        gap: 0.5rem;
        margin-top: 2rem;
      }

      .loading-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background-color: #60a5fa;
        animation: bounce 1.4s infinite ease-in-out both;
      }

      .loading-dot:nth-child(1) {
        animation-delay: -0.32s;
      }

      .loading-dot:nth-child(2) {
        animation-delay: -0.16s;
      }

      @keyframes bounce {
        0%,
        80%,
        100% {
          transform: scale(0);
        }
        40% {
          transform: scale(1);
        }
      }

      .pulse-ring {
        position: absolute;
        width: 150px;
        height: 150px;
        border: 4px solid rgba(59, 130, 246, 0.3);
        border-radius: 50%;
        animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
          transform: scale(0.95);
        }
        50% {
          opacity: 0.5;
          transform: scale(1.05);
        }
      }
    </style>
  </head>
  <body>
    <!-- Initial loading screen (shown immediately before React loads) -->
    <div id="initial-loader" class="loading-screen">
      <div class="relative">
        <div class="pulse-ring"></div>
        <div class="shark-icon">
          <img src="../assets/icon.png" alt="Sharkoder" />
        </div>
      </div>
      <div class="mt-8 text-xl text-white font-semibold text-center">Starting Sharkoder...</div>
      <div class="loading-dots">
        <div class="loading-dot"></div>
        <div class="loading-dot"></div>
        <div class="loading-dot"></div>
      </div>
    </div>

    <div id="root"></div>

    <!-- External React Components -->
    <script type="text/babel" src="components/CodecSelector.js"></script>

    <script type="text/babel">
      const { useState, useEffect, useCallback } = React;

      // Loading Screen Component
      const LoadingScreen = ({ message = "Loading Sharkoder..." }) => {
        return (
          <div className="loading-screen">
            <div className="relative">
              <div className="pulse-ring"></div>
              <div className="shark-icon">
                <img src="../assets/icon.png" alt="Sharkoder" />
              </div>
            </div>
            <div className="mt-8 text-xl text-white font-semibold text-center">{message}</div>
            <div className="loading-dots">
              <div className="loading-dot"></div>
              <div className="loading-dot"></div>
              <div className="loading-dot"></div>
            </div>
          </div>
        );
      };

      // Status Badge Component
      const StatusBadge = ({ status }) => {
        const statusConfig = {
          waiting: { label: "Waiting", className: "status-waiting" },
          downloading: { label: "Downloading", className: "status-downloading" },
          ready_encode: { label: "Ready to Encode", className: "status-ready_encode" },
          encoding: { label: "Encoding", className: "status-encoding" },
          awaiting_approval: { label: "‚è∏Ô∏è Awaiting Review", className: "status-awaiting_approval" },
          ready_upload: { label: "Ready to Upload", className: "status-ready_upload" },
          uploading: { label: "Uploading", className: "status-uploading" },
          completed: { label: "Completed", className: "status-completed" },
          failed: { label: "Failed", className: "status-failed" },
          paused: { label: "Paused", className: "status-paused" },
        };

        const config = statusConfig[status] || statusConfig.waiting;

        return <span className={`px-2 py-1 rounded-full text-xs font-medium text-white ${config.className}`}>{config.label}</span>;
      };

      // Progress Bar Component
      const ProgressBar = ({ progress, type, eta, fps, speed, elapsedTime, currentTime, totalDuration }) => {
        console.log("[ProgressBar] Rendering with:", { progress, type, eta, speed });
        const getBarColor = () => {
          switch (type) {
            case "download":
              return "bg-blue-500";
            case "encoding":
              return "bg-yellow-500";
            case "upload":
              return "bg-purple-500";
            default:
              return "bg-gray-500";
          }
        };

        const formatETA = (seconds) => {
          if (!seconds || seconds <= 0) return "";

          const hours = Math.floor(seconds / 3600);
          const minutes = Math.floor((seconds % 3600) / 60);
          const secs = Math.floor(seconds % 60);

          if (hours > 0) {
            return `${hours}h ${minutes}m`;
          } else if (minutes > 0) {
            return `${minutes}m ${secs}s`;
          } else {
            return `${secs}s`;
          }
        };

        const formatTime = (seconds) => {
          if (!seconds) return "00:00:00";
          const h = Math.floor(seconds / 3600);
          const m = Math.floor((seconds % 3600) / 60);
          const s = Math.floor(seconds % 60);
          return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
        };

        const formatSpeed = (bytesPerSecond) => {
          if (!bytesPerSecond || bytesPerSecond === 0) return "0 Ko/s";
          const k = 1024;
          if (bytesPerSecond < k) return bytesPerSecond.toFixed(0) + " o/s";
          if (bytesPerSecond < k * k) return (bytesPerSecond / k).toFixed(1) + " Ko/s";
          if (bytesPerSecond < k * k * k) return (bytesPerSecond / (k * k)).toFixed(1) + " Mo/s";
          return (bytesPerSecond / (k * k * k)).toFixed(2) + " Go/s";
        };

        return (
          <div className="w-full">
            <div className="flex justify-between text-xs mb-1">
              <div className="flex items-center space-x-3">
                <span className="font-medium">{Math.round(progress)}%</span>
                {fps && fps > 0 && <span className="text-blue-400">üé¨ {Math.round(fps)} FPS</span>}
                {speed && speed > 0 && <span className="text-purple-400">‚ö° {formatSpeed(speed)}</span>}
              </div>
              <div className="flex items-center space-x-3">
                {elapsedTime && <span className="text-gray-400">‚è±Ô∏è {formatETA(elapsedTime)}</span>}
                {type === "encoding" && <span className="text-green-400 font-medium">ETA: {eta && eta > 0 ? formatETA(eta) : "--"}</span>}
                {type !== "encoding" && eta && eta > 0 && <span className="text-green-400 font-medium">ETA: {formatETA(eta)}</span>}
              </div>
            </div>
            <div className="w-full bg-gray-700 rounded-full h-2">
              <div className={`${getBarColor()} h-2 rounded-full transition-all duration-300`} style={{ width: `${Math.min(progress, 100)}%` }}></div>
            </div>
          </div>
        );
      };

      // Cache Manager Component
      const CacheManager = ({ onClose }) => {
        const [rebuildingCache, setRebuildingCache] = useState(false);
        const [rebuildProgress, setRebuildProgress] = useState({ current: 0, total: 0, currentFolder: "", eta: 0 });
        const [cacheInfo, setCacheInfo] = useState({ size: 0, entries: 0 });
        const [dirCacheInfo, setDirCacheInfo] = useState({ size: 0, entries: 0 });
        const CACHE_KEY = "webdav_folder_stats_cache";
        const DIRECTORY_CACHE_KEY = "webdav_directory_structure_cache";

        // Charger les infos du cache
        React.useEffect(() => {
          updateCacheInfo();
        }, []);

        const updateCacheInfo = () => {
          try {
            // Stats Cache
            const cached = localStorage.getItem(CACHE_KEY);
            if (cached) {
              const cache = JSON.parse(cached);
              const entries = Object.keys(cache).length;
              const size = new Blob([cached]).size;
              setCacheInfo({ size, entries });
            } else {
              setCacheInfo({ size: 0, entries: 0 });
            }

            // Directory Structure Cache
            const dirCached = localStorage.getItem(DIRECTORY_CACHE_KEY);
            if (dirCached) {
              const dirCache = JSON.parse(dirCached);
              const entries = Object.keys(dirCache).length;
              const size = new Blob([dirCached]).size;
              setDirCacheInfo({ size, entries });
            } else {
              setDirCacheInfo({ size: 0, entries: 0 });
            }
          } catch (error) {
            console.error("Error loading cache info:", error);
            setCacheInfo({ size: 0, entries: 0 });
            setDirCacheInfo({ size: 0, entries: 0 });
          }
        };

        const formatBytes = (bytes) => {
          if (bytes === 0) return "0 B";
          const k = 1024;
          const sizes = ["B", "KB", "MB", "GB"];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + " " + sizes[i];
        };

        const clearCache = () => {
          if (confirm("Clear all folder stats cache?\n\nThis will remove all folder statistics from cache.")) {
            try {
              localStorage.removeItem(CACHE_KEY);
              updateCacheInfo();
              alert("Stats cache cleared successfully!");
            } catch (error) {
              alert("Error clearing cache: " + error.message);
            }
          }
        };

        const clearDirectoryCache = () => {
          if (confirm("‚ö†Ô∏è Clear directory structure cache?\n\nThis will remove all cached directory listings. Folders will be reloaded from the server on next visit.")) {
            try {
              localStorage.removeItem(DIRECTORY_CACHE_KEY);
              updateCacheInfo();
              alert("Directory cache cleared successfully!");
            } catch (error) {
              alert("Error clearing directory cache: " + error.message);
            }
          }
        };

        const clearAllCaches = () => {
          if (confirm("Clear ALL caches?\n\nThis will remove both folder statistics and directory structure caches.")) {
            try {
              localStorage.removeItem(CACHE_KEY);
              localStorage.removeItem(DIRECTORY_CACHE_KEY);
              updateCacheInfo();
              alert("All caches cleared successfully!");
            } catch (error) {
              alert("Error clearing caches: " + error.message);
            }
          }
        };

        const rebuildCompleteCache = async () => {
          try {
            setRebuildingCache(true);
            setRebuildProgress({ current: 0, total: 0, currentFolder: "Initializing...", eta: 0 });

            const startTime = Date.now();

            console.log("Starting optimized cache rebuild...");

            // Setup progress listener
            const progressListener = (progress) => {
              setRebuildProgress({
                current: progress.current,
                total: progress.total,
                currentFolder: progress.currentFolder,
                eta: progress.eta || 0,
              });
            };

            if (window.electronAPI.onCacheProgress) {
              window.electronAPI.onCacheProgress(progressListener);
            }

            // Call optimized backend method (single pass through entire tree)
            const result = await window.electronAPI.buildCompleteCache();

            if (result.success) {
              // Save the cache
              localStorage.setItem(CACHE_KEY, JSON.stringify(result.cache));
              updateCacheInfo();

              const totalTime = result.stats.totalTime;
              const totalFolders = result.stats.totalFolders;

              console.log(`Cache rebuilt successfully! ${totalFolders} folders in ${totalTime}s`);

              // Synchroniser le cache avec le serveur apr√®s le rebuild
              console.log("Syncing cache with server...");
              try {
                if (window.electronAPI.syncCache) {
                  await window.electronAPI.syncCache();
                  console.log("Cache synced with server");
                }
              } catch (syncError) {
                console.error("Error syncing cache:", syncError);
              }

              alert(`Cache rebuilt successfully!\n\n${totalFolders} folders scanned in ${totalTime}s\n\nOptimized single-pass algorithm used!`);
            } else {
              console.error("Cache rebuild failed:", result.error);
              alert(`Cache rebuild failed: ${result.error}`);
            }
          } catch (error) {
            console.error("Error rebuilding cache:", error);
            alert("‚ùå Error rebuilding cache: " + error.message);
          } finally {
            setRebuildingCache(false);
            setRebuildProgress({ current: 0, total: 0, currentFolder: "", eta: 0 });
          }
        };

        const formatETA = (seconds) => {
          const mins = Math.floor(seconds / 60);
          const secs = seconds % 60;
          return mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
        };

        return (
          <div className="space-y-6">
            <h3 className="text-lg font-semibold text-white">Cache Management</h3>

            {/* Cache Info */}
            <div className="bg-gray-700 rounded-lg p-6">
              <h4 className="text-md font-semibold mb-4 text-white">üìä Cache Statistics</h4>
              <div className="grid grid-cols-2 gap-4 mb-4">
                <div className="bg-gray-800 rounded p-4 col-span-2 border-l-4 border-blue-500">
                  <div className="text-gray-400 text-sm mb-2">üìÅ Folder Stats Cache</div>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <div className="text-xs text-gray-500">Cached Folders</div>
                      <div className="text-xl font-bold text-white">{cacheInfo.entries.toLocaleString()}</div>
                    </div>
                    <div>
                      <div className="text-xs text-gray-500">Cache Size</div>
                      <div className="text-xl font-bold text-white">{formatBytes(cacheInfo.size)}</div>
                    </div>
                  </div>
                </div>

                <div className="bg-gray-800 rounded p-4 col-span-2 border-l-4 border-green-500">
                  <div className="text-gray-400 text-sm mb-2">üóÇÔ∏è Directory Structure Cache</div>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <div className="text-xs text-gray-500">Cached Directories</div>
                      <div className="text-xl font-bold text-white">{dirCacheInfo.entries.toLocaleString()}</div>
                    </div>
                    <div>
                      <div className="text-xs text-gray-500">Cache Size</div>
                      <div className="text-xl font-bold text-white">{formatBytes(dirCacheInfo.size)}</div>
                    </div>
                  </div>
                  <div className="text-xs text-gray-400 mt-2">üí° Speeds up navigation by caching directory listings (max age: 5 min)</div>
                </div>

                <div className="bg-gray-800 rounded p-4 col-span-2">
                  <div className="text-gray-400 text-sm mb-1">Total Cache Size</div>
                  <div className="text-2xl font-bold text-white">{formatBytes(cacheInfo.size + dirCacheInfo.size)}</div>
                </div>
              </div>
            </div>

            {/* Actions */}
            <div className="space-y-4">
              <div className="bg-gray-700 rounded-lg p-6">
                <h4 className="text-md font-semibold mb-2 text-white">üîÑ Rebuild Complete Cache</h4>
                <p className="text-gray-300 text-sm mb-4">Scan all folders recursively and rebuild the entire cache. This may take several minutes depending on your library size.</p>
                <button onClick={rebuildCompleteCache} disabled={rebuildingCache} className="btn-primary w-full disabled:opacity-50 disabled:cursor-not-allowed">
                  {rebuildingCache ? "‚è≥ Rebuilding..." : "üîÑ Rebuild Complete Cache"}
                </button>
              </div>

              <div className="bg-gray-700 rounded-lg p-6">
                <h4 className="text-md font-semibold mb-2 text-white">üóëÔ∏è Clear Cache</h4>
                <p className="text-gray-300 text-sm mb-4">Remove cached data. Choose what to clear based on your needs.</p>
                <div className="space-y-2">
                  <button
                    onClick={clearCache}
                    disabled={rebuildingCache}
                    className="bg-orange-600 hover:bg-orange-700 text-white py-2 px-4 rounded w-full disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                  >
                    üìä Clear Folder Stats Cache
                  </button>
                  <button
                    onClick={clearDirectoryCache}
                    disabled={rebuildingCache}
                    className="bg-orange-600 hover:bg-orange-700 text-white py-2 px-4 rounded w-full disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                  >
                    üóÇÔ∏è Clear Directory Structure Cache
                  </button>
                  <button
                    onClick={clearAllCaches}
                    disabled={rebuildingCache}
                    className="bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded w-full disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    üóëÔ∏è Clear ALL Caches
                  </button>
                </div>
              </div>
            </div>

            {/* Progress */}
            {rebuildingCache && (
              <div className="bg-gray-700 rounded-lg p-6">
                <h4 className="text-md font-semibold mb-4 text-white">‚è≥ Rebuild Progress</h4>

                <div className="mb-4">
                  <div className="flex justify-between text-sm text-gray-300 mb-2">
                    <span>
                      {rebuildProgress.current} / {rebuildProgress.total} folders
                    </span>
                    <span>{rebuildProgress.total > 0 ? Math.round((rebuildProgress.current / rebuildProgress.total) * 100) : 0}%</span>
                  </div>
                  <div className="w-full bg-gray-600 rounded-full h-4 overflow-hidden">
                    <div className="bg-blue-500 h-full transition-all duration-300" style={{ width: `${rebuildProgress.total > 0 ? (rebuildProgress.current / rebuildProgress.total) * 100 : 0}%` }} />
                  </div>
                </div>

                {rebuildProgress.eta > 0 && <div className="text-sm text-gray-300 mb-2">‚è±Ô∏è Estimated time remaining: {formatETA(rebuildProgress.eta)}</div>}

                <div className="text-sm text-gray-400 truncate">üìÅ Current: {rebuildProgress.currentFolder || "Initializing..."}</div>
              </div>
            )}
          </div>
        );
      };

      // File Tree Component
      const FileTree = ({ onAddToQueue, encodedFiles, userConfig, pauseBeforeUpload }) => {
        const [currentPath, setCurrentPath] = useState("/");
        const [files, setFiles] = useState([]);
        const [loading, setLoading] = useState(false);
        const [connected, setConnected] = useState(false);
        const [sortBy, setSortBy] = useState("alpha"); // 'alpha' or 'size'
        const [searchTerm, setSearchTerm] = useState("");
        const [calculatingSize, setCalculatingSize] = useState({}); // Track folders being calculated
        const [loadedFromCache, setLoadedFromCache] = useState(false); // Track if directory was loaded from cache
        const [sessionCache, setSessionCache] = useState({}); // In-memory cache for current session (never expires)
        const sessionCacheRef = React.useRef(sessionCache); // Ref pour √©viter la recr√©ation de loadFiles
        const [loadingVideoInfo, setLoadingVideoInfo] = useState({}); // Track files loading video info
        const [calculatingStats, setCalculatingStats] = useState({ isCalculating: false, current: 0, total: 0 }); // Track stats calculation progress
        const [deleteConfirm, setDeleteConfirm] = useState(null); // Modal for delete confirmation { file, type: 'file'|'folder' }
        const [downloading, setDownloading] = useState({}); // Track files/folders being downloaded

        // Synchroniser la ref avec le state
        React.useEffect(() => {
          sessionCacheRef.current = sessionCache;
          console.log(`sessionCache updated, keys:`, Object.keys(sessionCache));
        }, [sessionCache]);

        // Cache persistant pour les stats des dossiers (localStorage)
        const CACHE_KEY = "webdav_folder_stats_cache";
        const DIRECTORY_CACHE_KEY = "webdav_directory_structure_cache";

        // Charger le cache depuis localStorage
        const loadCache = () => {
          try {
            const cached = localStorage.getItem(CACHE_KEY);
            return cached ? JSON.parse(cached) : {};
          } catch (error) {
            console.error("Error loading cache:", error);
            return {};
          }
        };

        // Sauvegarder le cache dans localStorage
        const saveCache = (cache) => {
          try {
            localStorage.setItem(CACHE_KEY, JSON.stringify(cache));
          } catch (error) {
            console.error("Error saving cache:", error);
          }
        };

        // Nettoyer les anciennes entr√©es de cache qui n'ont pas les champs duration
        const cleanOldCacheEntries = () => {
          try {
            const cache = loadCache();
            let cleaned = 0;
            let kept = 0;

            const newCache = {};

            for (const [path, stats] of Object.entries(cache)) {
              // V√©rifier si l'entr√©e a les champs requis
              const hasDurationFields = stats.hasOwnProperty("totalDuration") && stats.hasOwnProperty("sizePerHour");

              if (hasDurationFields) {
                newCache[path] = stats;
                kept++;
              } else {
                cleaned++;
              }
            }

            if (cleaned > 0) {
              console.log(`Cache cleanup: removed ${cleaned} outdated entries, kept ${kept} valid entries`);
              saveCache(newCache);
              return cleaned;
            } else {
              console.log(`Cache is up-to-date: all ${kept} entries have duration fields`);
              return 0;
            }
          } catch (error) {
            console.error("Error cleaning cache:", error);
            return 0;
          }
        };

        // Charger le cache de l'architecture des r√©pertoires
        const loadDirectoryCache = () => {
          try {
            const cached = localStorage.getItem(DIRECTORY_CACHE_KEY);
            return cached ? JSON.parse(cached) : {};
          } catch (error) {
            console.error("Error loading directory cache:", error);
            return {};
          }
        };

        // Sauvegarder le cache de l'architecture des r√©pertoires
        const saveDirectoryCache = (cache) => {
          try {
            localStorage.setItem(DIRECTORY_CACHE_KEY, JSON.stringify(cache));
            console.log(`Directory cache saved (${Object.keys(cache).length} directories)`);
          } catch (error) {
            console.error("Error saving directory cache:", error);
          }
        };

        // Vider le cache de l'architecture
        const clearDirectoryCache = () => {
          try {
            localStorage.removeItem(DIRECTORY_CACHE_KEY);
            console.log("Directory cache cleared");
          } catch (error) {
            console.error("Error clearing directory cache:", error);
          }
        };

        // V√©rifier si le cache est √† jour par rapport au serveur
        const isCacheValid = (cachedItem, serverLastModified) => {
          if (!cachedItem || !cachedItem.lastModified) return false;
          if (!serverLastModified) return true; // Si pas de date serveur, on garde le cache

          const cacheDate = new Date(cachedItem.lastModified).getTime();
          const serverDate = new Date(serverLastModified).getTime();

          return cacheDate >= serverDate; // Cache valide si plus r√©cent ou √©gal
        };

        // Synchroniser le cache avec le serveur au d√©marrage
        const syncCacheWithServer = async () => {
          try {
            console.log("Starting cache synchronization with server...");
            const cache = loadCache();
            const cachedPaths = Object.keys(cache);

            if (cachedPaths.length === 0) {
              console.log("No cache to sync");
              return;
            }

            console.log(`Cache loaded: ${cachedPaths.length} folders cached`);
            console.log("Cache ready to use (no recalculation needed)");

            // Option: Download cache from server if it exists
            // This would sync with other devices/sessions
            // TODO: Implement server-side cache file download here if needed

            // For now, just use the local cache as-is
            // The cache will be validated on-demand when folders are accessed
          } catch (error) {
            console.error("Error during cache sync:", error);
          }
        };

        // Fonction pour calculer les stats d'un dossier
        const calculateFolderSize = async (folderPath, silent = false, forceRefresh = false) => {
          try {
            // Charger le cache
            const cache = loadCache();

            // V√©rifier si on a un cache valide (sauf si forceRefresh)
            if (!forceRefresh && cache[folderPath]) {
              const cachedStats = cache[folderPath];

              // VALIDATION: V√©rifier que le cache a les champs duration/sizePerHour
              const hasDurationFields = cachedStats.hasOwnProperty("totalDuration") && cachedStats.hasOwnProperty("sizePerHour");

              if (!hasDurationFields) {
                console.log(`WARNING: Cache for "${folderPath}" is outdated (missing duration fields) - recalculating`);
                // Ne pas retourner, continuer avec le calcul
              } else {
                // Appliquer imm√©diatement le cache aux fichiers
                setFiles((prevFiles) =>
                  prevFiles.map((file) => {
                    if (file.path === folderPath && file.type === "directory") {
                      return {
                        ...file,
                        size: cachedStats.totalSize,
                        fileCount: cachedStats.fileCount,
                        videoCount: cachedStats.videoCount,
                        avgSize: cachedStats.avgSize,
                        sizeFormatted: cachedStats.totalSizeFormatted,
                        totalDuration: cachedStats.totalDuration,
                        totalDurationFormatted: cachedStats.totalDurationFormatted,
                        sizePerHour: cachedStats.sizePerHour,
                        sizePerHourFormatted: cachedStats.sizePerHourFormatted,
                        cached: true,
                        lastModified: cachedStats.lastModified,
                        upToDate: cachedStats.upToDate !== false,
                      };
                    }
                    return file;
                  })
                );

                // Si le cache existe et est marqu√© comme √† jour, ne pas recalculer
                if (cachedStats.upToDate !== false) {
                  if (!silent) {
                    console.log(`Using cached stats for ${folderPath}`);
                  }
                  return;
                }
              }
            } // Pas de cache OU cache pas √† jour OU forceRefresh : calculer

            // Mark as calculating (sauf en mode silent)
            if (!silent) {
              setCalculatingSize((prev) => ({ ...prev, [folderPath]: true }));
            }

            // TOUJOURS demander la dur√©e pour avoir les stats compl√®tes (totalDuration, sizePerHour)
            const result = await window.electronAPI.webdavGetFolderStats(folderPath, true);

            if (result.success) {
              // Mettre √† jour le cache avec la date actuelle
              const statsWithDate = {
                ...result.stats,
                lastModified: new Date().toISOString(),
                upToDate: true,
              };

              // RECHARGER le cache juste avant de sauvegarder pour √©viter les race conditions
              const latestCache = loadCache();
              latestCache[folderPath] = statsWithDate;
              saveCache(latestCache);

              // Synchroniser avec le serveur si c'est un refresh forc√©
              if (forceRefresh) {
                console.log("Forced refresh, syncing cache with server...");
                try {
                  if (window.electronAPI.syncCache) {
                    await window.electronAPI.syncCache();
                    console.log("Cache synced with server after refresh");
                  }
                } catch (syncError) {
                  console.error("Error syncing cache after refresh:", syncError);
                }
              }

              // Update the file in the list with the new size, fileCount and avgSize
              setFiles((prevFiles) =>
                prevFiles.map((file) => {
                  if (file.path === folderPath && file.type === "directory") {
                    return {
                      ...file,
                      size: result.stats.totalSize,
                      fileCount: result.stats.fileCount,
                      videoCount: result.stats.videoCount,
                      avgSize: result.stats.avgSize,
                      sizeFormatted: result.stats.totalSizeFormatted,
                      totalDuration: result.stats.totalDuration,
                      totalDurationFormatted: result.stats.totalDurationFormatted,
                      sizePerHour: result.stats.sizePerHour,
                      sizePerHourFormatted: result.stats.sizePerHourFormatted,
                      cached: true,
                      lastModified: statsWithDate.lastModified,
                      upToDate: true,
                    };
                  }
                  return file;
                })
              );

              // UPDATE SESSION CACHE: Mettre √† jour les items en cache avec les nouvelles stats
              const folderDir = folderPath.substring(0, folderPath.lastIndexOf("/")) || "/";
              console.log(`Updating session cache for folder "${folderPath}" in path "${folderDir}"`);

              if (sessionCacheRef.current[folderDir]) {
                const updatedCache = sessionCacheRef.current[folderDir].map((file) => {
                  if (file.path === folderPath && file.type === "directory") {
                    return {
                      ...file,
                      size: result.stats.totalSize,
                      fileCount: result.stats.fileCount,
                      videoCount: result.stats.videoCount,
                      avgSize: result.stats.avgSize,
                      sizeFormatted: result.stats.totalSizeFormatted,
                      totalDuration: result.stats.totalDuration,
                      totalDurationFormatted: result.stats.totalDurationFormatted,
                      sizePerHour: result.stats.sizePerHour,
                      sizePerHourFormatted: result.stats.sizePerHourFormatted,
                      cached: true,
                      lastModified: statsWithDate.lastModified,
                      upToDate: true,
                    };
                  }
                  return file;
                });

                // IMPORTANT: Mettre √† jour la ref imm√©diatement pour √©viter les race conditions
                sessionCacheRef.current = { ...sessionCacheRef.current, [folderDir]: updatedCache };
                // Utiliser la forme fonctionnelle pour mettre √† jour UNE CL√â sp√©cifique
                setSessionCache((prevCache) => ({
                  ...prevCache,
                  [folderDir]: updatedCache,
                }));
                console.log(`Session cache updated for "${folderDir}" with stats for "${folderPath}"`);
              }
            } else {
              console.error("Failed to calculate folder size:", result.error);
            }
          } catch (error) {
            console.error("Error calculating folder size:", error);
          } finally {
            // Remove from calculating state
            if (!silent) {
              setCalculatingSize((prev) => {
                const newState = { ...prev };
                delete newState[folderPath];
                return newState;
              });
            }
          }
        };

        const loadFiles = useCallback(
          async (path = "/", forceRefresh = false) => {
            setLoading(true);
            try {
              // Normaliser le chemin
              const normalizedPath = path === "/" ? "/" : path.startsWith("/") ? path : "/" + path;
              console.log(`loadFiles: "${normalizedPath}" (original: "${path}", forceRefresh=${forceRefresh})`);
              console.log(` Current session cache keys:`, Object.keys(sessionCacheRef.current));
              console.log(`Cache exists for "${normalizedPath}"?`, !!sessionCacheRef.current[normalizedPath]);

              // 1. CACHE SESSION - Si on l'a d√©j√†, on l'affiche imm√©diatement
              if (!forceRefresh && sessionCacheRef.current[normalizedPath]) {
                console.log(`CACHE HIT: ${normalizedPath}`);
                const cachedItems = sessionCacheRef.current[normalizedPath];
                console.log(`Cache contains ${cachedItems.length} items`);

                // Log quelques exemples pour voir les m√©tadonn√©es
                const sampleFolder = cachedItems.find((i) => i.type === "directory");
                if (sampleFolder) {
                  console.log(`Sample folder:`, {
                    name: sampleFolder.name,
                    size: sampleFolder.size,
                    fileCount: sampleFolder.fileCount,
                    sizeFormatted: sampleFolder.sizeFormatted,
                    cached: sampleFolder.cached,
                    upToDate: sampleFolder.upToDate,
                  });
                }
                const sampleVideo = cachedItems.find((i) => i.isVideo);
                if (sampleVideo) {
                  console.log(`Sample video:`, {
                    name: sampleVideo.name,
                    codec: sampleVideo.codec,
                    resolution: sampleVideo.resolution,
                    container: sampleVideo.container,
                  });
                }

                // Compter combien de dossiers ont des stats
                const foldersWithStats = cachedItems.filter((i) => i.type === "directory" && i.cached).length;
                const totalFolders = cachedItems.filter((i) => i.type === "directory").length;
                console.log(`Folders with cached stats: ${foldersWithStats}/${totalFolders}`);

                setFiles(cachedItems);
                setLoadedFromCache(true);
                setLoading(false);
                if (!connected) setConnected(true);
                return;
              }

              // 2. PAS DE CACHE - Charger depuis le serveur
              console.log(`LOADING from server: ${normalizedPath}`);
              setLoadedFromCache(false);

              const result = await window.electronAPI.webdavListDirectory(normalizedPath, true);

              if (!result.success) {
                console.error("ERROR: Failed:", result.error);
                setLoading(false);
                return;
              }

              console.log(`Received ${result.items?.length || 0} items from server`);

              // Log some sample items to see what data we have
              const sampleFile = result.items?.find((i) => i.type === "file");
              if (sampleFile) {
                console.log("Sample FILE:", {
                  name: sampleFile.name,
                  duration: sampleFile.duration,
                  bitrate: sampleFile.bitrate,
                  codec: sampleFile.codec,
                  resolution: sampleFile.resolution,
                  container: sampleFile.container,
                  audio: sampleFile.audio,
                  audioCodec: sampleFile.audioCodec,
                });
              }

              const sampleFolder = result.items?.find((i) => i.type === "directory");
              if (sampleFolder) {
                console.log("Sample FOLDER:", {
                  name: sampleFolder.name,
                  totalDuration: sampleFolder.totalDuration,
                  sizePerHour: sampleFolder.sizePerHour,
                  size: sampleFolder.size,
                  fileCount: sampleFolder.fileCount,
                });
              }

              // R√©cup√©rer le cache des stats
              const statsCache = loadCache();
              console.log(`statsCache has ${Object.keys(statsCache).length} entries`);

              // Log quelques exemples de cl√©s du cache pour debug
              const sampleKeys = Object.keys(statsCache).slice(0, 5);
              console.log(`Sample statsCache keys:`, sampleKeys);

              // Appliquer les stats si disponibles
              const items = (result.items || []).map((item) => {
                if (item.type === "directory") {
                  const hasStats = !!statsCache[item.path];
                  if (hasStats) {
                    const cachedStats = statsCache[item.path];

                    // VALIDATION: V√©rifier que le cache a les champs duration/sizePerHour
                    // Si le cache est ancien et n'a pas ces champs, on le consid√®re comme invalide
                    const hasDurationFields = cachedStats.hasOwnProperty("totalDuration") && cachedStats.hasOwnProperty("sizePerHour");

                    if (!hasDurationFields) {
                      console.log(`WARNING: Cache for "${item.name}" is outdated (missing duration fields) - will recalculate`);
                      return item; // Retourner l'item sans stats pour forcer le recalcul
                    }

                    return {
                      ...item,
                      size: cachedStats.totalSize,
                      fileCount: cachedStats.fileCount,
                      videoCount: cachedStats.videoCount,
                      avgSize: cachedStats.avgSize,
                      sizeFormatted: cachedStats.totalSizeFormatted,
                      totalDuration: cachedStats.totalDuration,
                      totalDurationFormatted: cachedStats.totalDurationFormatted,
                      sizePerHour: cachedStats.sizePerHour,
                      sizePerHourFormatted: cachedStats.sizePerHourFormatted,
                      cached: true,
                      upToDate: true, // Marquer comme √† jour
                    };
                  } else {
                    // Log les dossiers SANS stats pour debug
                    if (Object.keys(statsCache).length < 20 || Math.random() < 0.01) {
                      console.log(`No stats in cache for: "${item.path}" (name: "${item.name}")`);
                    }
                  }
                }
                return item;
              });

              const foldersFromCache = items.filter((i) => i.type === "directory" && i.cached).length;
              const totalFolders = items.filter((i) => i.type === "directory").length;
              console.log(`Applied stats from localStorage: ${foldersFromCache}/${totalFolders} folders have cached stats`);

              setFiles(items);
              if (!connected) setConnected(true);

              // Sauvegarder dans le session cache avec le chemin normalis√©
              // IMPORTANT: Mettre √† jour la ref imm√©diatement pour √©viter les race conditions
              sessionCacheRef.current = { ...sessionCacheRef.current, [normalizedPath]: items };
              setSessionCache((prev) => {
                const updated = { ...prev, [normalizedPath]: items };
                console.log(`SAVING to session cache: "${normalizedPath}" with ${items.length} items`);
                console.log(` Session cache now has keys:`, Object.keys(updated));
                return updated;
              });
              console.log(`Loaded ${items.length} items (${items.filter((i) => i.type === "directory").length} folders)`);

              // Calculer les stats manquantes progressivement par vagues
              // Ne calculer QUE les dossiers qui n'ont pas de stats en cache
              const foldersNeedingStats = items.filter((i) => i.type === "directory" && !i.cached && (!i.size || i.size === 0));

              if (foldersNeedingStats.length > 0) {
                // Trier par ordre alphab√©tique
                foldersNeedingStats.sort((a, b) => a.name.localeCompare(b.name));

                console.log(`Need to calculate stats for ${foldersNeedingStats.length} folders (sorted alphabetically)`);
                // Log quelques exemples de dossiers manquants
                if (foldersNeedingStats.length <= 10) {
                  console.log(
                    ` Missing stats for:`,
                    foldersNeedingStats.map((f) => f.name)
                  );
                } else {
                  console.log(
                    ` First 10 missing stats:`,
                    foldersNeedingStats.slice(0, 10).map((f) => f.name)
                  );
                }

                // Activer l'indicateur de chargement
                setCalculatingStats({ isCalculating: true, current: 0, total: foldersNeedingStats.length });

                // Calculer par vagues de 10 avec d√©lai entre chaque vague
                const batchSize = 10;
                const delayBetweenBatches = 10; // 10ms entre chaque vague

                const calculateInBatches = async (folders, startIndex = 0) => {
                  if (startIndex >= folders.length) {
                    console.log(`All folder stats calculated!`);
                    setCalculatingStats({ isCalculating: false, current: 0, total: 0 });
                    return;
                  }

                  const batch = folders.slice(startIndex, startIndex + batchSize);
                  const remaining = folders.length - startIndex - batch.length;

                  console.log(`Calculating batch ${Math.floor(startIndex / batchSize) + 1}: ${batch.length} folders (${remaining} remaining)`);

                  // Mettre √† jour le compteur
                  setCalculatingStats({ isCalculating: true, current: startIndex + batch.length, total: folders.length });

                  // ATTENDRE que TOUS les calculs du batch soient termin√©s
                  const results = await Promise.allSettled(batch.map((folder) => calculateFolderSize(folder.path, true)));

                  // Log les erreurs √©ventuelles
                  const errors = results.filter((r) => r.status === "rejected");
                  if (errors.length > 0) {
                    console.warn(
                      `WARNING: ${errors.length} folders failed in this batch:`,
                      errors.map((e) => e.reason)
                    );
                  }

                  const successful = results.filter((r) => r.status === "fulfilled").length;
                  console.log(`Batch completed: ${successful}/${batch.length} successful`);

                  // Continuer avec le prochain batch apr√®s un court d√©lai
                  if (remaining > 0) {
                    setTimeout(() => calculateInBatches(folders, startIndex + batchSize), delayBetweenBatches);
                  } else {
                    // Dernier batch termin√©
                    const totalSuccess = startIndex + successful;
                    console.log(`All batches completed: ${totalSuccess}/${folders.length} folders calculated successfully`);
                    setCalculatingStats({ isCalculating: false, current: 0, total: 0 });
                  }
                };

                // Lancer le calcul par vagues
                calculateInBatches(foldersNeedingStats);
              }
            } catch (error) {
              console.error("ERROR: Error loading files:", error);
            } finally {
              setLoading(false);
            }
          },
          [connected]
        );

        // Synchroniser le cache au montage du composant
        React.useEffect(() => {
          const initSync = async () => {
            try {
              // Nettoyer les anciennes entr√©es de cache sans les champs duration
              console.log("Cleaning outdated cache entries...");
              cleanOldCacheEntries();

              // V√©rifier si on est connect√©
              const result = await window.electronAPI.webdavConnect();
              if (result.success) {
                setConnected(true);
                // Synchroniser le cache avec le serveur
                await syncCacheWithServer();
                // Charger les fichiers de la racine (sans forcer le calcul des stats)
                await loadFiles("/");
              }
            } catch (error) {
              console.error("Error during initial sync:", error);
            }
          };

          initSync();

          // Listen for cache sync triggers from main process
          const handleCacheSyncTrigger = async () => {
            console.log("Cache sync triggered by main process");
            await syncCacheWithServer();
          };

          const handleInvalidateCache = (event) => {
            const { filepath } = event.detail || {};
            console.log(`Invalidating session cache for completed job: ${filepath}`);

            // Clear session cache completely to force reload
            setSessionCache({});
            sessionCacheRef.current = {};

            // Reload current directory
            if (currentPath) {
              console.log(`Reloading current directory: ${currentPath}`);
              loadFiles(currentPath, true); // Force refresh
            }
          };

          if (window.electronAPI.onWebdavTriggerCacheSync) {
            window.electronAPI.onWebdavTriggerCacheSync(handleCacheSyncTrigger);
          }

          // Listen for job completion events to invalidate cache
          window.addEventListener("invalidateFileTreeCache", handleInvalidateCache);

          // Cleanup listener on unmount
          return () => {
            window.removeEventListener("invalidateFileTreeCache", handleInvalidateCache);
          };
        }, []); // Execute only on mount, not on every loadFiles or currentPath change

        const connectToServer = async () => {
          try {
            const result = await window.electronAPI.webdavConnect();
            if (result.success) {
              setConnected(true);
              await loadFiles("/");
            } else {
              alert("Failed to connect: " + result.error);
            }
          } catch (error) {
            alert("Connection error: " + error.message);
          }
        };

        const navigateToFolder = (folderPath) => {
          // Normaliser le chemin : toujours commencer par /
          const normalizedPath = folderPath.startsWith("/") ? folderPath : "/" + folderPath;
          console.log(`Navigating to: ${normalizedPath} (original: ${folderPath})`);
          setCurrentPath(normalizedPath);
          setTimeout(() => loadFiles(normalizedPath), 0);
        };

        const goBack = () => {
          if (currentPath === "/") return;
          console.log(`goBack called, currentPath="${currentPath}"`);
          const pathParts = currentPath.split("/").filter((p) => p);
          console.log(`pathParts before pop:`, pathParts);
          pathParts.pop();
          console.log(`pathParts after pop:`, pathParts);
          const parentPath = pathParts.length > 0 ? "/" + pathParts.join("/") : "/";
          console.log(`Calculated parentPath="${parentPath}"`);
          navigateToFolder(parentPath);
        };

        const addToQueue = async (file) => {
          // Check if video metadata is already loaded
          const hasMetadata = file.codec && file.container && file.resolution;

          console.log("[addToQueue] File received:", file);
          console.log("[addToQueue] Has metadata:", hasMetadata);

          let fileWithMetadata = file;

          // If metadata not loaded, fetch it first
          if (!hasMetadata) {
            try {
              console.log("[addToQueue] Fetching video metadata for:", file.path);
              const result = await window.electronAPI.webdavGetFileInfo(file.path);

              console.log("[addToQueue] Metadata fetch result:", result);

              if (result.success && result.fileInfo) {
                fileWithMetadata = { ...file, ...result.fileInfo };
                console.log("[addToQueue] Metadata merged:", fileWithMetadata);
              } else {
                console.warn("[addToQueue] Failed to load metadata, proceeding with basic info");
              }
            } catch (error) {
              console.error("[addToQueue] Error loading metadata:", error);
            }
          } else {
            console.log("[addToQueue] Using existing metadata");
          }

          // Add to queue with metadata and pauseBeforeUpload setting
          const jobData = {
            ...fileWithMetadata,
            pauseBeforeUpload: pauseBeforeUpload,
          };

          console.log("[addToQueue] Sending to queue with data:", jobData);
          onAddToQueue(fileWithMetadata.path, jobData);
        };

        // Charger les m√©tadonn√©es vid√©o d'un fichier sp√©cifique
        const loadVideoInfo = async (filePath) => {
          try {
            setLoadingVideoInfo((prev) => ({ ...prev, [filePath]: true }));

            const result = await window.electronAPI.webdavGetFileInfo(filePath);

            if (result.success && result.fileInfo) {
              // Mettre √† jour le fichier dans la liste
              setFiles((prevFiles) => prevFiles.map((f) => (f.path === filePath ? { ...f, ...result.fileInfo } : f)));

              // Mettre √† jour le cache de session
              // IMPORTANT: Mettre √† jour la ref imm√©diatement pour √©viter les race conditions
              const pathFiles = sessionCacheRef.current[currentPath];
              if (pathFiles) {
                const updatedFiles = pathFiles.map((f) => (f.path === filePath ? { ...f, ...result.fileInfo } : f));
                sessionCacheRef.current = { ...sessionCacheRef.current, [currentPath]: updatedFiles };
                setSessionCache((prev) => ({
                  ...prev,
                  [currentPath]: updatedFiles,
                }));
              }
            }
          } catch (error) {
            console.error("Error loading video info:", error);
          } finally {
            setLoadingVideoInfo((prev) => {
              const newState = { ...prev };
              delete newState[filePath];
              return newState;
            });
          }
        };

        // Delete file or empty folder
        const deleteFileOrFolder = async (file) => {
          try {
            const isDirectory = file.type === "directory";

            // Check if folder is empty (if it's a directory)
            if (isDirectory) {
              // If we have stats and videoCount > 0, it's not empty
              if (file.videoCount > 0 || file.fileCount > 0) {
                alert(`‚ùå Cannot delete: Folder "${file.name}" is not empty.\n\nIt contains ${file.videoCount || 0} videos and ${file.fileCount || 0} files.`);
                return;
              }
            }

            const result = await window.electronAPI.webdavDelete(file.path, isDirectory);

            if (result.success) {
              // Remove from current file list
              setFiles((prevFiles) => prevFiles.filter((f) => f.path !== file.path));

              // Remove from session cache
              const pathFiles = sessionCacheRef.current[currentPath];
              if (pathFiles) {
                const updatedFiles = pathFiles.filter((f) => f.path !== file.path);
                sessionCacheRef.current = { ...sessionCacheRef.current, [currentPath]: updatedFiles };
                setSessionCache((prev) => ({
                  ...prev,
                  [currentPath]: updatedFiles,
                }));
              }

              alert(`‚úÖ ${isDirectory ? "Folder" : "File"} "${file.name}" deleted successfully!`);
            } else {
              alert(`‚ùå Failed to delete: ${result.error}`);
            }
          } catch (error) {
            console.error("Error deleting:", error);
            alert(`‚ùå Error: ${error.message}`);
          } finally {
            setDeleteConfirm(null);
          }
        };

        // Download file or folder to default directory
        const downloadToDefault = async (file) => {
          try {
            const isDirectory = file.type === "directory";
            const fileKey = file.path;

            setDownloading((prev) => ({ ...prev, [fileKey]: true }));

            console.log(`Starting download: ${file.name} (${isDirectory ? "folder" : "file"})`);

            const result = await window.electronAPI.webdavDownloadToDefault(file.path, isDirectory);

            if (result.success) {
              if (isDirectory) {
                alert(
                  `Folder downloaded successfully!\n\n${result.filesDownloaded} files (${result.totalSize} bytes)\n${
                    result.errors.length > 0 ? `\nWARNING: ${result.errors.length} errors occurred` : ""
                  }`
                );
              } else {
                alert(`‚úÖ File downloaded successfully!\n\n${result.message}`);
              }
            } else {
              alert(`‚ùå Download failed: ${result.error}`);
            }
          } catch (error) {
            console.error("Error downloading:", error);
            alert(`‚ùå Error: ${error.message}`);
          } finally {
            setDownloading((prev) => {
              const newState = { ...prev };
              delete newState[file.path];
              return newState;
            });
          }
        };

        const addFolderToQueue = async (folderPath) => {
          try {
            setLoading(true);
            const result = await window.electronAPI.webdavScanFolderRecursive(folderPath);

            if (result.success && result.files.length > 0) {
              let addedCount = 0;
              for (const file of result.files) {
                if (!isEncoded(file.path)) {
                  await onAddToQueue(file.path, file);
                  addedCount++;
                }
              }
              console.log(`Added ${addedCount} files to queue from folder`);
            } else if (result.success && result.files.length === 0) {
              console.log("No video files found in this folder");
            } else {
              console.error("Failed to scan folder:", result.error);
            }
          } catch (error) {
            console.error("Error scanning folder:", error.message);
          } finally {
            setLoading(false);
          }
        };

        // Fusionn√©: un seul bouton "Add" qui d√©tecte automatiquement si c'est une s√©rie ou un dossier
        const shouldShowAddButton = (folderName, filesList) => {
          // Show button for any directory (series or regular folder)
          return true;
        };

        const addToQueueSmart = async (folderPath, folderName) => {
          try {
            setLoading(true);

            // Lister le contenu du dossier cliqu√© pour d√©tecter si c'est une s√©rie
            const folderContents = await window.electronAPI.webdavListDirectory(folderPath, false);

            if (!folderContents.success) {
              alert(`Error loading folder: ${folderContents.error}`);
              return;
            }

            // D√©tecter si c'est une s√©rie (contient plusieurs dossiers Season dans CE dossier)
            const seasonFolders = folderContents.files.filter((f) => f.type === "directory" && f.name.toLowerCase().includes("season"));
            const isSeries = seasonFolders.length >= 2;

            console.log(`Folder: ${folderPath} | Seasons found: ${seasonFolders.length} | Is series: ${isSeries}`);

            if (isSeries) {
              // Mode s√©rie: ajouter tous les dossiers Season de CE dossier
              let totalAdded = 0;
              let totalSeasons = 0;

              for (const seasonFolder of seasonFolders) {
                console.log(`Scanning season: ${seasonFolder.path}`);
                const result = await window.electronAPI.webdavScanFolderRecursive(seasonFolder.path);

                if (result.success && result.files.length > 0) {
                  totalSeasons++;
                  for (const file of result.files) {
                    if (!isEncoded(file.path)) {
                      await onAddToQueue(file.path, {
                        ...file,
                        pauseBeforeUpload: pauseBeforeUpload,
                      });
                      totalAdded++;
                    }
                  }
                }
              }

              if (totalAdded > 0) {
                alert(`Added ${totalAdded} episodes from ${totalSeasons} seasons to queue!`);
              } else {
                alert("No new episodes to add (all already encoded)");
              }
            } else {
              // Mode dossier simple: ajouter tous les fichiers du dossier r√©cursivement
              console.log(`Scanning folder (non-series): ${folderPath}`);
              const result = await window.electronAPI.webdavScanFolderRecursive(folderPath);

              if (result.success && result.files.length > 0) {
                let addedCount = 0;
                for (const file of result.files) {
                  if (!isEncoded(file.path)) {
                    await onAddToQueue(file.path, {
                      ...file,
                      pauseBeforeUpload: pauseBeforeUpload,
                    });
                    addedCount++;
                  }
                }
                if (addedCount > 0) {
                  alert(`Added ${addedCount} files to queue!`);
                } else {
                  alert("No new files to add (all already encoded)");
                }
              } else if (result.success && result.files.length === 0) {
                alert("No video files found in this folder");
              } else {
                console.error("Failed to scan folder:", result.error);
                alert(`Error scanning folder: ${result.error}`);
              }
            }
          } catch (error) {
            console.error("Error adding to queue:", error);
            alert("Error adding to queue: " + error.message);
          } finally {
            setLoading(false);
          }
        };

        // Fonction pour rafra√Æchir tous les dossiers du r√©pertoire actuel
        const refreshAllFolders = async () => {
          const folders = files.filter((f) => f.type === "directory");
          if (folders.length === 0) return;

          const startTime = Date.now();
          let processed = 0;

          try {
            // Marquer tous les dossiers comme pas √† jour dans le cache
            const cache = loadCache();
            folders.forEach((folder) => {
              if (cache[folder.path]) {
                cache[folder.path].upToDate = false;
              }
            });
            saveCache(cache);

            // Recalculer tous les dossiers
            for (const folder of folders) {
              await calculateFolderSize(folder.path, true, true);
              processed++;

              // Calculer et afficher l'ETA
              const elapsed = Date.now() - startTime;
              const avgTimePerFolder = elapsed / processed;
              const remaining = folders.length - processed;
              const eta = Math.round((avgTimePerFolder * remaining) / 1000);

              console.log(`Progress: ${processed}/${folders.length} folders | ETA: ${eta}s`);
            }

            console.log(`Refreshed stats for ${folders.length} folders in ${Math.round((Date.now() - startTime) / 1000)}s`);
          } catch (error) {
            console.error("Error refreshing folders:", error);
          }
        };

        const isEncoded = (filePath) => {
          return encodedFiles.some((encoded) => encoded.path === filePath);
        };

        const formatSize = (bytes) => {
          if (!bytes || bytes === 0) return "0 B";
          const k = 1024;
          const sizes = ["B", "KB", "MB", "GB", "TB"];
          const i = Math.min(Math.floor(Math.log(bytes) / Math.log(k)), sizes.length - 1);
          return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
        };

        const sortFiles = (filesList) => {
          const sorted = [...filesList];

          if (sortBy === "size") {
            sorted.sort((a, b) => {
              // Directories first
              if (a.type !== b.type) {
                return a.type === "directory" ? -1 : 1;
              }
              // Then by size (largest first)
              return b.size - a.size;
            });
          } else if (sortBy === "fileCount") {
            sorted.sort((a, b) => {
              // Only sort directories, files stay below
              if (a.type !== b.type) {
                return a.type === "directory" ? -1 : 1;
              }
              if (a.type === "directory") {
                // Sort by file count (most files first)
                return (b.fileCount || 0) - (a.fileCount || 0);
              }
              return a.name.localeCompare(b.name);
            });
          } else if (sortBy === "avgSize") {
            sorted.sort((a, b) => {
              // Only sort directories, files stay below
              if (a.type !== b.type) {
                return a.type === "directory" ? -1 : 1;
              }
              if (a.type === "directory") {
                // Sort by average size per file (largest first)
                return (b.avgSize || 0) - (a.avgSize || 0);
              }
              return a.name.localeCompare(b.name);
            });
          } else if (sortBy === "duration") {
            sorted.sort((a, b) => {
              // Only sort directories, files stay below
              if (a.type !== b.type) {
                return a.type === "directory" ? -1 : 1;
              }
              if (a.type === "directory") {
                // Sort by total duration (longest first)
                return (b.totalDuration || 0) - (a.totalDuration || 0);
              }
              return a.name.localeCompare(b.name);
            });
          } else if (sortBy === "sizePerHour") {
            sorted.sort((a, b) => {
              // Only sort directories, files stay below
              if (a.type !== b.type) {
                return a.type === "directory" ? -1 : 1;
              }
              if (a.type === "directory") {
                // Sort by size per hour (highest quality first)
                return (b.sizePerHour || 0) - (a.sizePerHour || 0);
              }
              return a.name.localeCompare(b.name);
            });
          } else {
            // Alpha sort
            sorted.sort((a, b) => {
              // Directories first
              if (a.type !== b.type) {
                return a.type === "directory" ? -1 : 1;
              }
              // Then alphabetically
              return a.name.localeCompare(b.name);
            });
          }

          return sorted;
        };

        const filterFiles = (filesList) => {
          if (!searchTerm) return filesList;

          const term = searchTerm.toLowerCase();
          return filesList.filter((file) => file.name.toLowerCase().includes(term));
        };

        const getDisplayFiles = () => {
          let displayFiles = files;
          displayFiles = filterFiles(displayFiles);

          // Filter empty folders if option is enabled
          if (userConfig?.ui?.hide_empty_folders !== false) {
            displayFiles = displayFiles.filter((file) => {
              // Keep files (not directories)
              if (file.type !== "directory") return true;

              // Keep directories that have video files (videoCount > 0)
              if (file.videoCount && file.videoCount > 0) return true;

              // Keep directories without cached stats (we don't know if they're empty yet)
              if (!file.cached) return true;

              // Hide directories with 0 video files
              return false;
            });
          }

          displayFiles = sortFiles(displayFiles);
          return displayFiles;
        };

        return (
          <div className="bg-glass rounded-lg p-4 h-full flex flex-col">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-xl font-bold">Remote Files</h2>
              <div className="flex items-center space-x-2">
                {loading && <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-400"></div>}
                {loadedFromCache && !loading && (
                  <span className="text-xs text-green-400 bg-green-900/30 px-2 py-1 rounded" title="Directory loaded from cache">
                    üì¶ Cached
                  </span>
                )}
                <span className={connected ? "text-green-400" : "text-gray-400"}>‚óè</span>
                <span className="text-sm">{connected ? "Connected" : "Disconnected"}</span>
              </div>
            </div>

            {/* Indicateur de calcul des stats */}
            {calculatingStats.isCalculating && (
              <div className="mb-3 bg-blue-900/30 border border-blue-500/50 rounded-lg p-3 flex items-center space-x-3">
                <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-400"></div>
                <div className="flex-1">
                  <div className="text-sm text-blue-300 font-medium mb-1">
                    üìä Calculating folder statistics... {calculatingStats.current} / {calculatingStats.total}
                  </div>
                  <div className="w-full bg-gray-700 rounded-full h-2">
                    <div className="bg-blue-500 h-2 rounded-full transition-all duration-300" style={{ width: `${(calculatingStats.current / calculatingStats.total) * 100}%` }}></div>
                  </div>
                </div>
                <span className="text-xs text-blue-400">{Math.round((calculatingStats.current / calculatingStats.total) * 100)}%</span>
              </div>
            )}

            {connected && (
              <>
                {/* Search and Sort Controls */}
                <div className="mb-4 space-y-2">
                  {/* Search Bar */}
                  <div className="relative">
                    <input
                      type="text"
                      placeholder="Search files and folders..."
                      value={searchTerm}
                      onChange={(e) => setSearchTerm(e.target.value)}
                      className="w-full px-4 py-2 bg-gray-800 text-white rounded-lg border border-gray-700 focus:border-blue-500 focus:outline-none"
                    />
                    {searchTerm && (
                      <button onClick={() => setSearchTerm("")} className="absolute right-2 top-2 text-gray-400 hover:text-white">
                        ‚úï
                      </button>
                    )}
                  </div>

                  {/* Sort Controls */}
                  <div className="flex items-center space-x-2">
                    <span className="text-sm text-gray-400">Sort by:</span>
                    <button onClick={() => setSortBy("alpha")} className={`px-3 py-1 rounded text-sm ${sortBy === "alpha" ? "bg-blue-600 text-white" : "bg-gray-700 text-gray-300 hover:bg-gray-600"}`}>
                      üî§ Name
                    </button>
                    <button onClick={() => setSortBy("size")} className={`px-3 py-1 rounded text-sm ${sortBy === "size" ? "bg-blue-600 text-white" : "bg-gray-700 text-gray-300 hover:bg-gray-600"}`}>
                      üìä Size
                    </button>
                    <button
                      onClick={() => setSortBy("fileCount")}
                      className={`px-3 py-1 rounded text-sm ${sortBy === "fileCount" ? "bg-blue-600 text-white" : "bg-gray-700 text-gray-300 hover:bg-gray-600"}`}
                    >
                      üìÅ Files
                    </button>
                    <button
                      onClick={() => setSortBy("avgSize")}
                      className={`px-3 py-1 rounded text-sm ${sortBy === "avgSize" ? "bg-blue-600 text-white" : "bg-gray-700 text-gray-300 hover:bg-gray-600"}`}
                    >
                      ‚öñÔ∏è Avg/File
                    </button>
                    <button
                      onClick={() => setSortBy("duration")}
                      className={`px-3 py-1 rounded text-sm ${sortBy === "duration" ? "bg-blue-600 text-white" : "bg-gray-700 text-gray-300 hover:bg-gray-600"}`}
                      title="Sort by total duration"
                    >
                      ‚è±Ô∏è Duration
                    </button>
                    <button
                      onClick={() => setSortBy("sizePerHour")}
                      className={`px-3 py-1 rounded text-sm ${sortBy === "sizePerHour" ? "bg-blue-600 text-white" : "bg-gray-700 text-gray-300 hover:bg-gray-600"}`}
                      title="Sort by size per hour (quality metric)"
                    >
                      üìà GB/h
                    </button>
                    <span className="text-xs text-gray-500">({getDisplayFiles().length} items)</span>
                  </div>
                </div>

                {/* Navigation */}
                <div className="flex items-center justify-between mb-4">
                  <div className="flex items-center space-x-2">
                    {currentPath && currentPath !== "/" && (
                      <button onClick={goBack} className="btn-secondary">
                        ‚Üê Back
                      </button>
                    )}
                    <span className="text-sm text-gray-300">{currentPath || "/"}</span>
                  </div>
                  <div className="flex items-center space-x-2">
                    {loading ? (
                      <span className="text-xs text-blue-400 flex items-center">
                        <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-blue-400 mr-1"></div>
                        Refreshing...
                      </span>
                    ) : (
                      <button
                        onClick={async () => {
                          console.log("Refresh button clicked - reloading current directory");
                          setIsRefreshing(true);

                          try {
                            // Clear session cache to force complete reload
                            setSessionCache({});
                            sessionCacheRef.current = {};

                            // Reload current directory with force refresh to update UI
                            await loadFiles(currentPath, true);

                            // Refresh all folder stats display
                            await refreshAllFolders();
                          } catch (error) {
                            console.error("ERROR: Error during refresh:", error);
                          } finally {
                            setIsRefreshing(false);
                          }
                        }}
                        className="btn-secondary text-xs"
                        title="Refresh current directory"
                      >
                        üîÑ Refresh
                      </button>
                    )}
                  </div>
                </div>

                {/* File List */}
                <div className="flex-1 overflow-y-auto scrollbar-thin">
                  {loading ? (
                    <div className="flex items-center justify-center h-32">
                      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
                    </div>
                  ) : (
                    <div className="space-y-2">
                      {getDisplayFiles().map((file, index) => (
                        <div key={index} className="flex items-center justify-between p-3 bg-gray-800 rounded-lg hover:bg-gray-700 transition-colors">
                          <div className="flex items-center space-x-3 flex-1">
                            <span className="text-lg">{file.type === "directory" ? "üìÅ" : "üé¨"}</span>
                            <div className="flex-1">
                              <div className="font-medium">{file.name}</div>
                              <div className="text-sm text-gray-400">
                                {file.type === "directory" ? (
                                  <>
                                    {file.size > 0 || file.fileCount > 0 ? (
                                      <div className="flex flex-wrap items-center gap-2">
                                        {file.size > 0 && <span>üì¶ {file.sizeFormatted || formatSize(file.size)}</span>}
                                        {file.videoCount > 0 && <span>üé¨ {file.videoCount} videos</span>}
                                        {file.totalDuration > 0 && (
                                          <span className="bg-purple-900/40 px-2 py-0.5 rounded text-xs">
                                            ‚è±Ô∏è {file.totalDurationFormatted || `${Math.floor(file.totalDuration / 3600)}h${Math.floor((file.totalDuration % 3600) / 60)}m`}
                                          </span>
                                        )}
                                        {file.sizePerHour > 0 && (
                                          <span className="bg-green-900/40 px-2 py-0.5 rounded text-xs">üìä {file.sizePerHourFormatted || formatSize(file.sizePerHour) + "/h"}</span>
                                        )}
                                        {file.avgSize > 0 && <span className="text-xs text-gray-500">‚öñÔ∏è {formatSize(file.avgSize)}/file</span>}
                                      </div>
                                    ) : (
                                      <span>üìÇ Folder</span>
                                    )}
                                  </>
                                ) : (
                                  <>
                                    <div className="flex flex-wrap items-center gap-2">
                                      <span>üì¶ {formatSize(file.size)}</span>
                                      {file.container && <span className="bg-indigo-900/40 px-2 py-0.5 rounded text-xs">üì¶ {file.container.toUpperCase()}</span>}
                                      {file.codec && <span className="bg-blue-900/40 px-2 py-0.5 rounded text-xs">üéûÔ∏è {file.codec.toUpperCase()}</span>}
                                      {file.resolution && <span className="bg-cyan-900/40 px-2 py-0.5 rounded text-xs">üì∫ {file.resolution}</span>}
                                      {file.duration && (
                                        <span className="bg-purple-900/40 px-2 py-0.5 rounded text-xs">
                                          ‚è±Ô∏è {Math.floor(file.duration / 60)}:{String(Math.floor(file.duration % 60)).padStart(2, "0")}
                                        </span>
                                      )}
                                      {file.bitrate && file.bitrate > 0 && <span className="bg-green-900/40 px-2 py-0.5 rounded text-xs">üìä {(file.bitrate / 1000000).toFixed(1)} Mbps</span>}
                                      {file.audio > 0 && (
                                        <span className="bg-orange-900/40 px-2 py-0.5 rounded text-xs">
                                          üîä {file.audio} {file.audioCodec ? `(${file.audioCodec.toUpperCase()})` : "audio"}
                                        </span>
                                      )}
                                      {file.subtitles > 0 && <span className="bg-yellow-900/40 px-2 py-0.5 rounded text-xs">üí¨ {file.subtitles} subs</span>}
                                      {isEncoded(file.path) && <span className="text-green-400 font-semibold">‚úÖ Encoded</span>}
                                    </div>
                                  </>
                                )}
                              </div>
                            </div>
                          </div>
                          <div className="flex space-x-2">
                            {file.type === "directory" ? (
                              <>
                                <button onClick={() => navigateToFolder(file.path)} className="btn-secondary">
                                  ‚ÜòÔ∏è
                                </button>
                                {!file.cached && !calculatingSize[file.path] && (
                                  <button onClick={() => calculateFolderSize(file.path, false, false)} className="btn-secondary text-xs" title="Calculate folder size">
                                    üìä
                                  </button>
                                )}
                                {calculatingSize[file.path] && (
                                  <span className="text-xs text-blue-400 flex items-center">
                                    <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-blue-400 mr-1"></div>
                                    Calculating...
                                  </span>
                                )}
                                {file.cached && file.upToDate !== false && currentPath !== "/" && (
                                  <button onClick={() => calculateFolderSize(file.path, false, true)} className="btn-secondary text-xs" title="Force refresh folder stats">
                                    üîÑ
                                  </button>
                                )}
                                {file.cached && file.upToDate === false && (
                                  <button
                                    onClick={() => calculateFolderSize(file.path, false, true)}
                                    className="bg-yellow-600 hover:bg-yellow-500 text-white px-2 py-1 rounded text-xs"
                                    title="Stats may be outdated - click to refresh"
                                  >
                                    üîÑ
                                  </button>
                                )}
                                {/* Show add button only if not in root directory */}
                                {currentPath !== "/" && (
                                  <button onClick={() => addToQueueSmart(file.path, file.name)} className="btn-success" title="Add folder to queue (detects series automatically)">
                                    ‚ûï
                                  </button>
                                )}
                                {/* Download folder button - only show if not in root directory */}
                                {currentPath !== "/" &&
                                  (downloading[file.path] ? (
                                    <span className="text-xs text-blue-400 flex items-center px-2">
                                      <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-blue-400 mr-1"></div>
                                      Downloading...
                                    </span>
                                  ) : (
                                    <button
                                      onClick={() => downloadToDefault(file)}
                                      className="bg-blue-600 hover:bg-blue-500 text-white px-2 py-1 rounded text-xs"
                                      title="Download folder to default directory"
                                    >
                                      üì•
                                    </button>
                                  ))}
                                {/* Show delete button only for empty folders (videoCount === 0 and cached) */}
                                {file.cached && file.videoCount === 0 && file.fileCount === 0 && (
                                  <button
                                    onClick={() => setDeleteConfirm({ file, type: "folder" })}
                                    className="bg-red-600 hover:bg-red-500 text-white px-2 py-1 rounded text-xs"
                                    title="Delete this empty folder"
                                  >
                                    üóëÔ∏è
                                  </button>
                                )}
                              </>
                            ) : (
                              <>
                                <button
                                  onClick={() => addToQueue(file)}
                                  disabled={isEncoded(file.path)}
                                  className={isEncoded(file.path) ? "btn-secondary opacity-50 cursor-not-allowed" : "btn-success"}
                                >
                                  {isEncoded(file.path) ? "Encoded" : "Add to Queue"}
                                </button>
                                {/* Download file button */}
                                {downloading[file.path] ? (
                                  <span className="text-xs text-blue-400 flex items-center px-2">
                                    <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-blue-400 mr-1"></div>
                                    Downloading...
                                  </span>
                                ) : (
                                  <button onClick={() => downloadToDefault(file)} className="bg-blue-600 hover:bg-blue-500 text-white px-3 py-2 rounded" title="Download file to default directory">
                                    üì•
                                  </button>
                                )}
                                <button onClick={() => setDeleteConfirm({ file, type: "file" })} className="bg-red-600 hover:bg-red-500 text-white px-3 py-2 rounded" title="Delete this video file">
                                  üóëÔ∏è
                                </button>
                              </>
                            )}
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              </>
            )}

            {/* Delete Confirmation Modal */}
            {deleteConfirm && (
              <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onClick={() => setDeleteConfirm(null)}>
                <div className="bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4 border-2 border-red-500" onClick={(e) => e.stopPropagation()}>
                  <h3 className="text-xl font-bold mb-4 text-red-400">‚ö†Ô∏è Confirm Deletion</h3>
                  <div className="mb-4">
                    <p className="text-sm text-gray-300 mb-2">Are you sure you want to delete this {deleteConfirm.type}?</p>
                    <p className="text-sm text-gray-300 mb-2">
                      <span className="text-lg">{deleteConfirm.type === "directory" ? "üìÅ" : "üé¨"}</span> <span className="font-mono text-blue-400">{deleteConfirm.file.name}</span>
                    </p>
                    {deleteConfirm.file.size && <p className="text-sm text-gray-400">Size: {formatSize(deleteConfirm.file.size)}</p>}
                    <div className="mt-4 p-3 bg-red-900/20 border border-red-700 rounded">
                      <p className="text-sm text-red-300">
                        <strong>‚ö†Ô∏è Warning:</strong> This action cannot be undone!
                        {deleteConfirm.type === "folder" && " The folder will only be deleted if it's empty."}
                      </p>
                    </div>
                  </div>
                  <div className="flex justify-end space-x-3">
                    <button onClick={() => setDeleteConfirm(null)} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded text-white transition-colors">
                      Cancel
                    </button>
                    <button onClick={() => deleteFileOrFolder(deleteConfirm.file)} className="px-4 py-2 bg-red-600 hover:bg-red-700 rounded text-white transition-colors">
                      Delete
                    </button>
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      };

      // Encoder Info Panel Component
      const EncoderInfoPanel = ({ userConfig }) => {
        if (!userConfig || !userConfig.ffmpeg) return null;

        const ffmpegConfig = userConfig.ffmpeg;
        const videoCodec = ffmpegConfig.video_codec || "hevc_nvenc";
        const isVP9 = videoCodec.includes("vp9");
        const isGPU = videoCodec.includes("nvenc") || ffmpegConfig.force_gpu || ffmpegConfig.gpu_enabled;

        // Determine codec display name
        const codecName = isVP9 ? "VP9" : "HEVC";
        const codecBadge = isVP9 ? "üåê VP9" : "üé¨ HEVC";

        return (
          <div className="flex items-center gap-2">
            <span className="text-xs font-semibold text-gray-400">‚öôÔ∏è</span>
            <span className={`encoder-badge text-xs ${isVP9 ? "bg-green-900 text-green-300" : "bg-blue-900 text-blue-300"}`}>{codecBadge}</span>
            {isGPU ? <span className="encoder-badge encoder-badge-gpu text-xs">üéÆ GPU</span> : <span className="encoder-badge encoder-badge-cpu text-xs">üñ•Ô∏è CPU</span>}
            <div className="flex items-center gap-2 text-xs">
              <span className="text-gray-400">{isGPU ? ffmpegConfig.encode_preset || "p7" : ffmpegConfig.cpu_preset || "medium"}</span>
              <span className="text-gray-600">‚Ä¢</span>
              <span className="text-gray-400">{isGPU ? `CQ ${ffmpegConfig.cq || 18}` : `CRF ${ffmpegConfig.crf || 23}`}</span>
              {isGPU && (
                <>
                  <span className="text-gray-600">‚Ä¢</span>
                  <span className="text-gray-400">
                    {ffmpegConfig.bitrate || "5M"}/{ffmpegConfig.maxrate || "10M"}
                  </span>
                </>
              )}
            </div>
          </div>
        );
      };

      // Completed Jobs Component
      const CompletedJobs = ({ jobs, loadJobs, userConfig }) => {
        console.log("[CompletedJobs] Component rendering with", jobs?.length, "jobs");

        const [completedJobs, setCompletedJobs] = useState([]);
        const [backupStatus, setBackupStatus] = useState({});
        const [loading, setLoading] = useState(false);
        const [restoreProgress, setRestoreProgress] = useState({});
        const [showTooltip, setShowTooltip] = useState(null); // Pour afficher le tooltip d'encodage

        useEffect(() => {
          console.log("[CompletedJobs] Setting up restore progress listener");
          // Listen for restore progress updates
          window.electronAPI.onRestoreProgress((progress) => {
            setRestoreProgress((prev) => ({
              ...prev,
              [progress.jobId]: progress,
            }));
          });

          return () => {
            window.electronAPI.removeAllListeners("restore:progress");
          };
        }, []);

        useEffect(() => {
          console.log("[CompletedJobs] Jobs changed, filtering completed jobs from", jobs?.length, "total jobs");
          if (!jobs || !Array.isArray(jobs)) {
            console.error("[CompletedJobs] Invalid jobs array:", jobs);
            setCompletedJobs([]);
            return;
          }

          // Filter completed jobs
          const completed = jobs.filter((job) => job.status === "completed");
          console.log(`[CompletedJobs] Found ${completed.length} completed jobs out of ${jobs.length} total jobs`);
          setCompletedJobs(completed);

          // Check backup status for each completed job (only if not already checked)
          completed.forEach(async (job) => {
            // Skip if already checked
            if (backupStatus[job.id] !== undefined) {
              return;
            }

            const result = await window.electronAPI.backupCheckExists(job.id);
            if (result.success) {
              setBackupStatus((prev) => ({
                ...prev,
                [job.id]: result.exists,
              }));
            }
          });
        }, [jobs]);

        const handleRestore = async (jobId, source) => {
          // Find the job to get filename
          const job = completedJobs.find((j) => j.id === jobId);
          const filename = job ? job.filename || "Unknown file" : "Unknown file";

          if (!window.confirm(`Restore this file from ${source}?\n\n${filename}`)) return;

          setLoading(true);
          // Reset progress for this job
          setRestoreProgress((prev) => ({
            ...prev,
            [jobId]: { started: true, percent: 0 },
          }));

          try {
            let result;
            if (source === "server") {
              result = await window.electronAPI.restoreFromServer(jobId);
            } else {
              result = await window.electronAPI.restoreFromLocal(jobId, source);
            }

            if (result.success) {
              const message = `‚úÖ File restored successfully!\n\nüìÅ ${filename}\nüìç Source: ${source}\n\nThe file has been restored to its original location on the server.`;
              alert(message);
              // Clear progress
              setRestoreProgress((prev) => {
                const newState = { ...prev };
                delete newState[jobId];
                return newState;
              });
              // Reload jobs to update status
              await loadJobs();
            } else {
              alert(`‚ùå Failed to restore: ${result.error}`);
            }
          } catch (error) {
            alert(`‚ùå Error: ${error.message}`);
          } finally {
            setLoading(false);
            // Clear progress on error
            setRestoreProgress((prev) => {
              const newState = { ...prev };
              delete newState[jobId];
              return newState;
            });
          }
        };

        const handleDelete = async (jobId) => {
          if (!window.confirm("Permanently delete this job from history? This cannot be undone!")) return;

          setLoading(true);
          try {
            const result = await window.electronAPI.queueDeleteJob(jobId);
            if (result.success) {
              await loadJobs(); // Reload jobs list
            } else {
              alert(`‚ùå Failed to delete: ${result.error}`);
            }
          } catch (error) {
            alert(`‚ùå Error: ${error.message}`);
          } finally {
            setLoading(false);
          }
        };

        const formatSize = (bytes) => {
          if (!bytes || bytes === 0) return "0 B";
          const k = 1024;
          const sizes = ["B", "KB", "MB", "GB", "TB"];
          const i = Math.min(Math.floor(Math.log(bytes) / Math.log(k)), sizes.length - 1);
          return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
        };

        const formatDate = (dateString) => {
          if (!dateString) return "";
          return new Date(dateString).toLocaleString();
        };

        const calculateSavings = (before, after) => {
          if (!before || !after) return null;
          const saved = before - after;
          const percent = ((saved / before) * 100).toFixed(1);
          return { saved, percent };
        };

        return (
          <div className="bg-glass rounded-lg p-4 h-full flex flex-col">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-xl font-bold text-white">‚úÖ Completed Jobs ({completedJobs.length})</h2>
            </div>

            <div className="flex-1 overflow-auto">
              {completedJobs.length === 0 ? (
                <div className="text-center text-gray-400 py-8">No completed jobs yet</div>
              ) : (
                <div className="space-y-3">
                  {completedJobs.map((job) => {
                    try {
                      const savings = calculateSavings(job.size, job.size_after);
                      const status = backupStatus[job.id] || {};

                      return (
                        <div key={job.id} className="bg-gray-800 rounded-lg p-4 border border-gray-700">
                          {/* File Info */}
                          <div className="flex items-start justify-between mb-3 gap-2">
                            <div className="flex-1 min-w-0">
                              <div className="font-medium text-white truncate" title={job.filepath}>
                                {job.filepath.split("/").pop()}
                              </div>
                              <div className="text-xs text-gray-400 truncate">{job.filepath}</div>
                            </div>
                            <button
                              onClick={() => handleDelete(job.id)}
                              disabled={loading}
                              className="flex-shrink-0 px-2 py-1 bg-red-600 hover:bg-red-700 text-white text-xs rounded disabled:opacity-50"
                              title="Permanently delete from history"
                            >
                              üóëÔ∏è
                            </button>
                          </div>

                          {/* Stats - Clickable for full details */}
                          <div className="grid grid-cols-2 gap-2 text-xs mb-3">
                            <div className="relative">
                              <button
                                onClick={() => setShowTooltip(showTooltip === job.id ? null : job.id)}
                                className="cursor-pointer hover:bg-gray-700 rounded p-1 -m-1 transition-colors inline-flex items-center"
                              >
                                <span className="text-gray-400">üìπ Codec:</span>
                                <span className="text-white ml-2 font-medium">
                                  {job.codec_before} ‚Üí {job.codec_after}
                                </span>
                                <span className="text-blue-400 ml-2 text-[10px]">(click for details)</span>
                              </button>

                              {/* Tooltip complet avec toutes les infos */}
                              {showTooltip === job.id && (
                                <div className="fixed left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2 z-[9999] bg-gray-900 border-2 border-blue-500 rounded-lg shadow-2xl max-w-6xl max-h-[90vh] overflow-auto">
                                  <div className="sticky top-0 bg-gray-800 border-b border-blue-500 px-4 py-3 flex items-center justify-between">
                                    <h3 className="text-lg font-bold text-blue-400">üìä Complete Encoding Information</h3>
                                    <button onClick={() => setShowTooltip(null)} className="text-gray-400 hover:text-white text-xl leading-none">
                                      ‚úï
                                    </button>
                                  </div>

                                  <div className="p-4 space-y-4">
                                    {/* File Path & Timing */}
                                    <div className="bg-gray-800 rounded-lg p-3 border border-gray-700">
                                      <div className="flex items-start justify-between gap-4">
                                        <div className="flex-1">
                                          <div className="text-yellow-400 font-semibold mb-2">üìÅ File</div>
                                          <div className="text-xs text-gray-300 break-all">{job.filepath}</div>
                                          <div className="text-xs text-gray-400 mt-1">Completed: {formatDate(job.finished_at)}</div>
                                        </div>
                                        {/* Timing Information */}
                                        <div className="bg-gray-900 rounded-lg p-3 border border-gray-600 min-w-[280px]">
                                          <div className="text-cyan-400 font-semibold mb-2 text-sm">‚è±Ô∏è Process Duration</div>
                                          <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-xs">
                                            {(() => {
                                              const downloadTime = job.download_duration || 0;
                                              const encodeTime = job.encode_duration || 0;
                                              const uploadTime = job.upload_duration || 0;
                                              const totalTime = downloadTime + encodeTime + uploadTime;

                                              const formatDuration = (seconds) => {
                                                if (!seconds) return "N/A";
                                                const h = Math.floor(seconds / 3600);
                                                const m = Math.floor((seconds % 3600) / 60);
                                                const s = Math.floor(seconds % 60);
                                                if (h > 0) return `${h}h ${m}m ${s}s`;
                                                if (m > 0) return `${m}m ${s}s`;
                                                return `${s}s`;
                                              };

                                              return (
                                                <>
                                                  <div className="text-gray-400">Download:</div>
                                                  <div className="text-white font-mono text-right">{formatDuration(downloadTime)}</div>
                                                  <div className="text-gray-400">Encoding:</div>
                                                  <div className="text-white font-mono text-right">{formatDuration(encodeTime)}</div>
                                                  <div className="text-gray-400">Upload:</div>
                                                  <div className="text-white font-mono text-right">{formatDuration(uploadTime)}</div>
                                                  <div className="text-cyan-400 font-semibold border-t border-gray-700 pt-1">Total:</div>
                                                  <div className="text-cyan-300 font-mono font-bold text-right border-t border-gray-700 pt-1">{formatDuration(totalTime)}</div>
                                                </>
                                              );
                                            })()}
                                          </div>
                                        </div>
                                      </div>
                                    </div>

                                    {/* Before & After Comparison - Horizontal Layout */}
                                    <div className="grid grid-cols-3 gap-3">
                                      {/* BEFORE */}
                                      <div className="bg-red-900 bg-opacity-20 border border-red-700 rounded-lg p-3">
                                        <div className="text-red-400 font-semibold mb-3 flex items-center gap-2 text-sm">
                                          <span className="text-lg">üì•</span>
                                          <span>Original</span>
                                        </div>
                                        <div className="space-y-1.5 text-xs">
                                          <div className="flex justify-between">
                                            <span className="text-gray-400">Codec:</span>
                                            <span className="text-white font-mono">{job.codec_before || "N/A"}</span>
                                          </div>
                                          <div className="flex justify-between">
                                            <span className="text-gray-400">Resolution:</span>
                                            <span className="text-white font-mono">{job.resolution || "N/A"}</span>
                                          </div>
                                          <div className="flex justify-between">
                                            <span className="text-gray-400">Duration:</span>
                                            <span className="text-white font-mono">
                                              {job.duration ? `${Math.floor(job.duration / 60)}:${String(Math.floor(job.duration % 60)).padStart(2, "0")}` : "N/A"}
                                            </span>
                                          </div>
                                          <div className="flex justify-between">
                                            <span className="text-gray-400">Bitrate:</span>
                                            <span className="text-white font-mono">{job.bitrate ? `${(job.bitrate / 1000000).toFixed(1)} Mbps` : "N/A"}</span>
                                          </div>
                                          <div className="flex justify-between">
                                            <span className="text-gray-400">Audio:</span>
                                            <span className="text-white font-mono">
                                              {job.audioCodec || "N/A"} ({job.audio || 0})
                                            </span>
                                          </div>
                                          <div className="flex justify-between">
                                            <span className="text-gray-400">Subtitles:</span>
                                            <span className="text-white font-mono">{job.subtitles || 0}</span>
                                          </div>
                                          <div className="flex justify-between border-t border-red-900 pt-1.5 mt-1.5">
                                            <span className="text-gray-400 font-semibold">Size:</span>
                                            <span className="text-red-300 font-mono font-bold">{formatSize(job.size)}</span>
                                          </div>
                                        </div>
                                      </div>

                                      {/* AFTER */}
                                      <div className="bg-green-900 bg-opacity-20 border border-green-700 rounded-lg p-3">
                                        <div className="text-green-400 font-semibold mb-3 flex items-center gap-2 text-sm">
                                          <span className="text-lg">üì§</span>
                                          <span>Encoded</span>
                                        </div>
                                        <div className="space-y-1.5 text-xs">
                                          <div className="flex justify-between">
                                            <span className="text-gray-400">Codec:</span>
                                            <span className="text-white font-mono">{job.codec_after || "HEVC"}</span>
                                          </div>
                                          <div className="flex justify-between">
                                            <span className="text-gray-400">Resolution:</span>
                                            <span className="text-white font-mono">{job.resolution || "Same"}</span>
                                          </div>
                                          <div className="flex justify-between">
                                            <span className="text-gray-400">Duration:</span>
                                            <span className="text-white font-mono">
                                              {job.duration ? `${Math.floor(job.duration / 60)}:${String(Math.floor(job.duration % 60)).padStart(2, "0")}` : "Same"}
                                            </span>
                                          </div>
                                          <div className="flex justify-between">
                                            <span className="text-gray-400">Bitrate:</span>
                                            <span className="text-white font-mono">
                                              {job.size_after && job.duration ? `${((job.size_after * 8) / (job.duration * 1000000)).toFixed(1)} Mbps` : "N/A"}
                                            </span>
                                          </div>
                                          <div className="flex justify-between">
                                            <span className="text-gray-400">Audio:</span>
                                            <span className="text-white font-mono">Same</span>
                                          </div>
                                          <div className="flex justify-between">
                                            <span className="text-gray-400">Subtitles:</span>
                                            <span className="text-white font-mono">Same</span>
                                          </div>
                                          <div className="flex justify-between border-t border-green-900 pt-1.5 mt-1.5">
                                            <span className="text-gray-400 font-semibold">Size:</span>
                                            <span className="text-green-300 font-mono font-bold">{formatSize(job.size_after)}</span>
                                          </div>
                                        </div>
                                      </div>

                                      {/* SAVINGS */}
                                      <div className="bg-purple-900 bg-opacity-20 border border-purple-700 rounded-lg p-3">
                                        <div className="text-purple-400 font-semibold mb-3 flex items-center gap-2 text-sm">
                                          <span className="text-lg">üíæ</span>
                                          <span>Savings</span>
                                        </div>
                                        <div className="space-y-1.5 text-xs">
                                          {(() => {
                                            const saved = job.size - job.size_after;
                                            const percent = ((saved / job.size) * 100).toFixed(1);
                                            const isSavings = saved > 0;

                                            return (
                                              <>
                                                <div className="flex justify-between">
                                                  <span className="text-gray-400">Difference:</span>
                                                  <span className={`font-mono font-bold ${isSavings ? "text-green-400" : "text-red-400"}`}>
                                                    {isSavings ? "-" : "+"}
                                                    {formatSize(Math.abs(saved))}
                                                  </span>
                                                </div>
                                                <div className="flex justify-between">
                                                  <span className="text-gray-400">Percentage:</span>
                                                  <span className={`font-mono font-bold ${isSavings ? "text-green-400" : "text-red-400"}`}>
                                                    {isSavings ? "-" : "+"}
                                                    {Math.abs(percent)}%
                                                  </span>
                                                </div>
                                                <div className="flex justify-between">
                                                  <span className="text-gray-400">Container:</span>
                                                  <span className="text-white font-mono">MKV</span>
                                                </div>
                                                <div className="flex justify-between">
                                                  <span className="text-gray-400">Quality:</span>
                                                  <span className={`font-medium ${isSavings ? "text-green-400" : "text-yellow-400"}`}>{isSavings ? "‚úÖ Excellent" : "‚ö†Ô∏è Check"}</span>
                                                </div>
                                                <div className="border-t border-purple-900 pt-1.5 mt-1.5">
                                                  <div className="text-center">
                                                    <div className={`text-3xl font-bold mb-1 ${isSavings ? "text-green-400" : "text-red-400"}`}>
                                                      {isSavings ? "-" : "+"}
                                                      {Math.abs(percent)}%
                                                    </div>
                                                    <div className="text-gray-400 text-[10px]">{isSavings ? "Space Saved" : "Size Increased"}</div>
                                                  </div>
                                                </div>
                                              </>
                                            );
                                          })()}
                                        </div>
                                      </div>
                                    </div>

                                    {/* Encoding Settings Used */}
                                    {(() => {
                                      // Parse encoding params from job (saved during encoding)
                                      let params = null;
                                      try {
                                        params = job.encoding_params ? JSON.parse(job.encoding_params) : null;
                                      } catch (e) {
                                        console.error("Failed to parse encoding_params:", e);
                                      }

                                      // If no saved params, fall back to current config (for old jobs)
                                      const useCurrentConfig = !params && userConfig?.ffmpeg;

                                      if (!params && !useCurrentConfig) {
                                        return (
                                          <div className="bg-gray-800 rounded-lg p-3 border border-gray-700">
                                            <div className="text-gray-400 text-sm">‚ö†Ô∏è Encoding parameters not available for this job</div>
                                          </div>
                                        );
                                      }

                                      return (
                                        <div className="bg-blue-900 bg-opacity-20 border border-blue-700 rounded-lg p-3">
                                          <div className="text-blue-400 font-semibold mb-3 flex items-center gap-2">
                                            <span className="text-xl">‚öôÔ∏è</span>
                                            <span>Encoding Parameters {params ? "Used" : "(Current Config - Not Saved)"}</span>
                                          </div>
                                          <div className="grid grid-cols-2 gap-x-6 gap-y-2 text-xs">
                                            <div className="flex justify-between">
                                              <span className="text-gray-400">Encoder:</span>
                                              <span className="text-white font-medium">
                                                {params
                                                  ? params.gpu_used
                                                    ? "üéÆ NVENC (GPU)"
                                                    : "üíª x265 (CPU)"
                                                  : userConfig.ffmpeg.force_gpu || userConfig.ffmpeg.gpu_enabled
                                                  ? "üéÆ NVENC (GPU)"
                                                  : "üíª x265 (CPU)"}
                                              </span>
                                            </div>
                                            <div className="flex justify-between">
                                              <span className="text-gray-400">Preset:</span>
                                              <span className="text-white font-mono">
                                                {params
                                                  ? params.preset
                                                  : userConfig.ffmpeg.force_gpu || userConfig.ffmpeg.gpu_enabled
                                                  ? userConfig.ffmpeg.encode_preset || "p7"
                                                  : userConfig.ffmpeg.cpu_preset || "medium"}
                                              </span>
                                            </div>
                                            <div className="flex justify-between">
                                              <span className="text-gray-400">Quality:</span>
                                              <span className="text-white font-mono">
                                                {params
                                                  ? `${params.quality_type} ${params.quality}`
                                                  : userConfig.ffmpeg.force_gpu || userConfig.ffmpeg.gpu_enabled
                                                  ? "CQ " + (userConfig.ffmpeg.cq || 18)
                                                  : "CRF " + (userConfig.ffmpeg.crf || 23)}
                                              </span>
                                            </div>
                                            <div className="flex justify-between">
                                              <span className="text-gray-400">Profile:</span>
                                              <span className="text-white font-mono">{params ? params.profile : userConfig.ffmpeg.profile || "main10"}</span>
                                            </div>
                                            <div className="flex justify-between">
                                              <span className="text-gray-400">Audio Codec:</span>
                                              <span className="text-white font-mono">{params ? params.audio_codec : userConfig.ffmpeg.audio_codec || "copy"}</span>
                                            </div>
                                            <div className="flex justify-between">
                                              <span className="text-gray-400">Audio Bitrate:</span>
                                              <span className="text-white font-mono">
                                                {params
                                                  ? params.audio_bitrate
                                                    ? params.audio_bitrate + "k"
                                                    : "original"
                                                  : userConfig.ffmpeg.audio_codec !== "copy"
                                                  ? (userConfig.ffmpeg.audio_bitrate || 128) + "k"
                                                  : "original"}
                                              </span>
                                            </div>
                                            <div className="flex justify-between">
                                              <span className="text-gray-400">Two-Pass:</span>
                                              <span className={`font-medium ${(params ? params.two_pass : userConfig.ffmpeg.two_pass) ? "text-green-400" : "text-gray-400"}`}>
                                                {(params ? params.two_pass : userConfig.ffmpeg.two_pass) ? "‚úÖ Yes" : "‚ùå No"}
                                              </span>
                                            </div>

                                            {/* NVENC specific params (only if GPU was used) */}
                                            {(params ? params.gpu_used : userConfig.ffmpeg.force_gpu || userConfig.ffmpeg.gpu_enabled) && (
                                              <>
                                                <div className="flex justify-between">
                                                  <span className="text-gray-400">Avg Bitrate:</span>
                                                  <span className="text-white font-mono">{params ? params.bitrate : userConfig.ffmpeg.bitrate || "3M"}</span>
                                                </div>
                                                <div className="flex justify-between">
                                                  <span className="text-gray-400">Max Bitrate:</span>
                                                  <span className="text-white font-mono">{params ? params.maxrate : userConfig.ffmpeg.maxrate || "5M"}</span>
                                                </div>
                                                <div className="flex justify-between">
                                                  <span className="text-gray-400">RC Mode:</span>
                                                  <span className="text-white font-mono">{params ? params.rc_mode : userConfig.ffmpeg.rc_mode || "vbr_hq"}</span>
                                                </div>
                                                <div className="flex justify-between">
                                                  <span className="text-gray-400">B-Frames:</span>
                                                  <span className="text-white font-mono">{params ? params.bframes : userConfig.ffmpeg.bframes ?? 4}</span>
                                                </div>
                                                <div className="flex justify-between">
                                                  <span className="text-gray-400">Lookahead:</span>
                                                  <span className="text-white font-mono">{params ? params.lookahead : userConfig.ffmpeg.lookahead ?? 32}</span>
                                                </div>
                                                <div className="flex justify-between">
                                                  <span className="text-gray-400">Multipass:</span>
                                                  <span className="text-white font-mono">{params ? params.multipass : userConfig.ffmpeg.multipass || "fullres"}</span>
                                                </div>
                                                <div className="flex justify-between">
                                                  <span className="text-gray-400">Spatial AQ:</span>
                                                  <span className={`font-medium ${(params ? params.spatial_aq : userConfig.ffmpeg.spatial_aq !== false) ? "text-green-400" : "text-gray-400"}`}>
                                                    {(params ? params.spatial_aq : userConfig.ffmpeg.spatial_aq !== false) ? "‚úÖ" : "‚ùå"}
                                                  </span>
                                                </div>
                                                <div className="flex justify-between">
                                                  <span className="text-gray-400">Temporal AQ:</span>
                                                  <span className={`font-medium ${(params ? params.temporal_aq : userConfig.ffmpeg.temporal_aq !== false) ? "text-green-400" : "text-gray-400"}`}>
                                                    {(params ? params.temporal_aq : userConfig.ffmpeg.temporal_aq !== false) ? "‚úÖ" : "‚ùå"}
                                                  </span>
                                                </div>
                                                <div className="flex justify-between">
                                                  <span className="text-gray-400">AQ Strength:</span>
                                                  <span className="text-white font-mono">{params ? params.aq_strength : userConfig.ffmpeg.aq_strength || 8}</span>
                                                </div>
                                                <div className="flex justify-between">
                                                  <span className="text-gray-400">B-Ref Mode:</span>
                                                  <span className="text-white font-mono">{params ? params.b_ref_mode : userConfig.ffmpeg.b_ref_mode || "middle"}</span>
                                                </div>
                                              </>
                                            )}
                                          </div>
                                        </div>
                                      );
                                    })()}
                                  </div>
                                </div>
                              )}
                            </div>
                            <div>
                              <span className="text-gray-400">Size:</span>
                              <span className="text-white ml-2">
                                {formatSize(job.size)} ‚Üí {formatSize(job.size_after)}
                              </span>
                              {savings && savings.saved > 0 && <span className="text-green-400 ml-2">(-{savings.percent}%)</span>}
                              {savings && savings.saved < 0 && <span className="text-red-400 ml-2">(+{Math.abs(savings.percent)}% ‚ö†Ô∏è)</span>}
                            </div>
                            <div>
                              <span className="text-gray-400">Completed:</span>
                              <span className="text-white ml-2">{formatDate(job.finished_at)}</span>
                            </div>
                          </div>

                          {/* Backup Status & Restore Buttons */}
                          <div className="border-t border-gray-700 pt-3">
                            {/* Show restore progress if active */}
                            {restoreProgress[job.id] && restoreProgress[job.id].started && (
                              <div className="mb-3 p-2 bg-blue-900 bg-opacity-30 rounded">
                                <div className="flex items-center justify-between mb-1">
                                  <span className="text-xs text-blue-300 font-semibold">
                                    {restoreProgress[job.id].step || "Restoring..."}
                                    {restoreProgress[job.id].type === "move" ? " ‚ö°" : ` (${restoreProgress[job.id].type})`}
                                  </span>
                                  {restoreProgress[job.id].filename && <span className="text-xs text-gray-400">{restoreProgress[job.id].filename}</span>}
                                </div>
                                {restoreProgress[job.id].percent !== undefined && (
                                  <div className="mb-1">
                                    <div className="w-full bg-gray-700 rounded-full h-2">
                                      <div className="bg-blue-500 h-2 rounded-full transition-all" style={{ width: `${restoreProgress[job.id].percent}%` }} />
                                    </div>
                                  </div>
                                )}
                                {/* Only show transfer details for download/upload, not for instant move */}
                                {restoreProgress[job.id].type !== "move" && (
                                  <div className="flex items-center justify-between text-xs">
                                    <span className="text-gray-400">
                                      {restoreProgress[job.id].transferred && restoreProgress[job.id].total && (
                                        <>
                                          {formatSize(restoreProgress[job.id].transferred)} / {formatSize(restoreProgress[job.id].total)}
                                        </>
                                      )}
                                    </span>
                                    <span className="text-gray-400">
                                      {restoreProgress[job.id].speed && <>Speed: {formatSize(restoreProgress[job.id].speed)}/s</>}
                                      {restoreProgress[job.id].eta && <> ‚Ä¢ ETA: {restoreProgress[job.id].eta}</>}
                                    </span>
                                  </div>
                                )}
                                {/* Show instant move indicator */}
                                {restoreProgress[job.id].type === "move" && <div className="text-xs text-green-400 mt-1">‚ö° Instant server-side move (no data transfer)</div>}
                              </div>
                            )}

                            <div className="flex items-center justify-between">
                              <div className="flex items-center gap-3 text-xs">
                                <div className={`flex items-center gap-1 ${status.localOriginal ? "text-green-400" : "text-gray-500"}`}>
                                  <span>{status.localOriginal ? "‚úì" : "‚úó"}</span>
                                  <span>Local Original</span>
                                </div>
                                <div className={`flex items-center gap-1 ${status.localEncoded ? "text-green-400" : "text-gray-500"}`}>
                                  <span>{status.localEncoded ? "‚úì" : "‚úó"}</span>
                                  <span>Local Encoded</span>
                                </div>
                                <div className={`flex items-center gap-1 ${status.serverBackup ? "text-green-400" : "text-gray-500"}`}>
                                  <span>{status.serverBackup ? "‚úì" : "‚úó"}</span>
                                  <span>Server Backup</span>
                                </div>
                              </div>

                              <div className="flex flex-col gap-2">
                                {/* PLAYBACK GROUP */}
                                <div className="flex items-start gap-2">
                                  <span className="text-gray-400 text-xs font-semibold mr-1 min-w-[60px] pt-1">Play:</span>
                                  <div className="flex gap-2 flex-wrap">
                                    {status.localOriginal && (
                                      <button
                                        onClick={async () => {
                                          try {
                                            const result = await window.electronAPI.playOriginalFile(job.filepath);
                                            if (!result.success) {
                                              alert("Failed to open file: " + result.error);
                                            }
                                          } catch (error) {
                                            console.error("Failed to play original file:", error);
                                            alert("Failed to open file: " + error.message);
                                          }
                                        }}
                                        className="px-3 py-1 bg-gray-600 hover:bg-gray-700 text-white text-xs rounded"
                                        title="Play original file with MPV"
                                      >
                                        ‚ñ∂Ô∏è Original
                                      </button>
                                    )}
                                    {status.localEncoded && (
                                      <button
                                        onClick={async () => {
                                          try {
                                            const result = await window.electronAPI.playEncodedFile(job.filepath);
                                            if (!result.success) {
                                              alert("Failed to open file: " + result.error);
                                            }
                                          } catch (error) {
                                            console.error("Failed to play encoded file:", error);
                                            alert("Failed to open file: " + error.message);
                                          }
                                        }}
                                        className="px-3 py-1 bg-gray-600 hover:bg-gray-700 text-white text-xs rounded"
                                        title="Play encoded file with MPV"
                                      >
                                        ‚ñ∂Ô∏è Encoded
                                      </button>
                                    )}
                                  </div>
                                </div>

                                {/* COMPARISON GROUP */}
                                {status.localOriginal && status.localEncoded && (
                                  <div className="flex items-start gap-2">
                                    <span className="text-gray-400 text-xs font-semibold mr-1 min-w-[60px] pt-1">Compare:</span>
                                    <div className="flex gap-2 flex-wrap">
                                      <button
                                        onClick={async () => {
                                          try {
                                            const result = await window.electronAPI.compareWithMPV(job.filepath);
                                            if (!result.success) {
                                              alert("Failed to launch MPV: " + result.error);
                                            }
                                          } catch (error) {
                                            console.error("Failed to compare with MPV:", error);
                                            alert("Failed to launch MPV: " + error.message);
                                          }
                                        }}
                                        className="px-3 py-1 bg-purple-600 hover:bg-purple-700 text-white text-xs rounded"
                                        title="Compare original (top) and encoded (bottom) with MPV"
                                      >
                                        üîÄ Horizontal
                                      </button>
                                      <button
                                        onClick={async () => {
                                          try {
                                            const result = await window.electronAPI.compareWithMPVVertical(job.filepath);
                                            if (!result.success) {
                                              alert("Failed to launch MPV: " + result.error);
                                            }
                                          } catch (error) {
                                            console.error("Failed to compare with MPV (vertical):", error);
                                            alert("Failed to launch MPV: " + error.message);
                                          }
                                        }}
                                        className="px-3 py-1 bg-indigo-600 hover:bg-indigo-700 text-white text-xs rounded"
                                        title="Compare original (left) and encoded (right) side-by-side with MPV"
                                      >
                                        ‚öå Vertical
                                      </button>
                                      <button
                                        onClick={async () => {
                                          try {
                                            const result = await window.electronAPI.compareWithMPVInteractive(job.filepath);
                                            if (!result.success) {
                                              alert("Failed to launch MPV: " + result.error);
                                            }
                                          } catch (error) {
                                            console.error("Failed to compare (interactive):", error);
                                            alert("Failed to launch comparison: " + error.message);
                                          }
                                        }}
                                        className="px-3 py-1 bg-cyan-600 hover:bg-cyan-700 text-white text-xs rounded"
                                        title="Interactive A/B comparison - Press O to switch | F1=Original F2=Encoded"
                                      >
                                        üîÑ A/B
                                      </button>
                                    </div>
                                  </div>
                                )}

                                {/* RESTORE/UPLOAD GROUP */}
                                {(status.localOriginal || status.localEncoded || status.serverBackup) && (
                                  <div className="flex items-start gap-2">
                                    <span className="text-gray-400 text-xs font-semibold mr-1 min-w-[60px] pt-1">Restore:</span>
                                    <div className="flex gap-2 flex-wrap">
                                      {status.localOriginal && (
                                        <button
                                          onClick={() => handleRestore(job.id, "original")}
                                          disabled={loading || (restoreProgress[job.id] && restoreProgress[job.id].started)}
                                          className="px-3 py-1 bg-yellow-600 hover:bg-yellow-700 text-white text-xs rounded disabled:opacity-50"
                                          title="Restore original file from local backup"
                                        >
                                          ‚¨ÜÔ∏è Original
                                        </button>
                                      )}
                                      {status.localEncoded && (
                                        <button
                                          onClick={() => handleRestore(job.id, "encoded")}
                                          disabled={loading || (restoreProgress[job.id] && restoreProgress[job.id].started)}
                                          className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white text-xs rounded disabled:opacity-50"
                                          title="Re-upload encoded file from local backup"
                                        >
                                          ‚¨ÜÔ∏è Encoded
                                        </button>
                                      )}
                                      {status.serverBackup && (
                                        <button
                                          onClick={() => handleRestore(job.id, "server")}
                                          disabled={loading || (restoreProgress[job.id] && restoreProgress[job.id].started)}
                                          className="px-3 py-1 bg-purple-600 hover:bg-purple-700 text-white text-xs rounded disabled:opacity-50"
                                          title="Restore from server backup (.bak.<ext>)"
                                        >
                                          ‚Ü©Ô∏è Server Backup
                                        </button>
                                      )}
                                    </div>
                                  </div>
                                )}
                              </div>
                            </div>
                          </div>
                        </div>
                      );
                    } catch (error) {
                      console.error("[CompletedJobs] Error rendering job:", job?.id, error);
                      return (
                        <div key={job?.id || Math.random()} className="bg-red-900 rounded-lg p-4 border border-red-700">
                          <div className="text-red-300">Error rendering job: {error.message}</div>
                        </div>
                      );
                    }
                  })}
                </div>
              )}
            </div>
          </div>
        );
      };

      // Queue Table Component
      const QueueTable = ({ jobs, onRemoveJob, onRetryJob, progressData, queueStatus, userConfig, setQueueStatus, loadJobs, loadQueueStatus, setJobs, loadStats }) => {
        // Filter out completed jobs - only show active queue
        const queueJobs = jobs.filter((job) => job.status !== "completed");

        const formatSize = (bytes) => {
          if (!bytes || bytes === 0) return "0 B";
          const k = 1024;
          const sizes = ["B", "KB", "MB", "GB", "TB"];
          const i = Math.min(Math.floor(Math.log(bytes) / Math.log(k)), sizes.length - 1);
          return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
        };

        const getJobProgress = (jobId) => {
          return progressData[jobId] || { progress: 0, type: null, eta: null };
        };

        const formatDuration = (seconds) => {
          if (!seconds) return "";
          const hours = Math.floor(seconds / 3600);
          const minutes = Math.floor((seconds % 3600) / 60);
          if (hours > 0) {
            return `${hours}h ${minutes}m`;
          } else {
            return `${minutes}m`;
          }
        };

        return (
          <div className="bg-glass rounded-lg p-4 h-full flex flex-col">
            {/* Queue Control Panel */}
            <div className="bg-gray-800 rounded-lg p-4 mb-4 border-2 border-gray-700">
              {/* Status and Control */}
              <div className="flex items-center justify-between">
                <div className="flex items-center space-x-3">
                  {/* Start/Stop Button (fusionn√© avec status) */}
                  <button
                    onClick={async () => {
                      try {
                        setQueueStatus((prev) => ({ ...prev, loading: true }));

                        if (queueStatus.isRunning) {
                          // Arr√™ter : annuler tout et remettre √† z√©ro
                          const result = await window.electronAPI.queueStop();
                          if (result.success) {
                            // Recharger tous les jobs pour remettre ceux en cours √† "waiting"
                            await loadJobs();
                            await loadQueueStatus();
                            // Forcer la mise √† jour du status
                            setQueueStatus((prev) => ({ ...prev, isRunning: false, isPaused: false, currentJob: null }));
                            console.log("Queue arr√™t√©e - Jobs en cours remis √† z√©ro");
                          }
                        } else {
                          // D√©marrer
                          const result = await window.electronAPI.queueStart();
                          if (result.success) {
                            await loadQueueStatus();
                            // Forcer la mise √† jour du status
                            setQueueStatus((prev) => ({ ...prev, isRunning: true }));
                            console.log("Queue d√©marr√©e");
                          }
                        }
                      } catch (error) {
                        console.error("Toggle queue error:", error);
                      } finally {
                        setQueueStatus((prev) => ({ ...prev, loading: false }));
                      }
                    }}
                    className={`font-semibold py-3 px-6 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center space-x-3 text-lg ${
                      !queueStatus.isRunning ? "bg-green-600 hover:bg-green-700 text-white" : "bg-red-600 hover:bg-red-700 text-white animate-pulse"
                    }`}
                    disabled={queueStatus.loading || (!queueStatus.isRunning && jobs.length === 0)}
                    title={!queueStatus.isRunning ? "D√©marrer la queue" : "Arr√™ter la queue"}
                  >
                    <span className="text-2xl">{!queueStatus.isRunning ? "‚ñ∂Ô∏è" : "‚èπÔ∏è"}</span>
                    <span>{queueStatus.loading ? (queueStatus.isRunning ? "Arr√™t..." : "D√©marrage...") : queueStatus.isRunning ? "ARR√äTER" : "D√âMARRER"}</span>
                  </button>

                  {/* Current Job Info */}
                  {queueStatus.isRunning && queueStatus.currentJob && (
                    <div className="text-sm text-gray-300">
                      <span className="text-gray-500">‚Üí</span> {queueStatus.currentJob.filepath?.split("/").pop() || "Processing..."}
                    </div>
                  )}
                </div>

                <div className="flex items-center gap-2">
                  <span className="text-sm text-gray-400">
                    {jobs.length} fichier{jobs.length > 1 ? "s" : ""}
                  </span>

                  {/* Clear Queue Button */}
                  {jobs.length > 0 && (
                    <button
                      onClick={async () => {
                        // Count only non-completed jobs
                        const queueJobsCount = jobs.filter((job) => job.status !== "completed").length;

                        if (queueJobsCount === 0) {
                          alert("‚ö†Ô∏è La queue ne contient que des jobs compl√©t√©s. Utilisez l'onglet 'Completed' pour g√©rer l'historique.");
                          return;
                        }

                        if (window.confirm(`√ätes-vous s√ªr de vouloir vider la queue ?\n\n${queueJobsCount} jobs seront supprim√©s.\n\nNote: Les jobs compl√©t√©s seront conserv√©s dans l'historique.`)) {
                          try {
                            setQueueStatus((prev) => ({ ...prev, loading: true }));
                            const result = await window.electronAPI.queueClear();
                            if (result.success) {
                              console.log(`${result.count} jobs supprim√©s de la queue`);
                              await loadJobs();
                              await loadQueueStatus();
                              await loadStats();
                            } else {
                              console.error(`Erreur: ${result.error}`);
                            }
                          } catch (error) {
                            console.error("Failed to clear queue:", error);
                          } finally {
                            setQueueStatus((prev) => ({ ...prev, loading: false }));
                          }
                        }
                      }}
                      className="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                      disabled={queueStatus.loading}
                      title="Vider la queue (conserve les jobs compl√©t√©s)"
                    >
                      üóëÔ∏è Vider
                    </button>
                  )}
                </div>
              </div>
            </div>

            {/* Queue Status Indicator */}
            {queueStatus.isRunning && queueStatus.currentJob && (
              <div className="mb-3 p-3 bg-blue-900 bg-opacity-50 rounded-lg">
                <div className="flex items-center justify-between">
                  <div className="flex items-center">
                    <div className={`rounded-full h-2 w-2 mr-2 ${queueStatus.isPaused ? "bg-yellow-400" : "animate-pulse bg-blue-400"}`}></div>
                    <span className="text-sm text-blue-300">
                      {queueStatus.isPaused ? "‚è∏Ô∏è Paused: " : "üé¨ Encoding: "}
                      {queueStatus.currentJob.filepath?.split("/").pop() || "Processing..."}
                    </span>
                  </div>
                  {queueStatus.currentJob.started_at && <span className="text-xs text-blue-400">Started: {new Date(queueStatus.currentJob.started_at).toLocaleTimeString()}</span>}
                </div>
              </div>
            )}

            <div className="flex-1 overflow-y-auto scrollbar-thin">
              {queueJobs.length === 0 ? (
                <div className="flex items-center justify-center h-32 text-gray-400">No jobs in queue</div>
              ) : (
                <div className="space-y-3">
                  {[...queueJobs]
                    .sort((a, b) => {
                      // Sort by status first: awaiting_approval > encoding > downloading > ready_encode > uploading > ready_upload > waiting > paused > completed > failed
                      const statusOrder = {
                        awaiting_approval: 0,
                        encoding: 1,
                        downloading: 2,
                        ready_encode: 3,
                        uploading: 4,
                        ready_upload: 5,
                        waiting: 6,
                        paused: 7,
                        completed: 8,
                        failed: 9,
                      };
                      const statusDiff = (statusOrder[a.status] || 99) - (statusOrder[b.status] || 99);
                      if (statusDiff !== 0) return statusDiff;

                      // Then sort alphabetically by filename
                      const nameA = a.filepath.split("/").pop().toLowerCase();
                      const nameB = b.filepath.split("/").pop().toLowerCase();
                      return nameA.localeCompare(nameB);
                    })
                    .map((job) => {
                      const progress = getJobProgress(job.id);
                      return (
                        <div key={job.id} className="bg-gray-800 rounded-lg p-3">
                          <div className="flex items-start justify-between mb-2">
                            <div className="flex-1">
                              <div className="font-medium text-white mb-1 flex items-center gap-2">
                                <span>{job.filepath.split("/").pop()}</span>
                                {userConfig?.ffmpeg && (
                                  <span
                                    className="text-xs bg-blue-900/40 px-2 py-0.5 rounded cursor-help"
                                    title={
                                      `Encoding Settings:\n` +
                                      `Encoder: ${userConfig.ffmpeg.force_gpu || userConfig.ffmpeg.gpu_enabled ? "NVENC (GPU)" : "x265 (CPU)"}\n` +
                                      `Preset: ${userConfig.ffmpeg.force_gpu || userConfig.ffmpeg.gpu_enabled ? userConfig.ffmpeg.encode_preset || "p7" : userConfig.ffmpeg.cpu_preset || "medium"}\n` +
                                      `Quality: ${userConfig.ffmpeg.force_gpu || userConfig.ffmpeg.gpu_enabled ? "CQ " + (userConfig.ffmpeg.cq || 18) : "CRF " + (userConfig.ffmpeg.cpu_crf || 23)}\n` +
                                      `Bitrate: ${userConfig.ffmpeg.bitrate || "5M"} / ${userConfig.ffmpeg.maxrate || "10M"}`
                                    }
                                  >
                                    ‚öôÔ∏è {userConfig.ffmpeg.force_gpu || userConfig.ffmpeg.gpu_enabled ? "NVENC" : "x265"}
                                  </span>
                                )}
                              </div>
                              <div className="flex flex-wrap items-center gap-2 text-xs">
                                <span className="bg-gray-700 px-2 py-0.5 rounded">üì¶ {formatSize(job.size)}</span>
                                {job.container && <span className="bg-indigo-900/40 px-2 py-0.5 rounded">üì¶ {job.container.toUpperCase()}</span>}
                                {job.codec_before && <span className="bg-blue-900/40 px-2 py-0.5 rounded">üéûÔ∏è {job.codec_before.toUpperCase()}</span>}
                                {job.resolution && <span className="bg-cyan-900/40 px-2 py-0.5 rounded">üì∫ {job.resolution}</span>}
                                {job.duration && (
                                  <span className="bg-purple-900/40 px-2 py-0.5 rounded">
                                    ‚è±Ô∏è {Math.floor(job.duration / 60)}:{String(Math.floor(job.duration % 60)).padStart(2, "0")}
                                  </span>
                                )}
                                {job.bitrate && job.bitrate > 0 && <span className="bg-green-900/40 px-2 py-0.5 rounded">üìä {(job.bitrate / 1000000).toFixed(1)} Mbps</span>}
                                {job.audio > 0 && (
                                  <span className="bg-orange-900/40 px-2 py-0.5 rounded">
                                    üîä {job.audio} {job.audioCodec ? `(${job.audioCodec.toUpperCase()})` : "audio"}
                                  </span>
                                )}
                                {job.subtitles > 0 && <span className="bg-yellow-900/40 px-2 py-0.5 rounded">üí¨ {job.subtitles} subs</span>}
                                {job.started_at && <span className="bg-gray-700 px-2 py-0.5 rounded">üïê {new Date(job.started_at).toLocaleTimeString()}</span>}
                                {job.pause_before_upload === 1 && job.status !== "awaiting_approval" && job.status !== "completed" && (
                                  <span className="bg-orange-900/40 px-2 py-0.5 rounded" title="Will pause for manual review after encoding">
                                    ‚è∏Ô∏è Review
                                  </span>
                                )}
                              </div>

                              {/* Metadata Comparison for Completed Jobs */}
                              {job.status === "completed" && job.codec_after && job.size_after && (
                                <div className="mt-2 p-2 bg-gray-700/50 rounded border border-green-900/30">
                                  <div className="flex items-center justify-between mb-1.5">
                                    <div className="text-xs font-semibold text-green-400">‚úÖ Compressed</div>
                                    <div className="text-xs text-green-400 font-bold">
                                      -{((1 - job.size_after / job.size) * 100).toFixed(1)}% ‚Ä¢ {formatSize(job.size - job.size_after)} saved
                                    </div>
                                  </div>
                                  <div className="grid grid-cols-2 gap-3 text-xs">
                                    <div className="space-y-0.5">
                                      <div className="text-gray-500 font-medium">Before:</div>
                                      <div className="text-gray-300">
                                        {formatSize(job.size)} ‚Ä¢ {job.codec_before?.toUpperCase()}
                                      </div>
                                      {job.bitrate && <div className="text-gray-400">{(job.bitrate / 1000000).toFixed(1)} Mbps</div>}
                                    </div>
                                    <div className="space-y-0.5">
                                      <div className="text-gray-500 font-medium">After:</div>
                                      <div className="text-green-400 font-semibold">
                                        {formatSize(job.size_after)} ‚Ä¢ {job.codec_after?.toUpperCase()}
                                      </div>
                                      {job.bitrate_after && <div className="text-green-400">{(job.bitrate_after / 1000000).toFixed(1)} Mbps</div>}
                                    </div>
                                  </div>
                                </div>
                              )}

                              {/* Metadata Comparison for Awaiting Approval */}
                              {job.status === "awaiting_approval" && job.codec_after && (
                                <div className="mt-2 p-2 bg-yellow-900/20 rounded border border-yellow-600/50">
                                  <div className="flex items-center justify-between mb-1.5">
                                    <div className="text-xs font-semibold text-yellow-400">‚è∏Ô∏è Review Required</div>
                                    <div className="text-xs text-yellow-400 font-bold">
                                      -{((1 - job.size_after / job.size) * 100).toFixed(1)}% ‚Ä¢ {formatSize(job.size - job.size_after)} saved
                                    </div>
                                  </div>
                                  <div className="grid grid-cols-2 gap-3 text-xs">
                                    <div className="space-y-0.5">
                                      <div className="text-gray-400 font-medium">Original:</div>
                                      <div className="text-white">
                                        {formatSize(job.size)} ‚Ä¢ {job.codec_before?.toUpperCase()}
                                      </div>
                                      {job.bitrate && <div className="text-gray-400">{(job.bitrate / 1000000).toFixed(1)} Mbps</div>}
                                    </div>
                                    <div className="space-y-0.5">
                                      <div className="text-gray-400 font-medium">Encoded:</div>
                                      <div className="text-green-400 font-semibold">
                                        {formatSize(job.size_after)} ‚Ä¢ {job.codec_after?.toUpperCase()}
                                      </div>
                                      {job.bitrate_after && <div className="text-green-400">{(job.bitrate_after / 1000000).toFixed(1)} Mbps</div>}
                                    </div>
                                  </div>
                                </div>
                              )}
                            </div>

                            {/* Status Badge - Only show if not in processing/awaiting state */}
                            {!(job.status === "downloading" || job.status === "encoding" || job.status === "uploading" || job.status === "awaiting_approval") && (
                              <div className="ml-3">
                                <StatusBadge status={job.status} />
                              </div>
                            )}
                          </div>

                          {/* Action buttons - Full width below */}
                          <div className="flex space-x-2 mt-2">
                            {/* Awaiting Approval - Play buttons THEN Approve/Reject */}
                            {job.status === "awaiting_approval" && (
                              <>
                                <button
                                  onClick={async () => {
                                    console.log("Play encoded - job.filepath:", job.filepath);
                                    const result = await window.electronAPI.playEncodedFile(job.filepath);
                                    console.log("Play encoded - result:", result);
                                    if (!result.success) {
                                      alert(`Erreur: ${result.error}`);
                                    }
                                  }}
                                  className="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1.5 rounded text-sm transition-colors"
                                  title="Play encoded file with MPV"
                                >
                                  ‚ñ∂Ô∏è Encod√©
                                </button>
                                <button
                                  onClick={async () => {
                                    console.log("Play original - job.filepath:", job.filepath);
                                    const result = await window.electronAPI.playOriginalFile(job.filepath);
                                    console.log("Play original - result:", result);
                                    if (!result.success) {
                                      alert(`Erreur: ${result.error}`);
                                    }
                                  }}
                                  className="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1.5 rounded text-sm transition-colors"
                                  title="Play original file with MPV"
                                >
                                  ‚ñ∂Ô∏è Original
                                </button>
                                <div className="border-l border-gray-600 h-8 mx-1"></div>
                                <button
                                  onClick={async () => {
                                    try {
                                      await window.electronAPI.queueApproveJob(job.id);
                                      loadJobs();
                                    } catch (error) {
                                      console.error("Failed to approve job:", error);
                                    }
                                  }}
                                  className="bg-green-600 hover:bg-green-700 text-white px-3 py-1.5 rounded text-sm transition-colors flex items-center space-x-1"
                                  title="Approve and proceed to upload"
                                >
                                  <span>‚úÖ</span>
                                  <span>Approve</span>
                                </button>
                                <button
                                  onClick={async () => {
                                    try {
                                      await window.electronAPI.queueRejectJob(job.id);
                                      loadJobs();
                                    } catch (error) {
                                      console.error("Failed to reject job:", error);
                                    }
                                  }}
                                  className="bg-orange-600 hover:bg-orange-700 text-white px-3 py-1.5 rounded text-sm transition-colors flex items-center space-x-1"
                                  title="Reject and re-encode"
                                >
                                  <span>üîÑ</span>
                                  <span>Re-encode</span>
                                </button>
                              </>
                            )}

                            {/* Completed jobs - Play buttons */}
                            {job.status === "completed" && (
                              <>
                                <button
                                  onClick={async () => {
                                    console.log("Play encoded - job.filepath:", job.filepath);
                                    const result = await window.electronAPI.playEncodedFile(job.filepath);
                                    console.log("Play encoded - result:", result);
                                    if (!result.success) {
                                      alert(`Erreur: ${result.error}`);
                                    }
                                  }}
                                  className="bg-green-600 hover:bg-green-700 text-white px-3 py-1.5 rounded text-sm transition-colors"
                                  title="Play encoded file with MPV"
                                >
                                  ‚ñ∂Ô∏è Encod√©
                                </button>
                                <button
                                  onClick={async () => {
                                    console.log("Play original - job.filepath:", job.filepath);
                                    const result = await window.electronAPI.playOriginalFile(job.filepath);
                                    console.log("Play original - result:", result);
                                    if (!result.success) {
                                      alert(`Erreur: ${result.error}`);
                                    }
                                  }}
                                  className="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1.5 rounded text-sm transition-colors"
                                  title="Play original file with MPV"
                                >
                                  ‚ñ∂Ô∏è Original
                                </button>
                              </>
                            )}

                            {/* Failed or ready jobs - Retry button */}
                            {/* Only show retry for failed jobs if they at least started downloading (have started_at) */}
                            {/* Show for ready_encode, ready_upload, paused states (but NOT waiting) */}
                            {((job.status === "failed" && job.started_at) || job.status === "ready_encode" || job.status === "ready_upload" || job.status === "paused") && (
                              <button onClick={() => onRetryJob(job.id)} className="bg-green-600 hover:bg-green-700 text-white px-3 py-1.5 rounded text-sm transition-colors" title="R√©essayer">
                                üîÑ R√©essayer
                              </button>
                            )}

                            {/* Processing jobs - Status indicator */}
                            {(job.status === "downloading" || job.status === "encoding" || job.status === "uploading") && (
                              <div className="bg-blue-600 text-white px-3 py-1.5 rounded text-sm flex items-center space-x-2">
                                <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-white"></div>
                                <span>{job.status === "downloading" ? "T√©l√©chargement..." : job.status === "encoding" ? "Encodage..." : "Upload..."}</span>
                              </div>
                            )}

                            {/* Remove button - always available */}
                            <button onClick={() => onRemoveJob(job.id)} className="bg-red-600 hover:bg-red-700 text-white px-3 py-1.5 rounded text-sm transition-colors ml-auto" title="Supprimer">
                              üóëÔ∏è
                            </button>
                          </div>
                          {/* Progress Bar */}
                          {(job.status === "downloading" || job.status === "encoding" || job.status === "uploading") && (
                            <div className="mb-2">
                              {console.log(`[Queue] Job ${job.id} status=${job.status}, progressData:`, progress)}
                              <ProgressBar
                                progress={progress.progress || job.progress || 0}
                                type={progress.type}
                                eta={progress.eta}
                                fps={progress.fps}
                                speed={progress.speed}
                                elapsedTime={progress.elapsedTime}
                                currentTime={progress.currentTime}
                                totalDuration={progress.totalDuration}
                              />
                            </div>
                          )}
                          {/* Error Message */}
                          {job.error && <div className="mt-2 p-2 bg-red-900 rounded text-red-200 text-sm">{job.error}</div>}
                        </div>
                      );
                    })}
                </div>
              )}
            </div>
          </div>
        );
      };

      // Status Bar Component
      const StatusBar = ({ stats, isConnected }) => {
        return (
          <div className="bg-gray-900 px-4 py-2 flex items-center justify-between text-sm">
            <div className="flex items-center space-x-6">
              <div className="flex items-center space-x-2">
                <span className={`w-2 h-2 rounded-full ${isConnected ? "bg-green-500" : "bg-red-500"}`}></span>
                <span>{isConnected ? "Connected" : "Disconnected"}</span>
              </div>
              <span>
                Queue: {stats.waiting || 0} waiting, {stats.processing || 0} processing
              </span>
              <span>Completed: {stats.completed || 0}</span>
              {stats.failed > 0 && <span className="text-red-400">Failed: {stats.failed}</span>}
            </div>
            <div className="text-gray-400">Sharkoder v1.0.0</div>
          </div>
        );
      };

      // Settings Component
      const SettingsPanel = ({ userConfig, onSave, onClose }) => {
        // Initialize with modern structured config matching backend/config.js
        const defaultConfig = {
          ffmpeg: {
            video_codec: "hevc_nvenc", // Default codec: HEVC GPU
            gpu_enabled: true,
            force_gpu: false,
            gpu_limit: 100,
            encode_preset: "p7",
            cq: 24,
            rc_mode: "vbr_hq",
            bitrate: "5",
            maxrate: "8",
            lookahead: 32,
            bframes: 3,
            b_ref_mode: "middle",
            spatial_aq: true,
            temporal_aq: true,
            aq_strength: 8,
            multipass: "fullres",
            cpu_preset: "medium",
            crf: 23,
            audio_codec: "copy",
            audio_bitrate: 192,
            two_pass: true,
            tune: null,
            profile: "main10",
          },
          remote: {
            transfer_method: "auto",
            sftp: {
              host: "",
              user: "",
              password: "",
              path: "/",
            },
            webdav: {
              url: "",
              username: "",
              password: "",
              path: "/",
            },
          },
          storage: {
            local_temp: "",
            local_backup: "",
            download_path: "",
          },
          advanced: {
            connection: {
              max_concurrent_downloads: 1,
              max_prefetch_files: 1,
              retry_attempts: 2,
              connection_timeout: 30000,
            },
            behavior: {
              log_level: "info",
              auto_start_queue: false,
              verify_checksums: true,
              create_backups: false,
              extract_video_duration: false,
              release_tag: "",
              keep_encoded: true,
              keep_original: true,
              simulation_mode: false,
            },
          },
          ui: {
            show_notifications: true,
            auto_refresh_interval: 5000,
            hide_empty_folders: true,
            theme: "dark",
          },
          notification_settings: {
            show_completion_notifications: true,
            show_error_notifications: true,
            minimize_to_tray: true,
          },
        };

        const [config, setConfig] = useState({ ...defaultConfig, ...userConfig });
        const [activeTab, setActiveTab] = useState("ffmpeg");
        const [connectionStatus, setConnectionStatus] = useState({ testing: false, message: "", success: null });
        const [webdavConnectionStatus, setWebdavConnectionStatus] = useState({ testing: false, message: "", success: null });

        const updateConfig = (path, value) => {
          const newConfig = { ...config };
          const keys = path.split(".");
          let current = newConfig;
          for (let i = 0; i < keys.length - 1; i++) {
            if (!current[keys[i]]) current[keys[i]] = {};
            current = current[keys[i]];
          }
          current[keys[keys.length - 1]] = value;
          setConfig(newConfig);
        };

        const updateConfigNested = (parent, key, value) => {
          const newConfig = { ...config };
          if (!newConfig[parent]) newConfig[parent] = {};
          newConfig[parent] = { ...newConfig[parent], [key]: value };
          setConfig(newConfig);
        };

        const saveFFmpegPresetToServer = async () => {
          try {
            // Extract FFmpeg settings
            const ffmpegPreset = {
              ffmpeg: config.ffmpeg,
              encode_preset: config.encode_preset,
              cq: config.cq,
              cpu_preset: config.cpu_preset,
              cpu_crf: config.cpu_crf,
              saved_at: new Date().toISOString(),
              version: "1.0",
            };

            const result = await window.electronAPI.saveFFmpegPreset(ffmpegPreset);

            if (result.success) {
              alert(`‚úÖ Preset FFmpeg sauvegard√© sur le serveur!\n\nFichier: ${result.path}`);
            } else {
              alert(`‚ùå Erreur lors de la sauvegarde: ${result.error}`);
            }
          } catch (error) {
            console.error("Error saving FFmpeg preset:", error);
            alert(`‚ùå Erreur: ${error.message}`);
          }
        };

        const loadFFmpegPresetFromServer = async () => {
          try {
            const result = await window.electronAPI.loadFFmpegPreset();

            if (result.success) {
              // Apply the loaded preset to current config
              const preset = result.preset;

              if (preset.ffmpeg) {
                setConfig((prev) => ({
                  ...prev,
                  ffmpeg: preset.ffmpeg,
                  encode_preset: preset.encode_preset || prev.encode_preset,
                  cq: preset.cq || prev.cq,
                  cpu_preset: preset.cpu_preset || prev.cpu_preset,
                  cpu_crf: preset.cpu_crf || prev.cpu_crf,
                }));

                alert(`‚úÖ Preset FFmpeg charg√© depuis le serveur!\n\nSauvegard√© le: ${new Date(preset.saved_at).toLocaleString()}`);
              } else {
                alert("‚ö†Ô∏è Le preset charg√© ne contient pas de param√®tres FFmpeg valides");
              }
            } else {
              alert(`‚ùå Erreur lors du chargement: ${result.error}`);
            }
          } catch (error) {
            console.error("Error loading FFmpeg preset:", error);
            alert(`‚ùå Erreur: ${error.message}`);
          }
        };

        const handleSave = () => {
          onSave(config);
          onClose();
        };

        const testConnection = async () => {
          setConnectionStatus({ testing: true, message: "Testing connection...", success: null });

          try {
            // Save config first to test with latest values
            await window.electronAPI.configSaveUserConfig(config);

            // Try to connect
            const result = await window.electronAPI.sftpConnect();

            if (result.success) {
              setConnectionStatus({
                testing: false,
                message: "‚úÖ Connection successful!",
                success: true,
              });
            } else {
              setConnectionStatus({
                testing: false,
                message: `‚ùå Connection failed: ${result.error}`,
                success: false,
              });
            }
          } catch (error) {
            setConnectionStatus({
              testing: false,
              message: `‚ùå Error: ${error.message}`,
              success: false,
            });
          }

          // Clear message after 5 seconds
          setTimeout(() => {
            setConnectionStatus({ testing: false, message: "", success: null });
          }, 5000);
        };

        return (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-gray-800 rounded-lg w-3/4 max-h-[90vh] overflow-hidden flex flex-col">
              {/* Header */}
              <div className="px-6 py-4 border-b border-gray-700 flex items-center justify-between">
                <h2 className="text-xl font-bold">‚öôÔ∏è Settings</h2>
                <button onClick={onClose} className="text-gray-400 hover:text-white">
                  ‚úï
                </button>
              </div>

              {/* Tabs */}
              <div className="flex border-b border-gray-700 overflow-x-auto">
                <button onClick={() => setActiveTab("ffmpeg")} className={`px-6 py-3 whitespace-nowrap ${activeTab === "ffmpeg" ? "border-b-2 border-blue-500 text-blue-500" : "text-gray-400"}`}>
                  üé¨ FFmpeg
                </button>
                <button onClick={() => setActiveTab("remote")} className={`px-6 py-3 whitespace-nowrap ${activeTab === "remote" ? "border-b-2 border-blue-500 text-blue-500" : "text-gray-400"}`}>
                  üåê Remote Server
                </button>
                <button onClick={() => setActiveTab("storage")} className={`px-6 py-3 whitespace-nowrap ${activeTab === "storage" ? "border-b-2 border-blue-500 text-blue-500" : "text-gray-400"}`}>
                  üíæ Storage
                </button>
                <button onClick={() => setActiveTab("advanced")} className={`px-6 py-3 whitespace-nowrap ${activeTab === "advanced" ? "border-b-2 border-blue-500 text-blue-500" : "text-gray-400"}`}>
                  ‚öôÔ∏è Advanced
                </button>
                <button onClick={() => setActiveTab("ui")} className={`px-6 py-3 whitespace-nowrap ${activeTab === "ui" ? "border-b-2 border-blue-500 text-blue-500" : "text-gray-400"}`}>
                  üé® UI
                </button>
                <button onClick={() => setActiveTab("cache")} className={`px-6 py-3 whitespace-nowrap ${activeTab === "cache" ? "border-b-2 border-blue-500 text-blue-500" : "text-gray-400"}`}>
                  üóÑÔ∏è Cache
                </button>
              </div>

              {/* Content */}
              <div className="h-[650px] overflow-y-auto p-6 space-y-6">
                {activeTab === "ffmpeg" && (
                  <>
                    {/* ===== PRESET MANAGEMENT ===== */}
                    <div className="bg-gray-800 border border-gray-600 rounded-lg p-4">
                      <h3 className="text-md font-semibold text-white mb-3">üì¶ Gestion des Pr√©sets FFmpeg</h3>
                      <div className="flex gap-3">
                        <button onClick={saveFFmpegPresetToServer} className="btn-success flex-1" title="Sauvegarder les param√®tres FFmpeg actuels sur le serveur">
                          üì§ Sauvegarder sur serveur
                        </button>
                        <button onClick={loadFFmpegPresetFromServer} className="btn-secondary flex-1" title="Charger les param√®tres FFmpeg depuis le serveur">
                          üì• Charger depuis serveur
                        </button>
                      </div>
                      <p className="text-xs text-gray-400 mt-2">
                        Les pr√©sets sont sauvegard√©s dans <code>ffmpeg_preset.json</code> √† la racine du serveur WebDAV/SFTP
                      </p>
                    </div>

                    {/* ===== CODEC SELECTION ===== */}
                    <CodecSelector config={config} updateConfigNested={updateConfigNested} />

                    {/* ===== GPU SETTINGS ===== */}
                    <div className="space-y-4 bg-gray-800 bg-opacity-30 p-5 rounded-lg border border-gray-700">
                      <h3 className="text-lg font-semibold text-white">üéÆ GPU Settings (NVENC)</h3>
                      <p className="text-sm text-gray-400">Param√®tres pour l'encodage GPU avec NVIDIA NVENC (hevc_nvenc ou vp9_nvenc)</p>

                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm text-gray-300 mb-2">
                            GPU Encode Preset
                            <span className="ml-2 text-xs text-blue-400">(p1-p7)</span>
                          </label>
                          <select
                            value={config.ffmpeg?.encode_preset || "p7"}
                            onChange={(e) => updateConfigNested("ffmpeg", "encode_preset", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          >
                            <option value="p1">P1 - Fastest (‚ö° Tr√®s rapide)</option>
                            <option value="p2">P2 - Faster</option>
                            <option value="p3">P3 - Fast</option>
                            <option value="p4">P4 - Medium</option>
                            <option value="p5">P5 - Slow</option>
                            <option value="p6">P6 - Slower</option>
                            <option value="p7">P7 - Slowest (Meilleure qualit√©)</option>
                          </select>
                          <p className="text-xs text-gray-400 mt-1">
                            <strong>Min:</strong> p1 (rapide, qualit√© moyenne) | <strong>Max:</strong> p7 (lent, meilleure qualit√©)
                            <br />
                            <strong>Recommand√©:</strong> p7 pour qualit√© optimale, p4-p5 pour rapidit√©
                            <br />
                            <em>Contr√¥le la vitesse d'encodage vs qualit√© - plus lent = meilleure compression</em>
                          </p>
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">
                            CQ - Constant Quality
                            <span className="ml-2 text-xs text-blue-400">(0-51)</span>
                          </label>
                          <input
                            type="number"
                            min="0"
                            max="51"
                            value={config.ffmpeg?.cq || 18}
                            onChange={(e) => updateConfigNested("ffmpeg", "cq", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                          <p className="text-xs text-gray-400 mt-1">
                            <strong>Min:</strong> 0 (lossless, √©norme) | <strong>Max:</strong> 51 (qualit√© minimale)
                            <br />
                            <strong>Recommand√©:</strong> 18-20 (haute qualit√©), 22-24 (√©quilibr√©), 26-28 (√©conomie)
                            <br />
                            <em>Facteur de qualit√© constant - plus bas = meilleure qualit√© mais fichiers plus gros</em>
                          </p>
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">
                            Mode de Contr√¥le RC (Rate Control)
                            <span className="ml-2 text-xs text-blue-400">(CQP/VBR/CBR)</span>
                          </label>
                          <select
                            value={config.ffmpeg?.rc_mode || "vbr_hq"}
                            onChange={(e) => updateConfigNested("ffmpeg", "rc_mode", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          >
                            <option value="constqp">CQP - Constant QP (qualit√© fixe)</option>
                            <option value="vbr">VBR - Variable Bitrate</option>
                            <option value="vbr_hq">VBR HQ - Variable Bitrate High Quality (Recommand√©)</option>
                            <option value="cbr">CBR - Constant Bitrate (streaming)</option>
                          </select>
                          <p className="text-xs text-gray-400 mt-1">
                            <strong>Recommand√©:</strong> vbr_hq (meilleur compromis qualit√©/taille)
                            <br />
                            CQP = qualit√© constante, VBR = bitrate variable, CBR = streaming
                            <br />
                            <em>M√©thode de contr√¥le du d√©bit - VBR HQ adapte le bitrate selon la complexit√©</em>
                          </p>
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">
                            Bitrate Moyen
                            <span className="ml-2 text-xs text-blue-400">(ex: 3M, 5M, 10M)</span>
                          </label>
                          <input
                            type="text"
                            value={config.ffmpeg?.bitrate || "5M"}
                            onChange={(e) => updateConfigNested("ffmpeg", "bitrate", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            placeholder="5M"
                          />
                          <p className="text-xs text-gray-400 mt-1">
                            <strong>720p:</strong> 2-3M | <strong>1080p:</strong> 4-6M | <strong>4K:</strong> 15-25M
                            <br />
                            <strong>Recommand√© 1080p:</strong> 5M (√©quilibre qualit√©/taille)
                            <br />
                            <em>D√©bit binaire cible en M√©gabits par seconde (M = millions de bits/s)</em>
                          </p>
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">
                            Maxrate - D√©bit Maximum
                            <span className="ml-2 text-xs text-blue-400">(pics autoris√©s)</span>
                          </label>
                          <input
                            type="text"
                            value={config.ffmpeg?.maxrate || "5M"}
                            onChange={(e) => updateConfigNested("ffmpeg", "maxrate", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            placeholder="10M"
                          />
                          <p className="text-xs text-gray-400 mt-1">
                            <strong>Recommand√©:</strong> 1.5-2x le bitrate moyen
                            <br />
                            √âvite les pics de bitrate trop √©lev√©s (sc√®nes complexes)
                            <br />
                            <em>Limite le d√©bit maximum autoris√© pour √©viter les sautes de qualit√©</em>
                          </p>
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">
                            Lookahead Frames
                            <span className="ml-2 text-xs text-blue-400">(0-32)</span>
                          </label>
                          <input
                            type="number"
                            min="0"
                            max="32"
                            value={config.ffmpeg?.lookahead || 32}
                            onChange={(e) => updateConfigNested("ffmpeg", "lookahead", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                          <p className="text-xs text-gray-400 mt-1">
                            <em>Nombre de frames analys√©es √† l'avance pour optimiser l'allocation du bitrate</em>
                            <br />
                            <strong>Min:</strong> 0 (d√©sactiv√©) | <strong>Max:</strong> 32 frames
                            <br />
                            <strong>Recommand√©:</strong> 32 (meilleure allocation du bitrate)
                          </p>
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">
                            B-Frames (Bidirectional)
                            <span className="ml-2 text-xs text-blue-400">(0-4)</span>
                          </label>
                          <input
                            type="number"
                            min="0"
                            max="4"
                            value={config.ffmpeg?.bframes || 3}
                            onChange={(e) => updateConfigNested("ffmpeg", "bframes", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                          <p className="text-xs text-gray-400 mt-1">
                            <em>Frames bidirectionnelles pour meilleure compression (r√©f√©rencent pass√© et futur)</em>
                            <br />
                            <strong>Min:</strong> 0 (aucune) | <strong>Max:</strong> 4 (NVENC limit√©)
                            <br />
                            <strong>Recommand√©:</strong> 3 (bon compromis compression/compatibilit√©)
                          </p>
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">
                            B-Frame Reference Mode
                            <span className="ml-2 text-xs text-blue-400">(disabled/each/middle)</span>
                          </label>
                          <select
                            value={config.ffmpeg?.b_ref_mode || "middle"}
                            onChange={(e) => updateConfigNested("ffmpeg", "b_ref_mode", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          >
                            <option value="disabled">Disabled (aucune r√©f√©rence)</option>
                            <option value="each">Each (r√©f√©rence chaque B-frame)</option>
                            <option value="middle">Middle (r√©f√©rence frame centrale - Recommand√©)</option>
                          </select>
                          <p className="text-xs text-gray-400 mt-1">
                            <em>D√©finit comment les B-frames se r√©f√©rencent entre elles pour la compression</em>
                            <br />
                            <strong>Recommand√©:</strong> middle (meilleur compromis qualit√©/performance)
                          </p>
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">
                            AQ Strength - Force Quantification Adaptive
                            <span className="ml-2 text-xs text-blue-400">(1-15)</span>
                          </label>
                          <input
                            type="number"
                            min="1"
                            max="15"
                            value={config.ffmpeg?.aq_strength || 8}
                            onChange={(e) => updateConfigNested("ffmpeg", "aq_strength", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                          <p className="text-xs text-gray-400 mt-1">
                            <em>Intensit√© de la quantification adaptative pour pr√©server les d√©tails</em>
                            <br />
                            <strong>Min:</strong> 1 (faible) | <strong>Max:</strong> 15 (tr√®s fort)
                            <br />
                            <strong>Recommand√©:</strong> 8 (√©quilibre d√©tails/uniformit√©)
                          </p>
                        </div>
                        <div>
                          <label className="block text-sm text-gray-300 mb-2">
                            Multipass Mode
                            <span className="ml-2 text-xs text-blue-400">(disabled/qres/fullres)</span>
                          </label>
                          <select
                            value={config.ffmpeg?.multipass || "fullres"}
                            onChange={(e) => updateConfigNested("ffmpeg", "multipass", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          >
                            <option value="disabled">Disabled (d√©sactiv√©)</option>
                            <option value="qres">Quarter Res (1/4 r√©solution, plus rapide)</option>
                            <option value="fullres">Full Res (pleine r√©solution - Recommand√©)</option>
                          </select>
                          <p className="text-xs text-gray-400 mt-1">
                            <em>Analyse en multi-passes pour optimiser l'allocation du bitrate</em>
                            <br />
                            <strong>Recommand√©:</strong> fullres (meilleure qualit√©, l√©g√®rement plus lent)
                          </p>
                        </div>
                        <div>
                          <label className="flex items-center space-x-2 cursor-pointer">
                            <input
                              type="checkbox"
                              checked={config.ffmpeg?.temporal_aq !== false}
                              onChange={(e) => updateConfigNested("ffmpeg", "temporal_aq", e.target.checked)}
                              className="form-checkbox h-5 w-5 text-blue-600"
                            />
                            <span className="text-sm text-gray-300">
                              Temporal AQ (Quantification Temporelle)
                              <span className="ml-2 text-xs text-blue-400">(true/false)</span>
                            </span>
                          </label>
                          <p className="text-xs text-gray-400 mt-1">
                            <em>Adapte le bitrate selon la complexit√© temporelle (mouvement entre frames)</em>
                            <br />
                            <strong>Recommand√©:</strong> Activ√© (am√©liore les sc√®nes avec mouvement)
                          </p>
                        </div>

                        <div>
                          <label className="flex items-center space-x-2 cursor-pointer">
                            <input
                              type="checkbox"
                              checked={config.ffmpeg?.spatial_aq !== false}
                              onChange={(e) => updateConfigNested("ffmpeg", "spatial_aq", e.target.checked)}
                              className="form-checkbox h-5 w-5 text-blue-600"
                            />
                            <span className="text-sm text-gray-300">
                              Spatial AQ (Quantification Spatiale)
                              <span className="ml-2 text-xs text-blue-400">(true/false)</span>
                            </span>
                          </label>
                          <p className="text-xs text-gray-400 mt-1">
                            <em>Adapte le bitrate selon la complexit√© spatiale (d√©tails dans l'image)</em>
                            <br />
                            <strong>Recommand√©:</strong> Activ√© (am√©liore les zones d√©taill√©es)
                          </p>
                        </div>
                      </div>
                    </div>

                    {/* ===== CPU SETTINGS ===== */}
                    <div className="space-y-4 pt-4 border-t border-gray-700">
                      <h3 className="text-lg font-semibold text-white">‚öôÔ∏è CPU Settings (x265 Fallback)</h3>
                      <p className="text-sm text-gray-400">Utilis√© uniquement si le GPU n'est pas disponible ou force_gpu=false</p>

                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm text-gray-300 mb-2">
                            CPU Preset (libx265)
                            <span className="ml-2 text-xs text-blue-400">(ultrafast-veryslow)</span>
                          </label>
                          <select
                            value={config.ffmpeg?.cpu_preset || "medium"}
                            onChange={(e) => updateConfigNested("ffmpeg", "cpu_preset", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          >
                            <option value="ultrafast">Ultrafast (‚ö° Tr√®s rapide, qualit√© faible)</option>
                            <option value="superfast">Superfast</option>
                            <option value="veryfast">Veryfast</option>
                            <option value="faster">Faster</option>
                            <option value="fast">Fast</option>
                            <option value="medium">Medium (Recommand√© - √âquilibr√©)</option>
                            <option value="slow">Slow (Lent, bonne qualit√©)</option>
                            <option value="slower">Slower (Tr√®s lent)</option>
                            <option value="veryslow">Veryslow (‚è±Ô∏è Extr√™mement lent)</option>
                          </select>
                          <p className="text-xs text-gray-400 mt-1">
                            <em>Contr√¥le le compromis vitesse vs qualit√© pour l'encodage CPU (x265)</em>
                            <br />
                            <strong>Recommand√©:</strong> medium (√©quilibre vitesse/qualit√©)
                            <br />
                            <strong>Rapide:</strong> fast/faster | <strong>Qualit√© max:</strong> slow/slower
                          </p>
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">
                            CPU CRF - Constant Rate Factor
                            <span className="ml-2 text-xs text-blue-400">(0-51)</span>
                          </label>
                          <input
                            type="number"
                            min="0"
                            max="51"
                            value={config.ffmpeg?.crf || 23}
                            onChange={(e) => updateConfigNested("ffmpeg", "crf", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                          <p className="text-xs text-gray-400 mt-1">
                            <em>Facteur de qualit√© constant pour x265 - plus bas = meilleure qualit√©</em>
                            <br />
                            <strong>Min:</strong> 0 (lossless, √©norme) | <strong>Max:</strong> 51 (qualit√© minimale)
                            <br />
                            <strong>Recommand√©:</strong> 20-22 (haute qualit√©), 23-25 (√©quilibr√©), 26-28 (√©conomie)
                          </p>
                        </div>

                        <div>
                          <label className="flex items-center cursor-pointer">
                            <input type="checkbox" checked={config.ffmpeg?.two_pass || false} onChange={(e) => updateConfigNested("ffmpeg", "two_pass", e.target.checked)} className="mr-2" />
                            <span className="text-sm text-gray-300">Two-Pass Encoding</span>
                          </label>
                          <p className="text-xs text-gray-400 mt-1">
                            <em>Encodage en deux passes pour meilleure allocation du bitrate (CPU x265 seulement)</em>
                            <br />
                            <strong>Attention:</strong> 2x plus lent, meilleure allocation bitrate
                            <br />
                            Non support√© avec NVENC (utilise multipass √† la place)
                          </p>
                        </div>
                      </div>
                    </div>

                    {/* ===== COMMON SETTINGS ===== */}
                    <div className="space-y-4 pt-4 border-t border-gray-700">
                      <h3 className="text-lg font-semibold text-white">üîß Param√®tres Communs (GPU & CPU)</h3>
                      <p className="text-sm text-gray-400">Param√®tres applicables aux deux modes d'encodage</p>

                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm text-gray-300 mb-2">
                            HEVC Profile
                            <span className="ml-2 text-xs text-blue-400">(main/main10)</span>
                          </label>
                          <select
                            value={config.ffmpeg?.profile || "main10"}
                            onChange={(e) => updateConfigNested("ffmpeg", "profile", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          >
                            <option value="main">Main (8-bit, compatible)</option>
                            <option value="main10">Main10 (10-bit, meilleure qualit√© - Recommand√©)</option>
                          </select>
                          <p className="text-xs text-gray-400 mt-1">
                            <em>Profil HEVC/H.265 - Main10 offre de meilleures gradations de couleurs</em>
                            <br />
                            <strong>Recommand√©:</strong> main10 (10-bit, meilleure gradation couleurs)
                            <br />
                            <strong>Compatibilit√©:</strong> main (8-bit, plus compatible appareils anciens)
                          </p>
                        </div>

                        <div>
                          <label className="flex items-center cursor-pointer">
                            <input type="checkbox" checked={config.ffmpeg?.force_gpu !== false} onChange={(e) => updateConfigNested("ffmpeg", "force_gpu", e.target.checked)} className="mr-2" />
                            <span className="text-sm text-gray-300">
                              Force GPU Encoding
                              <span className="ml-2 text-xs text-blue-400">(skip GPU test)</span>
                            </span>
                          </label>
                          <p className="text-xs text-gray-400 mt-1">
                            <em>Force l'utilisation du GPU sans test pr√©alable de disponibilit√©</em>
                            <br />
                            <strong>Recommand√©:</strong> D√©sactiv√© (laisse la d√©tection automatique)
                            <br />
                            Activer uniquement si GPU d√©tect√© mais test √©choue
                          </p>
                        </div>
                      </div>
                    </div>

                    {/* ===== AUDIO SETTINGS ===== */}
                    <div className="space-y-4 pt-4 border-t border-gray-700">
                      <h3 className="text-lg font-semibold text-white">üîä Audio Settings</h3>

                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm text-gray-300 mb-2">
                            Audio Codec
                            <span className="ml-2 text-xs text-blue-400">(copy/aac/ac3/opus)</span>
                          </label>
                          <select
                            value={config.ffmpeg?.audio_codec || "copy"}
                            onChange={(e) => updateConfigNested("ffmpeg", "audio_codec", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          >
                            <option value="copy">Copy (Pas de r√©-encodage - Recommand√©)</option>
                            <option value="aac">AAC (Compatibilit√© maximale)</option>
                            <option value="ac3">AC3 (Dolby Digital)</option>
                            <option value="opus">Opus (Meilleure qualit√©/taille)</option>
                          </select>
                          <p className="text-xs text-gray-400 mt-1">
                            <em>Codec audio √† utiliser - copy pr√©serve la piste originale sans perte</em>
                            <br />
                            <strong>Recommand√©:</strong> copy (pr√©serve qualit√© audio originale)
                            <br />
                            Re-encoder uniquement si n√©cessaire (compatibilit√©)
                          </p>
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">
                            Audio Bitrate (si r√©-encodage)
                            <span className="ml-2 text-xs text-blue-400">(64-320 kbps)</span>
                          </label>
                          <input
                            type="number"
                            min="64"
                            max="320"
                            step="32"
                            value={config.ffmpeg?.audio_bitrate || 192}
                            onChange={(e) => updateConfigNested("ffmpeg", "audio_bitrate", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            disabled={config.ffmpeg?.audio_codec === "copy"}
                          />
                          <p className="text-xs text-gray-400 mt-1">
                            <em>D√©bit binaire audio en kilobits par seconde (uniquement si r√©-encodage)</em>
                            <br />
                            <strong>Min:</strong> 64 kbps (mono/voix) | <strong>Max:</strong> 320 kbps (musique)
                            <br />
                            <strong>Recommand√©:</strong> 128-192 kbps (st√©r√©o), 256 kbps (5.1)
                          </p>
                        </div>
                      </div>
                    </div>

                    {/* Command Preview */}
                    <div className="mt-4 p-3 bg-gray-800 rounded border border-gray-600">
                      <div className="text-xs text-gray-400 mb-1">Commande FFmpeg (aper√ßu):</div>
                      <div className="text-xs text-green-400 font-mono break-all">
                        ffmpeg -i input.mkv -c:v hevc_nvenc -preset {config.ffmpeg?.encode_preset || "p7"} -rc {config.ffmpeg?.rc_mode || "vbr_hq"} -cq {config.ffmpeg?.cq || 24} -b:v{" "}
                        {config.ffmpeg?.bitrate || "3M"} -maxrate {config.ffmpeg?.maxrate || "6M"} -profile:v main10 -pix_fmt p010le -spatial-aq {config.ffmpeg?.spatial_aq !== false ? "1" : "0"}{" "}
                        -temporal-aq {config.ffmpeg?.temporal_aq !== false ? "1" : "0"} -aq-strength {config.ffmpeg?.aq_strength || 8} -bf {config.ffmpeg?.bframes || 3} -b_ref_mode{" "}
                        {config.ffmpeg?.b_ref_mode || "middle"} -rc-lookahead {config.ffmpeg?.lookahead || 32} -multipass {config.ffmpeg?.multipass || "fullres"} -c:a copy output.mkv
                      </div>
                    </div>
                  </>
                )}

                {activeTab === "remote" && (
                  <>
                    <div className="space-y-4">
                      <h3 className="text-lg font-semibold text-white">Remote Server Configuration</h3>

                      {/* Transfer Mode at Top */}
                      <div>
                        <label className="block text-sm text-gray-300 mb-2">Transfer Mode</label>
                        <select
                          value={config.remote?.transfer_method || "auto"}
                          onChange={(e) => updateConfig("remote.transfer_method", e.target.value)}
                          className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                        >
                          <option value="prefer_webdav">Prefer WebDAV with SFTP fallback</option>
                          <option value="auto">Mixed (WebDAV download, SFTP upload)</option>
                          <option value="webdav">WebDAV only</option>
                          <option value="sftp">SFTP only</option>
                        </select>
                        <p className="text-xs text-gray-400 mt-1">
                          <span className="font-semibold">Prefer WebDAV with SFTP fallback (recommended):</span> Uses WebDAV for fast downloads and SFTP for backup protection
                        </p>
                      </div>

                      {/* WebDAV Configuration */}
                      <div className="pt-4 border-t border-gray-700">
                        <h4 className="text-md font-semibold text-white mb-3">WebDAV Settings</h4>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">WebDAV URL</label>
                          <input
                            type="text"
                            value={config.remote?.webdav?.url || ""}
                            onChange={(e) => updateConfig("remote.webdav.url", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            placeholder="http://your-server.com:port"
                          />
                          <p className="text-xs text-gray-400 mt-1">Full URL including protocol and port (e.g., http://192.168.1.100:8080)</p>
                        </div>

                        <div className="grid grid-cols-2 gap-4 mt-4">
                          <div>
                            <label className="block text-sm text-gray-300 mb-2">Username</label>
                            <input
                              type="text"
                              value={config.remote?.webdav?.username || ""}
                              onChange={(e) => updateConfig("remote.webdav.username", e.target.value)}
                              className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            />
                          </div>

                          <div>
                            <label className="block text-sm text-gray-300 mb-2">Password</label>
                            <input
                              type="password"
                              value={config.remote?.webdav?.password || ""}
                              onChange={(e) => updateConfig("remote.webdav.password", e.target.value)}
                              className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            />
                          </div>
                        </div>

                        <div className="mt-4">
                          <label className="block text-sm text-gray-300 mb-2">WebDAV Base Path</label>
                          <input
                            type="text"
                            value={config.remote?.webdav?.path || "/"}
                            onChange={(e) => updateConfig("remote.webdav.path", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            placeholder="/"
                          />
                          <p className="text-xs text-gray-400 mt-1">Base path on WebDAV server (usually "/" for root)</p>
                        </div>

                        {/* Test WebDAV Connection Button */}
                        <div className="pt-4">
                          <button
                            onClick={async () => {
                              setWebdavConnectionStatus({ testing: true, message: "Testing WebDAV connection...", success: null });
                              try {
                                // Save config first
                                await window.electronAPI.configSaveUserConfig(config);

                                // Test WebDAV connection
                                const result = await window.electronAPI.testWebdavConnection();

                                if (result.success) {
                                  setWebdavConnectionStatus({
                                    testing: false,
                                    message: "‚úÖ WebDAV connection successful!",
                                    success: true,
                                  });
                                } else {
                                  setWebdavConnectionStatus({
                                    testing: false,
                                    message: `‚ùå WebDAV connection failed: ${result.error}`,
                                    success: false,
                                  });
                                }
                              } catch (error) {
                                setWebdavConnectionStatus({
                                  testing: false,
                                  message: `‚ùå Error: ${error.message}`,
                                  success: false,
                                });
                              }

                              setTimeout(() => {
                                setWebdavConnectionStatus({ testing: false, message: "", success: null });
                              }, 5000);
                            }}
                            disabled={webdavConnectionStatus.testing}
                            className={`btn-primary w-full ${webdavConnectionStatus.testing ? "opacity-50 cursor-not-allowed" : ""}`}
                          >
                            {webdavConnectionStatus.testing ? "üîÑ Testing..." : "üåê Test WebDAV Connection"}
                          </button>
                          {webdavConnectionStatus.message && (
                            <p className={`mt-2 text-sm ${webdavConnectionStatus.success ? "text-green-400" : webdavConnectionStatus.success === false ? "text-red-400" : "text-gray-400"}`}>
                              {webdavConnectionStatus.message}
                            </p>
                          )}
                        </div>
                      </div>

                      {/* SFTP Configuration (for upload in auto mode) */}
                      <div className="pt-4 border-t border-gray-700">
                        <h4 className="text-md font-semibold text-white mb-3">SFTP Settings</h4>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">SFTP Host</label>
                          <input
                            type="text"
                            value={config.remote?.sftp?.host || ""}
                            onChange={(e) => updateConfig("remote.sftp.host", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            placeholder="ds10256.seedhost.eu"
                          />
                        </div>

                        <div className="grid grid-cols-2 gap-4 mt-4">
                          <div>
                            <label className="block text-sm text-gray-300 mb-2">Username</label>
                            <input
                              type="text"
                              value={config.remote?.sftp?.user || ""}
                              onChange={(e) => updateConfig("remote.sftp.user", e.target.value)}
                              className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            />
                          </div>

                          <div>
                            <label className="block text-sm text-gray-300 mb-2">Password</label>
                            <input
                              type="password"
                              value={config.remote?.sftp?.password || ""}
                              onChange={(e) => updateConfig("remote.sftp.password", e.target.value)}
                              className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            />
                          </div>
                        </div>

                        <div className="mt-4">
                          <label className="block text-sm text-gray-300 mb-2">Remote Library Path</label>
                          <input
                            type="text"
                            value={config.remote?.sftp?.path || ""}
                            onChange={(e) => updateConfig("remote.sftp.path", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            placeholder="/home/user/library"
                          />
                        </div>

                        {/* Test SFTP Connection Button */}
                        <div className="pt-4">
                          <button onClick={testConnection} disabled={connectionStatus.testing} className={`btn-primary w-full ${connectionStatus.testing ? "opacity-50 cursor-not-allowed" : ""}`}>
                            {connectionStatus.testing ? "üîÑ Testing..." : "üîå Test SFTP Connection"}
                          </button>
                        </div>
                      </div>
                    </div>
                  </>
                )}

                {activeTab === "storage" && (
                  <>
                    <div className="space-y-4">
                      <h3 className="text-lg font-semibold text-white">File Retention Options</h3>

                      <div className="space-y-3">
                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={config.advanced?.behavior?.keep_original !== false}
                            onChange={(e) => updateConfig("advanced.behavior.keep_original", e.target.checked)}
                            className="mr-2"
                          />
                          <span className="text-sm text-gray-300">Keep original source files locally</span>
                        </label>
                        <p className="text-xs text-gray-400 ml-6">Original files kept in backup/originals for quality comparison (enabled by default)</p>

                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={config.advanced?.behavior?.keep_encoded !== false}
                            onChange={(e) => updateConfig("advanced.behavior.keep_encoded", e.target.checked)}
                            className="mr-2"
                          />
                          <span className="text-sm text-gray-300">Keep encoded files locally</span>
                        </label>
                        <p className="text-xs text-gray-400 ml-6">Encoded files kept in backup/encoded for quality comparison (enabled by default)</p>

                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={config.advanced?.behavior?.create_backups !== false}
                            onChange={(e) => updateConfig("advanced.behavior.create_backups", e.target.checked)}
                            className="mr-2"
                          />
                          <span className="text-sm text-gray-300">Create backups on server before replacing</span>
                        </label>
                        <p className="text-xs text-gray-400 ml-6">Original file on server will be renamed from .ext to .bak.ext</p>

                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={config.advanced?.behavior?.skip_hevc_reencode || false}
                            onChange={(e) => updateConfig("advanced.behavior.skip_hevc_reencode", e.target.checked)}
                            className="mr-2"
                          />
                          <span className="text-sm text-gray-300">Skip re-encoding HEVC/x265 files</span>
                        </label>
                        <p className="text-xs text-gray-400 ml-6">Files already in HEVC format will be copied without re-encoding (faster but no size reduction)</p>

                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={config.advanced?.behavior?.simulation_mode || false}
                            onChange={(e) => updateConfig("advanced.behavior.simulation_mode", e.target.checked)}
                            className="mr-2"
                          />
                          <span className="text-sm text-gray-300">üß™ Simulation mode (testing only)</span>
                        </label>
                        <p className="text-xs text-gray-400 ml-6">Skip encoding entirely - just copy files to test download/upload pipeline</p>
                      </div>
                    </div>

                    <div className="space-y-4 pt-4 border-t border-gray-700">
                      <h3 className="text-lg font-semibold text-white">Local Paths</h3>

                      <div>
                        <label className="block text-sm text-gray-300 mb-2">Local Temp Directory</label>
                        <div className="flex gap-2">
                          <input
                            type="text"
                            value={config.storage?.local_temp || ""}
                            onChange={(e) => updateConfig("storage.local_temp", e.target.value)}
                            className="flex-1 bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            placeholder="C:/Users/Zed/AppData/Local/Temp/Sharkoder/cache"
                          />
                          <button
                            onClick={async () => {
                              try {
                                const result = await window.electronAPI.selectFolder(config.storage?.local_temp);
                                if (result.success && result.path) {
                                  updateConfig("storage.local_temp", result.path);
                                }
                              } catch (error) {
                                console.error("Select folder error:", error);
                                alert("Error: " + error.message);
                              }
                            }}
                            className="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded whitespace-nowrap"
                            title="Browse and select directory"
                          >
                            üìÇ Browse
                          </button>
                          <button
                            onClick={async () => {
                              if (!config.storage?.local_temp) {
                                alert("‚ö†Ô∏è Please configure the path first");
                                return;
                              }
                              try {
                                const result = await window.electronAPI.openFolder(config.storage.local_temp);
                                if (!result.success) {
                                  alert("Failed to open folder: " + (result.error || "Path may not exist"));
                                }
                              } catch (error) {
                                console.error("Open folder error:", error);
                                alert("Error: " + error.message);
                              }
                            }}
                            className="btn-secondary px-4 py-2 whitespace-nowrap"
                            title="Open folder in File Explorer"
                          >
                            üìÅ Open
                          </button>
                        </div>
                        <p className="text-xs text-gray-400 mt-1">Where files are downloaded for encoding</p>
                      </div>

                      <div>
                        <label className="block text-sm text-gray-300 mb-2">Local Backup Directory</label>
                        <div className="flex gap-2">
                          <input
                            type="text"
                            value={config.storage?.local_backup || ""}
                            onChange={(e) => updateConfig("storage.local_backup", e.target.value)}
                            className="flex-1 bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            placeholder="C:/Users/Zed/AppData/Local/Temp/Sharkoder/backups"
                          />
                          <button
                            onClick={async () => {
                              try {
                                const result = await window.electronAPI.selectFolder(config.storage?.local_backup);
                                if (result.success && result.path) {
                                  updateConfig("storage.local_backup", result.path);
                                }
                              } catch (error) {
                                console.error("Select folder error:", error);
                                alert("Error: " + error.message);
                              }
                            }}
                            className="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded whitespace-nowrap"
                            title="Browse and select directory"
                          >
                            üìÇ Browse
                          </button>
                          <button
                            onClick={async () => {
                              if (!config.storage?.local_backup) {
                                alert("‚ö†Ô∏è Please configure the path first");
                                return;
                              }
                              try {
                                const result = await window.electronAPI.openFolder(config.storage.local_backup);
                                if (!result.success) {
                                  alert("Failed to open folder: " + (result.error || "Path may not exist"));
                                }
                              } catch (error) {
                                console.error("Open folder error:", error);
                                alert("Error: " + error.message);
                              }
                            }}
                            className="btn-secondary px-4 py-2 whitespace-nowrap"
                            title="Open folder in File Explorer"
                          >
                            üìÅ Open
                          </button>
                        </div>
                        <p className="text-xs text-gray-400 mt-1">Where original files are backed up</p>
                      </div>

                      <div>
                        <label className="block text-sm text-gray-300 mb-2">Default Download Directory</label>
                        <div className="flex gap-2">
                          <input
                            type="text"
                            value={config.storage?.download_path || ""}
                            onChange={(e) => updateConfig("storage.download_path", e.target.value)}
                            className="flex-1 bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            placeholder="C:/Users/Zed/Downloads"
                          />
                          <button
                            onClick={async () => {
                              try {
                                const result = await window.electronAPI.selectFolder(config.storage?.download_path);
                                if (result.success && result.path) {
                                  updateConfig("storage.download_path", result.path);
                                }
                              } catch (error) {
                                console.error("Select folder error:", error);
                                alert("Error: " + error.message);
                              }
                            }}
                            className="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded whitespace-nowrap"
                            title="Browse and select directory"
                          >
                            üìÇ Browse
                          </button>
                          <button
                            onClick={async () => {
                              if (!config.storage?.download_path) {
                                alert("‚ö†Ô∏è Please configure the path first");
                                return;
                              }
                              try {
                                const result = await window.electronAPI.openFolder(config.storage.download_path);
                                if (!result.success) {
                                  alert("Failed to open folder: " + (result.error || "Path may not exist"));
                                }
                              } catch (error) {
                                console.error("Open folder error:", error);
                                alert("Error: " + error.message);
                              }
                            }}
                            className="btn-secondary px-4 py-2 whitespace-nowrap"
                            title="Open folder in File Explorer"
                          >
                            üìÅ Open
                          </button>
                        </div>
                        <p className="text-xs text-gray-400 mt-1">Where files are downloaded when using the download button</p>
                      </div>
                    </div>
                  </>
                )}

                {activeTab === "advanced" && (
                  <>
                    <div className="space-y-4">
                      <h3 className="text-lg font-semibold text-white">Connection Settings</h3>

                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm text-gray-300 mb-2">Max Concurrent Downloads</label>
                          <input
                            type="number"
                            min="1"
                            max="5"
                            value={config.advanced?.connection?.max_concurrent_downloads || 2}
                            onChange={(e) => updateConfig("advanced.connection.max_concurrent_downloads", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">Max Prefetch Files</label>
                          <input
                            type="number"
                            min="1"
                            max="10"
                            value={config.advanced?.connection?.max_prefetch_files || 3}
                            onChange={(e) => updateConfig("advanced.connection.max_prefetch_files", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">Retry Attempts</label>
                          <input
                            type="number"
                            min="0"
                            max="5"
                            value={config.advanced?.connection?.retry_attempts || 2}
                            onChange={(e) => updateConfig("advanced.connection.retry_attempts", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">Connection Timeout (ms)</label>
                          <input
                            type="number"
                            min="5000"
                            max="120000"
                            step="1000"
                            value={config.advanced?.connection?.connection_timeout || 30000}
                            onChange={(e) => updateConfig("advanced.connection.connection_timeout", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                        </div>
                      </div>
                    </div>

                    <div className="space-y-4 pt-4 border-t border-gray-700">
                      <h3 className="text-lg font-semibold text-white">Behavior</h3>

                      <div className="space-y-3">
                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={config.notification_settings?.show_completion_notifications !== false}
                            onChange={(e) => updateConfig("notification_settings.show_completion_notifications", e.target.checked)}
                            className="mr-2"
                          />
                          <span className="text-sm text-gray-300">Show completion notifications</span>
                        </label>

                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={config.notification_settings?.show_error_notifications !== false}
                            onChange={(e) => updateConfig("notification_settings.show_error_notifications", e.target.checked)}
                            className="mr-2"
                          />
                          <span className="text-sm text-gray-300">Show error notifications</span>
                        </label>

                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={config.notification_settings?.minimize_to_tray !== false}
                            onChange={(e) => updateConfig("notification_settings.minimize_to_tray", e.target.checked)}
                            className="mr-2"
                          />
                          <span className="text-sm text-gray-300">Minimize to system tray</span>
                        </label>
                      </div>
                    </div>

                    <div className="space-y-4 pt-4 border-t border-gray-700">
                      <h3 className="text-lg font-semibold text-white">Advanced Options</h3>

                      <div className="space-y-3">
                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={config.advanced?.behavior?.auto_start_queue !== false}
                            onChange={(e) => updateConfig("advanced.behavior.auto_start_queue", e.target.checked)}
                            className="mr-2"
                          />
                          <span className="text-sm text-gray-300">Auto-start queue on launch</span>
                        </label>

                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={config.advanced?.behavior?.verify_checksums !== false}
                            onChange={(e) => updateConfig("advanced.behavior.verify_checksums", e.target.checked)}
                            className="mr-2"
                          />
                          <span className="text-sm text-gray-300">Verify file checksums after transfer</span>
                        </label>

                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={config.advanced?.behavior?.create_backups !== false}
                            onChange={(e) => updateConfig("advanced.behavior.create_backups", e.target.checked)}
                            className="mr-2"
                          />
                          <span className="text-sm text-gray-300">Create backups on server before replacing</span>
                        </label>

                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={config.advanced?.behavior?.extract_video_duration || false}
                            onChange={(e) => updateConfig("advanced.behavior.extract_video_duration", e.target.checked)}
                            className="mr-2"
                          />
                          <span className="text-sm text-gray-300">Extract video duration during statistics</span>
                        </label>
                        <p className="text-xs text-gray-400 ml-6">Slower, requires partial downloads but shows total duration in folders</p>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">
                            Release Tag
                            <span className="text-xs text-gray-500 ml-2">(appended to encoded filenames)</span>
                          </label>
                          <input
                            type="text"
                            value={config.advanced?.behavior?.release_tag || ""}
                            onChange={(e) => updateConfig("advanced.behavior.release_tag", e.target.value)}
                            placeholder="e.g., Z3D, PROPER, etc."
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                          <p className="text-xs text-gray-500 mt-1">
                            Example: "Movie [x265]-<span className="text-cyan-400">{config.advanced?.behavior?.release_tag || "TAG"}</span>.mkv"
                          </p>
                        </div>
                      </div>
                    </div>

                    <div className="space-y-4 pt-4 border-t border-gray-700">
                      <h3 className="text-lg font-semibold text-white">Logging</h3>

                      <div>
                        <label className="block text-sm text-gray-300 mb-2">Log Level</label>
                        <select
                          value={config.advanced?.behavior?.log_level || "info"}
                          onChange={(e) => updateConfig("advanced.behavior.log_level", e.target.value)}
                          className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                        >
                          <option value="error">Error</option>
                          <option value="warn">Warning</option>
                          <option value="info">Info</option>
                          <option value="debug">Debug</option>
                        </select>
                      </div>
                    </div>
                  </>
                )}

                {activeTab === "ui" && (
                  <>
                    <div className="space-y-4">
                      <h3 className="text-lg font-semibold text-white">UI Preferences</h3>

                      <div className="space-y-3">
                        <label className="flex items-center cursor-pointer">
                          <input type="checkbox" checked={config.ui.show_notifications} onChange={(e) => updateConfig("ui.show_notifications", e.target.checked)} className="mr-2" />
                          <span className="text-sm text-gray-300">Show completion notifications</span>
                        </label>

                        <label className="flex items-center cursor-pointer">
                          <input type="checkbox" checked={config.ui?.hide_empty_folders !== false} onChange={(e) => updateConfig("ui.hide_empty_folders", e.target.checked)} className="mr-2" />
                          <span className="text-sm text-gray-300">Hide empty folders (no video files)</span>
                        </label>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">Auto-refresh interval (ms)</label>
                          <input
                            type="number"
                            min="1000"
                            max="30000"
                            step="1000"
                            value={config.ui.auto_refresh_interval}
                            onChange={(e) => updateConfig("ui.auto_refresh_interval", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                        </div>
                      </div>
                    </div>
                  </>
                )}

                {activeTab === "cache" && (
                  <>
                    <CacheManager onClose={onClose} />
                  </>
                )}
              </div>

              {/* Footer */}
              <div className="px-6 py-4 border-t border-gray-700 flex justify-between items-center">
                <div className="text-xs text-gray-400">Settings saved to server: {config.last_update ? new Date(config.last_update).toLocaleString() : "Never"}</div>
                <div className="flex space-x-3">
                  <button onClick={onClose} className="btn-secondary">
                    Cancel
                  </button>
                  <button onClick={handleSave} className="btn-success">
                    üíæ Save Settings
                  </button>
                </div>
              </div>
            </div>
          </div>
        );
      };

      // Main App Component
      const App = () => {
        const [jobs, setJobs] = useState([]);
        const [stats, setStats] = useState({});
        const [progressData, setProgressData] = useState({});
        const [encodedFiles, setEncodedFiles] = useState([]);
        const [isConnected, setIsConnected] = useState(false);
        const [queueStatus, setQueueStatus] = useState({ isRunning: false, isPaused: false, loading: false });
        const [showSettings, setShowSettings] = useState(false);
        const [userConfig, setUserConfig] = useState(null);
        const [isLoading, setIsLoading] = useState(true);
        const [shutdownWhenFinished, setShutdownWhenFinished] = useState(false);
        const [blockLargerEncoded, setBlockLargerEncoded] = useState(true); // Block upload if encoded is larger than original
        const [pauseBeforeUpload, setPauseBeforeUpload] = useState(false); // Pause before upload for manual approval
        const [activeTab, setActiveTab] = useState("queue"); // 'queue' or 'completed'

        // Use ref to track shutdown state in event handlers
        const shutdownWhenFinishedRef = React.useRef(shutdownWhenFinished);
        React.useEffect(() => {
          shutdownWhenFinishedRef.current = shutdownWhenFinished;
        }, [shutdownWhenFinished]);

        // Load blockLargerEncoded preference from localStorage
        useEffect(() => {
          const saved = localStorage.getItem("blockLargerEncoded");
          if (saved !== null) {
            setBlockLargerEncoded(saved === "true");
          }
        }, []);

        // Save blockLargerEncoded preference to localStorage
        useEffect(() => {
          localStorage.setItem("blockLargerEncoded", blockLargerEncoded.toString());
          // Send to backend
          window.electronAPI.queueUpdateSettings({ blockLargerEncoded });
        }, [blockLargerEncoded]);

        // Load pauseBeforeUpload preference from localStorage
        useEffect(() => {
          const saved = localStorage.getItem("pauseBeforeUpload");
          if (saved !== null) {
            setPauseBeforeUpload(saved === "true");
          }
        }, []);

        // Save pauseBeforeUpload preference to localStorage
        useEffect(() => {
          localStorage.setItem("pauseBeforeUpload", pauseBeforeUpload.toString());
        }, [pauseBeforeUpload]);

        useEffect(() => {
          // Hide the initial HTML loader when React starts
          const initialLoader = document.getElementById("initial-loader");
          if (initialLoader) {
            initialLoader.style.display = "none";
          }

          // Load initial data
          const initializeApp = async () => {
            try {
              await Promise.all([loadJobs(), loadStats(), loadEncodedFiles(), loadQueueStatus(), loadUserConfig()]);

              // Auto-connect to SFTP server on startup
              try {
                const connectResult = await window.electronAPI.sftpConnect();
                if (connectResult.success) {
                  setIsConnected(true);
                  console.log("Connected to SFTP server");
                } else {
                  console.warn(`SFTP connection failed: ${connectResult.error}`);
                }
              } catch (error) {
                console.warn(`SFTP connection error: ${error.message}`);
              }

              // WebDAV connection is handled by FileTree component
              // No need to connect here to avoid duplicate connections

              // Small delay to show the loading animation
              setTimeout(() => setIsLoading(false), 1000);
            } catch (error) {
              console.error("Failed to initialize app:", error);
              setIsLoading(false);
            }
          };

          initializeApp();

          // Setup event listeners
          window.electronAPI.onQueueProgress((data) => {
            console.log("[PROGRESS] Received:", data);
            setProgressData((prev) => ({
              ...prev,
              [data.jobId]: data,
            }));
          });

          window.electronAPI.onQueueStatusChange((data) => {
            console.log("Queue status changed:", data);
            setQueueStatus((prev) => ({
              ...prev,
              isRunning: data.isRunning,
              isPaused: data.isPaused,
            }));
          });

          window.electronAPI.onJobUpdate(async (data) => {
            console.log("Job update received:", data);
            if (data.status === "failed") {
              console.error(`ERROR: Job ${data.id} failed: ${data.error || "Unknown error"}`);
            } else if (data.status === "ready_upload") {
              console.log(`Job ${data.id} ready for upload`);
            }
            // Reload jobs to update UI
            await loadJobs();
          });

          window.electronAPI.onJobComplete(async (data) => {
            console.log(`Job completed: ${data.filepath}`);
            await loadJobs();
            await loadStats();
            await loadEncodedFiles();

            // Invalidate FileTree cache to force reload of directory
            console.log("Dispatching invalidateFileTreeCache event");
            window.dispatchEvent(
              new CustomEvent("invalidateFileTreeCache", {
                detail: { filepath: data.filepath },
              })
            );

            // Sync cache after upload completion
            try {
              console.log("Job completed, syncing cache...");
              // Wait a moment for the file to be fully uploaded
              await new Promise((resolve) => setTimeout(resolve, 1000));
              // Trigger cache sync via main process to ensure it happens in FileTree
              await window.electronAPI.webdavConnect(); // Ensure connected
              if (window.electronAPI.syncCache) {
                await window.electronAPI.syncCache();
              }
            } catch (error) {
              console.error("Error syncing cache after job completion:", error);
            }

            // Check if shutdown is enabled and queue is finished
            if (shutdownWhenFinishedRef.current) {
              const result = await window.electronAPI.queueGetJobs();
              if (result.success) {
                const remainingJobs = result.jobs.filter(
                  (job) =>
                    job.status === "waiting" ||
                    job.status === "downloading" ||
                    job.status === "encoding" ||
                    job.status === "uploading" ||
                    job.status === "ready_encode" ||
                    job.status === "ready_upload"
                );

                if (remainingJobs.length === 0) {
                  console.log("All jobs completed! Shutting down computer in 30 seconds...");
                  setTimeout(async () => {
                    try {
                      await window.electronAPI.systemShutdown();
                    } catch (error) {
                      console.error(`Failed to shutdown: ${error.message}`);
                    }
                  }, 2000); // Wait 2 seconds before initiating shutdown
                }
              }
            }
          });

          window.electronAPI.onQueueError((error) => {
            console.error("Queue error:", error);
            console.error(`ERROR: Queue error: ${error.message || JSON.stringify(error)}`);
          });

          // Poll queue status every 5 seconds
          const statusInterval = setInterval(loadQueueStatus, 5000);

          // Poll job list every 2 seconds to see status updates
          const jobsInterval = setInterval(loadJobs, 2000);

          return () => {
            window.electronAPI.removeAllListeners("queue:progress");
            window.electronAPI.removeAllListeners("queue:statusChange");
            window.electronAPI.removeAllListeners("queue:jobComplete");
            window.electronAPI.removeAllListeners("queue:jobUpdate");
            window.electronAPI.removeAllListeners("queue:error");
            clearInterval(statusInterval);
            clearInterval(jobsInterval);
          };
        }, []);

        const loadJobs = async () => {
          try {
            const result = await window.electronAPI.queueGetJobs();
            if (result.success) {
              setJobs(result.jobs);
            }
          } catch (error) {
            console.error("Failed to load jobs:", error);
          }
        };

        const loadStats = async () => {
          try {
            const result = await window.electronAPI.queueGetStats();
            if (result.success) {
              setStats(result.stats);
            }
          } catch (error) {
            console.error("Failed to load stats:", error);
          }
        };

        const loadEncodedFiles = async () => {
          try {
            const result = await window.electronAPI.progressGetEncodedFiles();
            if (result.success) {
              setEncodedFiles(result.encodedFiles);
            }
          } catch (error) {
            console.error("Failed to load encoded files:", error);
          }
        };

        const loadQueueStatus = async () => {
          try {
            const result = await window.electronAPI.queueGetStatus();
            if (result.success) {
              setQueueStatus((prev) => ({
                ...prev,
                isRunning: result.isRunning,
                isPaused: result.isPaused,
                currentJob: result.currentJob,
              }));
            }
          } catch (error) {
            console.error("Failed to load queue status:", error);
          }
        };

        const toggleQueueProcessing = async () => {
          try {
            console.log("[DEBUG] toggleQueueProcessing called, current state:", queueStatus);
            setQueueStatus((prev) => ({ ...prev, loading: true }));

            if (queueStatus.isRunning) {
              console.log("[DEBUG] Stopping queue...");
              const result = await window.electronAPI.queueStop();
              console.log("[DEBUG] Stop result:", result);
              if (result.success) {
                console.log("Queue processing stopped");
                await loadQueueStatus();
                await loadJobs();
                await loadStats();
              } else {
                console.error(`Failed to stop queue: ${result.error}`);
              }
            } else {
              console.log("[DEBUG] Starting queue...");
              const result = await window.electronAPI.queueStart();
              console.log("[DEBUG] Start result:", result);
              if (result.success) {
                console.log("Queue processing started");
                await loadQueueStatus();
                await loadJobs();
                await loadStats();
              } else {
                console.error(`Failed to start queue: ${result.error}`);
              }
            }
          } catch (error) {
            console.error("[DEBUG] toggleQueueProcessing error:", error);
            console.error(`Error: ${error.message}`);
          } finally {
            setQueueStatus((prev) => ({ ...prev, loading: false }));
          }
        };

        const loadUserConfig = async () => {
          try {
            const result = await window.electronAPI.configLoadUserConfig();
            if (result.success && result.config) {
              // Ensure UI preferences have default values
              const configWithDefaults = {
                ...result.config,
                ui: {
                  show_notifications: true,
                  auto_refresh_interval: 5000,
                  hide_empty_folders: true, // Default to hiding empty folders
                  ...result.config.ui,
                },
              };
              setUserConfig(configWithDefaults);
            } else {
              // Fallback to default config if loading fails
              const localConfig = await window.electronAPI.configGet();
              if (localConfig.success) {
                const configWithDefaults = {
                  ...localConfig.config,
                  ui: {
                    show_notifications: true,
                    auto_refresh_interval: 5000,
                    hide_empty_folders: true,
                    ...localConfig.config.ui,
                  },
                };
                setUserConfig(configWithDefaults);
              }
            }
          } catch (error) {
            console.error("Failed to load user config:", error);
            // Try to load local config as fallback
            try {
              const localConfig = await window.electronAPI.configGet();
              if (localConfig.success) {
                const configWithDefaults = {
                  ...localConfig.config,
                  ui: {
                    show_notifications: true,
                    auto_refresh_interval: 5000,
                    hide_empty_folders: true,
                    ...localConfig.config.ui,
                  },
                };
                setUserConfig(configWithDefaults);
              }
            } catch (e) {
              console.error("Failed to load local config:", e);
            }
          }
        };

        const saveUserConfig = async (newConfig) => {
          try {
            const result = await window.electronAPI.configSaveUserConfig(newConfig);
            if (result.success) {
              setUserConfig(newConfig);
              console.log("Settings saved successfully");
            } else {
              console.error(`Failed to save settings: ${result.error}`);
            }
          } catch (error) {
            console.error(`Error: ${error.message}`);
          }
        };

        const handleAddToQueue = async (filePath, fileInfo) => {
          try {
            const result = await window.electronAPI.queueAddJob(filePath, fileInfo);
            if (result.success) {
              console.log(`Added to queue: ${filePath}`);
              loadJobs();
              loadStats();
            } else {
              console.error(`ERROR: Failed to add to queue: ${result.error}`);
              alert(`Failed to add to queue:\n\n${result.error}`);
            }
          } catch (error) {
            console.error(`ERROR: ${error.message}`);
            alert(`Error: ${error.message}`);
          }
        };

        const handleRemoveJob = async (jobId) => {
          try {
            const result = await window.electronAPI.queueRemoveJob(jobId);
            if (result.success) {
              console.log("Job removed from queue");
              loadJobs();
              loadStats();
            }
          } catch (error) {
            console.error(`Error: ${error.message}`);
          }
        };

        const handlePauseJob = async (jobId) => {
          try {
            const result = await window.electronAPI.queuePauseJob(jobId);
            if (result.success) {
              console.log("Job paused");
              loadJobs();
            }
          } catch (error) {
            console.error(`Error: ${error.message}`);
          }
        };

        const handleResumeJob = async (jobId) => {
          try {
            const result = await window.electronAPI.queueResumeJob(jobId);
            if (result.success) {
              console.log("Job resumed");
              loadJobs();
            }
          } catch (error) {
            console.error(`Error: ${error.message}`);
          }
        };

        const handleRetryJob = async (jobId) => {
          try {
            const result = await window.electronAPI.queueRetryJob(jobId);
            if (result.success) {
              console.log("Job queued for retry");
              loadJobs();
            }
          } catch (error) {
            console.error(`Error: ${error.message}`);
          }
        };

        // Show loading screen while initializing
        if (isLoading) {
          return <LoadingScreen message="Initializing Sharkoder..." />;
        }

        return (
          <div className="h-screen flex flex-col">
            {/* Header */}
            <div className="bg-gray-900 px-6 py-4 border-b border-gray-700 flex items-center justify-between">
              <h1 className="text-2xl font-bold text-white flex items-center">
                <img src="../assets/icon.png" alt="Sharkoder" className="w-8 h-8 mr-2" />
                Sharkoder
                <span className="ml-3 text-sm text-gray-400 font-normal">GPU-Accelerated Video Encoder</span>
              </h1>
              <div className="flex items-center space-x-3">
                <button
                  onClick={() => {
                    // Toggle DevTools
                    if (window.electronAPI && window.electronAPI.toggleDevTools) {
                      window.electronAPI.toggleDevTools();
                    }
                  }}
                  className="btn-secondary flex items-center space-x-2"
                  title="Toggle Developer Tools"
                >
                  <span>üîß</span>
                  <span>DevTools</span>
                </button>
                <button onClick={() => setShowSettings(true)} className="btn-secondary flex items-center space-x-2">
                  <span>‚öôÔ∏è</span>
                  <span>Settings</span>
                </button>
              </div>
            </div>

            {/* Settings Panel - Show with loading if userConfig is not loaded yet */}
            {showSettings &&
              (userConfig ? (
                <SettingsPanel userConfig={userConfig} onSave={saveUserConfig} onClose={() => setShowSettings(false)} />
              ) : (
                <div
                  className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
                  onClick={(e) => {
                    // Close if clicking on backdrop
                    if (e.target === e.currentTarget) {
                      setShowSettings(false);
                    }
                  }}
                >
                  <div className="bg-gray-800 rounded-lg p-12">
                    <LoadingScreen message="Loading settings..." />
                    <button onClick={() => setShowSettings(false)} className="mt-4 btn-secondary w-full">
                      Close
                    </button>
                  </div>
                </div>
              ))}

            {/* Main Content */}
            <div className="flex-1 flex overflow-hidden">
              {/* Left Panel - File Tree */}
              <div className="w-1/2 p-4">
                <FileTree onAddToQueue={handleAddToQueue} encodedFiles={encodedFiles} userConfig={userConfig} pauseBeforeUpload={pauseBeforeUpload} />
              </div>

              {/* Right Panel - Queue/Completed with Tabs */}
              <div className="w-1/2 p-4 flex flex-col">
                {/* Tabs */}
                <div className="flex border-b border-gray-700 mb-4">
                  <button
                    onClick={() => setActiveTab("queue")}
                    className={`px-4 py-2 font-medium transition-colors ${activeTab === "queue" ? "text-blue-400 border-b-2 border-blue-400" : "text-gray-400 hover:text-white"}`}
                  >
                    Queue ({jobs.filter((j) => j.status !== "completed").length})
                  </button>
                  <button
                    onClick={() => setActiveTab("completed")}
                    className={`px-4 py-2 font-medium transition-colors ${activeTab === "completed" ? "text-green-400 border-b-2 border-green-400" : "text-gray-400 hover:text-white"}`}
                  >
                    ‚úÖ Completed ({jobs.filter((j) => j.status === "completed").length})
                  </button>
                </div>

                {/* Tab Content */}
                <div className="flex-1 overflow-hidden">
                  {activeTab === "queue" ? (
                    <QueueTable
                      jobs={jobs}
                      progressData={progressData}
                      onRemoveJob={handleRemoveJob}
                      onRetryJob={handleRetryJob}
                      queueStatus={queueStatus}
                      userConfig={userConfig}
                      setQueueStatus={setQueueStatus}
                      loadJobs={loadJobs}
                      loadQueueStatus={loadQueueStatus}
                      setJobs={setJobs}
                      loadStats={loadStats}
                    />
                  ) : (
                    <CompletedJobs jobs={jobs} loadJobs={loadJobs} userConfig={userConfig} />
                  )}
                </div>
              </div>
            </div>

            {/* Bottom Panel - Shutdown Checkbox & Encoding Settings */}
            <div className="bg-gray-900 border-t border-gray-700">
              <div className="px-4 py-3 flex items-center justify-between">
                <div className="flex items-center gap-6">
                  {/* Shutdown Checkbox */}
                  <label className="flex items-center space-x-2 cursor-pointer group">
                    <input
                      type="checkbox"
                      checked={shutdownWhenFinished}
                      onChange={(e) => setShutdownWhenFinished(e.target.checked)}
                      className="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500 focus:ring-2"
                    />
                    <span className="text-sm text-gray-300 group-hover:text-white transition-colors">üîå Shutdown when finished</span>
                  </label>

                  {/* Block Larger Encoded Checkbox */}
                  <label className="flex items-center space-x-2 cursor-pointer group">
                    <input
                      type="checkbox"
                      checked={blockLargerEncoded}
                      onChange={(e) => setBlockLargerEncoded(e.target.checked)}
                      className="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500 focus:ring-2"
                    />
                    <span className="text-sm text-gray-300 group-hover:text-white transition-colors">üö´ Block upload if encoded {">"} original</span>
                  </label>

                  {/* Pause Before Upload Checkbox */}
                  <label className="flex items-center space-x-2 cursor-pointer group">
                    <input
                      type="checkbox"
                      checked={pauseBeforeUpload}
                      onChange={(e) => setPauseBeforeUpload(e.target.checked)}
                      className="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500 focus:ring-2"
                    />
                    <span className="text-sm text-gray-300 group-hover:text-white transition-colors">‚è∏Ô∏è Pause before upload</span>
                  </label>

                  {/* Divider */}
                  <div className="h-6 w-px bg-gray-700"></div>

                  {/* Encoding Settings */}
                  <EncoderInfoPanel userConfig={userConfig} />
                </div>

                {shutdownWhenFinished && (
                  <span className="text-xs text-yellow-400 flex items-center space-x-1">
                    <span>‚ö†Ô∏è</span>
                    <span>Computer will shutdown after all jobs complete</span>
                  </span>
                )}
              </div>
            </div>

            {/* Status Bar */}
            <StatusBar stats={stats} isConnected={isConnected} />
          </div>
        );
      };

      // Render the app (React 18 API)
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
