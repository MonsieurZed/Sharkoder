<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sharkoder - GPU Video Encoder</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        margin: 0;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 50%, #5b21b6 100%);
        color: #f8fafc;
        overflow: hidden;
      }

      .bg-glass {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .scrollbar-thin {
        scrollbar-width: thin;
        scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
      }

      .scrollbar-thin::-webkit-scrollbar {
        width: 8px;
      }

      .scrollbar-thin::-webkit-scrollbar-track {
        background: transparent;
      }

      .scrollbar-thin::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 4px;
      }

      .scrollbar-thin::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.5);
      }

      .status-waiting {
        background-color: rgb(107 114 128);
      }
      .status-downloading {
        background-color: rgb(59 130 246);
      }
      .status-ready_encode {
        background-color: rgb(96 165 250);
      }
      .status-encoding {
        background-color: rgb(234 179 8);
      }
      .status-ready_upload {
        background-color: rgb(192 132 252);
      }
      .status-uploading {
        background-color: rgb(168 85 247);
      }
      .status-completed {
        background-color: rgb(34 197 94);
      }
      .status-failed {
        background-color: rgb(239 68 68);
      }
      .status-paused {
        background-color: rgb(249 115 22);
      }

      .glow-effect {
        box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
      }

      .btn-primary {
        background-color: rgb(37 99 235);
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        transition: background-color 0.2s;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        border: none;
        cursor: pointer;
      }

      .btn-primary:hover {
        background-color: rgb(29 78 216);
      }

      .btn-secondary {
        background-color: rgb(75 85 99);
        color: white;
        padding: 0.25rem 0.75rem;
        border-radius: 0.25rem;
        transition: background-color 0.2s;
        border: none;
        cursor: pointer;
      }

      .btn-secondary:hover {
        background-color: rgb(55 65 81);
      }

      .btn-danger {
        background-color: rgb(220 38 38);
        color: white;
        padding: 0.25rem 0.75rem;
        border-radius: 0.25rem;
        transition: background-color 0.2s;
        border: none;
        cursor: pointer;
      }

      .btn-danger:hover {
        background-color: rgb(185 28 28);
      }

      .btn-success {
        background-color: rgb(22 163 74);
        color: white;
        padding: 0.25rem 0.75rem;
        border-radius: 0.25rem;
        transition: background-color 0.2s;
        border: none;
        cursor: pointer;
      }

      .btn-success:hover {
        background-color: rgb(21 128 61);
      }

      .btn-warning {
        background-color: rgb(234 179 8);
        color: white;
        padding: 0.25rem 0.75rem;
        border-radius: 0.25rem;
        transition: background-color 0.2s;
        border: none;
        cursor: pointer;
      }

      .btn-warning:hover {
        background-color: rgb(202 138 4);
      }

      .encoder-info-panel {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(139, 92, 246, 0.1));
        border: 1px solid rgba(59, 130, 246, 0.3);
        border-radius: 0.5rem;
        padding: 0.75rem;
        margin-bottom: 1rem;
      }

      .encoder-badge {
        display: inline-flex;
        align-items: center;
        padding: 0.25rem 0.75rem;
        border-radius: 9999px;
        font-size: 0.75rem;
        font-weight: 600;
        margin-right: 0.5rem;
      }

      .encoder-badge-gpu {
        background-color: rgba(34, 197, 94, 0.2);
        color: rgb(134, 239, 172);
        border: 1px solid rgba(34, 197, 94, 0.4);
      }

      .encoder-badge-cpu {
        background-color: rgba(234, 179, 8, 0.2);
        color: rgb(253, 224, 71);
        border: 1px solid rgba(234, 179, 8, 0.4);
      }

      .encoder-param {
        display: inline-flex;
        align-items: center;
        padding: 0.25rem 0.5rem;
        background-color: rgba(75, 85, 99, 0.3);
        border-radius: 0.25rem;
        font-size: 0.75rem;
        margin-right: 0.5rem;
        margin-bottom: 0.25rem;
      }

      .encoder-param-label {
        color: rgb(156, 163, 175);
        margin-right: 0.25rem;
      }

      .encoder-param-value {
        color: rgb(229, 231, 235);
        font-weight: 600;
      }

      /* Loading Animation */
      .loading-screen {
        position: fixed;
        inset: 0;
        background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 50%, #5b21b6 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 9999;
      }

      .shark-icon {
        font-size: 6rem;
        animation: float 3s ease-in-out infinite;
        filter: drop-shadow(0 10px 30px rgba(59, 130, 246, 0.5));
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-20px);
        }
      }

      .loading-dots {
        display: flex;
        gap: 0.5rem;
        margin-top: 2rem;
      }

      .loading-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background-color: #60a5fa;
        animation: bounce 1.4s infinite ease-in-out both;
      }

      .loading-dot:nth-child(1) {
        animation-delay: -0.32s;
      }

      .loading-dot:nth-child(2) {
        animation-delay: -0.16s;
      }

      @keyframes bounce {
        0%,
        80%,
        100% {
          transform: scale(0);
        }
        40% {
          transform: scale(1);
        }
      }

      .pulse-ring {
        position: absolute;
        width: 150px;
        height: 150px;
        border: 4px solid rgba(59, 130, 246, 0.3);
        border-radius: 50%;
        animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
          transform: scale(0.95);
        }
        50% {
          opacity: 0.5;
          transform: scale(1.05);
        }
      }
    </style>
  </head>
  <body>
    <!-- Initial loading screen (shown immediately before React loads) -->
    <div id="initial-loader" class="loading-screen">
      <div class="relative">
        <div class="pulse-ring"></div>
        <div class="shark-icon">ü¶à</div>
      </div>
      <div class="mt-8 text-xl text-white font-semibold">Starting Sharkoder...</div>
      <div class="loading-dots">
        <div class="loading-dot"></div>
        <div class="loading-dot"></div>
        <div class="loading-dot"></div>
      </div>
    </div>

    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useCallback } = React;

      // Loading Screen Component
      const LoadingScreen = ({ message = "Loading Sharkoder..." }) => {
        return (
          <div className="loading-screen">
            <div className="relative">
              <div className="pulse-ring"></div>
              <div className="shark-icon">ü¶à</div>
            </div>
            <div className="mt-8 text-xl text-white font-semibold">{message}</div>
            <div className="loading-dots">
              <div className="loading-dot"></div>
              <div className="loading-dot"></div>
              <div className="loading-dot"></div>
            </div>
          </div>
        );
      };

      // Status Badge Component
      const StatusBadge = ({ status }) => {
        const statusConfig = {
          waiting: { label: "Waiting", className: "status-waiting" },
          downloading: { label: "Downloading", className: "status-downloading" },
          ready_encode: { label: "Ready to Encode", className: "status-ready_encode" },
          encoding: { label: "Encoding", className: "status-encoding" },
          ready_upload: { label: "Ready to Upload", className: "status-ready_upload" },
          uploading: { label: "Uploading", className: "status-uploading" },
          completed: { label: "Completed", className: "status-completed" },
          failed: { label: "Failed", className: "status-failed" },
          paused: { label: "Paused", className: "status-paused" },
        };

        const config = statusConfig[status] || statusConfig.waiting;

        return <span className={`px-2 py-1 rounded-full text-xs font-medium text-white ${config.className}`}>{config.label}</span>;
      };

      // Progress Bar Component
      const ProgressBar = ({ progress, type, eta, fps, speed, elapsedTime, currentTime, totalDuration }) => {
        const getBarColor = () => {
          switch (type) {
            case "download":
              return "bg-blue-500";
            case "encoding":
              return "bg-yellow-500";
            case "upload":
              return "bg-purple-500";
            default:
              return "bg-gray-500";
          }
        };

        const formatETA = (seconds) => {
          if (!seconds || seconds <= 0) return "";

          const hours = Math.floor(seconds / 3600);
          const minutes = Math.floor((seconds % 3600) / 60);
          const secs = Math.floor(seconds % 60);

          if (hours > 0) {
            return `${hours}h ${minutes}m`;
          } else if (minutes > 0) {
            return `${minutes}m ${secs}s`;
          } else {
            return `${secs}s`;
          }
        };

        const formatTime = (seconds) => {
          if (!seconds) return "00:00:00";
          const h = Math.floor(seconds / 3600);
          const m = Math.floor((seconds % 3600) / 60);
          const s = Math.floor(seconds % 60);
          return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
        };

        const formatSpeed = (bytesPerSecond) => {
          if (!bytesPerSecond || bytesPerSecond === 0) return "0 Ko/s";
          const k = 1024;
          if (bytesPerSecond < k) return bytesPerSecond.toFixed(0) + " o/s";
          if (bytesPerSecond < k * k) return (bytesPerSecond / k).toFixed(1) + " Ko/s";
          if (bytesPerSecond < k * k * k) return (bytesPerSecond / (k * k)).toFixed(1) + " Mo/s";
          return (bytesPerSecond / (k * k * k)).toFixed(2) + " Go/s";
        };

        return (
          <div className="w-full">
            <div className="flex justify-between text-xs mb-1">
              <div className="flex items-center space-x-3">
                <span className="font-medium">{Math.round(progress)}%</span>
                {type === "encoding" && currentTime && totalDuration && (
                  <span className="text-gray-400">
                    {formatTime(currentTime)} / {formatTime(totalDuration)}
                  </span>
                )}
                {fps && fps > 0 && <span className="text-blue-400">üé¨ {Math.round(fps)} FPS</span>}
                {speed && speed > 0 && <span className="text-purple-400">‚ö° {formatSpeed(speed)}</span>}
              </div>
              <div className="flex items-center space-x-3">
                {elapsedTime && <span className="text-gray-400">‚è±Ô∏è {formatETA(elapsedTime)}</span>}
                {eta && <span className="text-green-400 font-medium">ETA: {formatETA(eta)}</span>}
              </div>
            </div>
            <div className="w-full bg-gray-700 rounded-full h-2">
              <div className={`${getBarColor()} h-2 rounded-full transition-all duration-300`} style={{ width: `${Math.min(progress, 100)}%` }}></div>
            </div>
          </div>
        );
      };

      // Cache Manager Component
      const CacheManager = ({ onClose }) => {
        const [rebuildingCache, setRebuildingCache] = useState(false);
        const [rebuildProgress, setRebuildProgress] = useState({ current: 0, total: 0, currentFolder: '', eta: 0 });
        const [cacheInfo, setCacheInfo] = useState({ size: 0, entries: 0 });
        const [dirCacheInfo, setDirCacheInfo] = useState({ size: 0, entries: 0 });
        const CACHE_KEY = 'webdav_folder_stats_cache';
        const DIRECTORY_CACHE_KEY = 'webdav_directory_structure_cache';

        // Charger les infos du cache
        React.useEffect(() => {
          updateCacheInfo();
        }, []);

        const updateCacheInfo = () => {
          try {
            // Stats Cache
            const cached = localStorage.getItem(CACHE_KEY);
            if (cached) {
              const cache = JSON.parse(cached);
              const entries = Object.keys(cache).length;
              const size = new Blob([cached]).size;
              setCacheInfo({ size, entries });
            } else {
              setCacheInfo({ size: 0, entries: 0 });
            }

            // Directory Structure Cache
            const dirCached = localStorage.getItem(DIRECTORY_CACHE_KEY);
            if (dirCached) {
              const dirCache = JSON.parse(dirCached);
              const entries = Object.keys(dirCache).length;
              const size = new Blob([dirCached]).size;
              setDirCacheInfo({ size, entries });
            } else {
              setDirCacheInfo({ size: 0, entries: 0 });
            }
          } catch (error) {
            console.error('Error loading cache info:', error);
            setCacheInfo({ size: 0, entries: 0 });
            setDirCacheInfo({ size: 0, entries: 0 });
          }
        };

        const formatBytes = (bytes) => {
          if (bytes === 0) return '0 B';
          const k = 1024;
          const sizes = ['B', 'KB', 'MB', 'GB'];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        };

        const clearCache = () => {
          if (confirm('‚ö†Ô∏è Clear all folder stats cache?\n\nThis will remove all folder statistics from cache.')) {
            try {
              localStorage.removeItem(CACHE_KEY);
              updateCacheInfo();
              alert('‚úÖ Stats cache cleared successfully!');
            } catch (error) {
              alert('‚ùå Error clearing cache: ' + error.message);
            }
          }
        };

        const clearDirectoryCache = () => {
          if (confirm('‚ö†Ô∏è Clear directory structure cache?\n\nThis will remove all cached directory listings. Folders will be reloaded from the server on next visit.')) {
            try {
              localStorage.removeItem(DIRECTORY_CACHE_KEY);
              updateCacheInfo();
              alert('‚úÖ Directory cache cleared successfully!');
            } catch (error) {
              alert('‚ùå Error clearing directory cache: ' + error.message);
            }
          }
        };

        const clearAllCaches = () => {
          if (confirm('‚ö†Ô∏è Clear ALL caches?\n\nThis will remove both folder statistics and directory structure caches.')) {
            try {
              localStorage.removeItem(CACHE_KEY);
              localStorage.removeItem(DIRECTORY_CACHE_KEY);
              updateCacheInfo();
              alert('‚úÖ All caches cleared successfully!');
            } catch (error) {
              alert('‚ùå Error clearing caches: ' + error.message);
            }
          }
        };

        const rebuildCompleteCache = async () => {
          try {
            setRebuildingCache(true);
            setRebuildProgress({ current: 0, total: 0, currentFolder: 'Initializing...', eta: 0 });
            
            const startTime = Date.now();
            
            console.log('üöÄ Starting optimized cache rebuild...');
            
            // Setup progress listener
            const progressListener = (progress) => {
              setRebuildProgress({
                current: progress.current,
                total: progress.total,
                currentFolder: progress.currentFolder,
                eta: progress.eta || 0,
              });
            };
            
            if (window.electronAPI.onCacheProgress) {
              window.electronAPI.onCacheProgress(progressListener);
            }
            
            // Call optimized backend method (single pass through entire tree)
            const result = await window.electronAPI.buildCompleteCache();
            
            if (result.success) {
              // Save the cache
              localStorage.setItem(CACHE_KEY, JSON.stringify(result.cache));
              updateCacheInfo();
              
              const totalTime = result.stats.totalTime;
              const totalFolders = result.stats.totalFolders;
              
              console.log(`‚úÖ Cache rebuilt successfully! ${totalFolders} folders in ${totalTime}s`);
              
              // Synchroniser le cache avec le serveur apr√®s le rebuild
              console.log('üîÑ Syncing cache with server...');
              try {
                if (window.electronAPI.syncCache) {
                  await window.electronAPI.syncCache();
                  console.log('‚úÖ Cache synced with server');
                }
              } catch (syncError) {
                console.error('Error syncing cache:', syncError);
              }
              
              alert(`‚úÖ Cache rebuilt successfully!\n\n${totalFolders} folders scanned in ${totalTime}s\n\nüöÄ Optimized single-pass algorithm used!`);
            } else {
              console.error('Cache rebuild failed:', result.error);
              alert(`‚ùå Cache rebuild failed: ${result.error}`);
            }
            
          } catch (error) {
            console.error('Error rebuilding cache:', error);
            alert('‚ùå Error rebuilding cache: ' + error.message);
          } finally {
            setRebuildingCache(false);
            setRebuildProgress({ current: 0, total: 0, currentFolder: '', eta: 0 });
          }
        };

        const formatETA = (seconds) => {
          const mins = Math.floor(seconds / 60);
          const secs = seconds % 60;
          return mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
        };

        return (
          <div className="space-y-6">
            <h3 className="text-lg font-semibold text-white">Cache Management</h3>
            
            {/* Cache Info */}
            <div className="bg-gray-700 rounded-lg p-6">
              <h4 className="text-md font-semibold mb-4 text-white">üìä Cache Statistics</h4>
              <div className="grid grid-cols-2 gap-4 mb-4">
                <div className="bg-gray-800 rounded p-4 col-span-2 border-l-4 border-blue-500">
                  <div className="text-gray-400 text-sm mb-2">üìÅ Folder Stats Cache</div>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <div className="text-xs text-gray-500">Cached Folders</div>
                      <div className="text-xl font-bold text-white">{cacheInfo.entries.toLocaleString()}</div>
                    </div>
                    <div>
                      <div className="text-xs text-gray-500">Cache Size</div>
                      <div className="text-xl font-bold text-white">{formatBytes(cacheInfo.size)}</div>
                    </div>
                  </div>
                </div>
                
                <div className="bg-gray-800 rounded p-4 col-span-2 border-l-4 border-green-500">
                  <div className="text-gray-400 text-sm mb-2">üóÇÔ∏è Directory Structure Cache</div>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <div className="text-xs text-gray-500">Cached Directories</div>
                      <div className="text-xl font-bold text-white">{dirCacheInfo.entries.toLocaleString()}</div>
                    </div>
                    <div>
                      <div className="text-xs text-gray-500">Cache Size</div>
                      <div className="text-xl font-bold text-white">{formatBytes(dirCacheInfo.size)}</div>
                    </div>
                  </div>
                  <div className="text-xs text-gray-400 mt-2">
                    üí° Speeds up navigation by caching directory listings (max age: 5 min)
                  </div>
                </div>
                
                <div className="bg-gray-800 rounded p-4 col-span-2">
                  <div className="text-gray-400 text-sm mb-1">Total Cache Size</div>
                  <div className="text-2xl font-bold text-white">{formatBytes(cacheInfo.size + dirCacheInfo.size)}</div>
                </div>
              </div>
            </div>

            {/* Actions */}
            <div className="space-y-4">
              <div className="bg-gray-700 rounded-lg p-6">
                <h4 className="text-md font-semibold mb-2 text-white">üîÑ Rebuild Complete Cache</h4>
                <p className="text-gray-300 text-sm mb-4">
                  Scan all folders recursively and rebuild the entire cache. This may take several minutes depending on your library size.
                </p>
                <button 
                  onClick={rebuildCompleteCache} 
                  disabled={rebuildingCache}
                  className="btn-primary w-full disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {rebuildingCache ? '‚è≥ Rebuilding...' : 'üîÑ Rebuild Complete Cache'}
                </button>
              </div>

              <div className="bg-gray-700 rounded-lg p-6">
                <h4 className="text-md font-semibold mb-2 text-white">üóëÔ∏è Clear Cache</h4>
                <p className="text-gray-300 text-sm mb-4">
                  Remove cached data. Choose what to clear based on your needs.
                </p>
                <div className="space-y-2">
                  <button 
                    onClick={clearCache} 
                    disabled={rebuildingCache}
                    className="bg-orange-600 hover:bg-orange-700 text-white py-2 px-4 rounded w-full disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                  >
                    üìä Clear Folder Stats Cache
                  </button>
                  <button 
                    onClick={clearDirectoryCache} 
                    disabled={rebuildingCache}
                    className="bg-orange-600 hover:bg-orange-700 text-white py-2 px-4 rounded w-full disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                  >
                    üóÇÔ∏è Clear Directory Structure Cache
                  </button>
                  <button 
                    onClick={clearAllCaches} 
                    disabled={rebuildingCache}
                    className="bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded w-full disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    üóëÔ∏è Clear ALL Caches
                  </button>
                </div>
              </div>
            </div>

            {/* Progress */}
            {rebuildingCache && (
              <div className="bg-gray-700 rounded-lg p-6">
                <h4 className="text-md font-semibold mb-4 text-white">‚è≥ Rebuild Progress</h4>
                
                <div className="mb-4">
                  <div className="flex justify-between text-sm text-gray-300 mb-2">
                    <span>{rebuildProgress.current} / {rebuildProgress.total} folders</span>
                    <span>{rebuildProgress.total > 0 ? Math.round((rebuildProgress.current / rebuildProgress.total) * 100) : 0}%</span>
                  </div>
                  <div className="w-full bg-gray-600 rounded-full h-4 overflow-hidden">
                    <div 
                      className="bg-blue-500 h-full transition-all duration-300"
                      style={{ width: `${rebuildProgress.total > 0 ? (rebuildProgress.current / rebuildProgress.total) * 100 : 0}%` }}
                    />
                  </div>
                </div>

                {rebuildProgress.eta > 0 && (
                  <div className="text-sm text-gray-300 mb-2">
                    ‚è±Ô∏è Estimated time remaining: {formatETA(rebuildProgress.eta)}
                  </div>
                )}

                <div className="text-sm text-gray-400 truncate">
                  üìÅ Current: {rebuildProgress.currentFolder || 'Initializing...'}
                </div>
              </div>
            )}
          </div>
        );
      };

      // File Tree Component
      const FileTree = ({ onAddToQueue, encodedFiles, userConfig }) => {
        const [currentPath, setCurrentPath] = useState("/");
        const [files, setFiles] = useState([]);
        const [loading, setLoading] = useState(false);
        const [connected, setConnected] = useState(false);
        const [sortBy, setSortBy] = useState("alpha"); // 'alpha' or 'size'
        const [searchTerm, setSearchTerm] = useState("");
        const [calculatingSize, setCalculatingSize] = useState({}); // Track folders being calculated
        const [loadedFromCache, setLoadedFromCache] = useState(false); // Track if directory was loaded from cache
        const [sessionCache, setSessionCache] = useState({}); // In-memory cache for current session (never expires)
        const sessionCacheRef = React.useRef(sessionCache); // Ref pour √©viter la recr√©ation de loadFiles
        const [loadingVideoInfo, setLoadingVideoInfo] = useState({}); // Track files loading video info
        const [calculatingStats, setCalculatingStats] = useState({ isCalculating: false, current: 0, total: 0 }); // Track stats calculation progress

        // Synchroniser la ref avec le state
        React.useEffect(() => {
          sessionCacheRef.current = sessionCache;
          console.log(`üîÑ sessionCache updated, keys:`, Object.keys(sessionCache));
        }, [sessionCache]);

        // Cache persistant pour les stats des dossiers (localStorage)
        const CACHE_KEY = 'webdav_folder_stats_cache';
        const DIRECTORY_CACHE_KEY = 'webdav_directory_structure_cache';
        
        // Charger le cache depuis localStorage
        const loadCache = () => {
          try {
            const cached = localStorage.getItem(CACHE_KEY);
            return cached ? JSON.parse(cached) : {};
          } catch (error) {
            console.error('Error loading cache:', error);
            return {};
          }
        };

        // Sauvegarder le cache dans localStorage
        const saveCache = (cache) => {
          try {
            localStorage.setItem(CACHE_KEY, JSON.stringify(cache));
          } catch (error) {
            console.error('Error saving cache:', error);
          }
        };

        // Charger le cache de l'architecture des r√©pertoires
        const loadDirectoryCache = () => {
          try {
            const cached = localStorage.getItem(DIRECTORY_CACHE_KEY);
            return cached ? JSON.parse(cached) : {};
          } catch (error) {
            console.error('Error loading directory cache:', error);
            return {};
          }
        };

        // Sauvegarder le cache de l'architecture des r√©pertoires
        const saveDirectoryCache = (cache) => {
          try {
            localStorage.setItem(DIRECTORY_CACHE_KEY, JSON.stringify(cache));
            console.log(`üì¶ Directory cache saved (${Object.keys(cache).length} directories)`);
          } catch (error) {
            console.error('Error saving directory cache:', error);
          }
        };

        // Vider le cache de l'architecture
        const clearDirectoryCache = () => {
          try {
            localStorage.removeItem(DIRECTORY_CACHE_KEY);
            console.log('üóëÔ∏è Directory cache cleared');
          } catch (error) {
            console.error('Error clearing directory cache:', error);
          }
        };

        // V√©rifier si le cache est √† jour par rapport au serveur
        const isCacheValid = (cachedItem, serverLastModified) => {
          if (!cachedItem || !cachedItem.lastModified) return false;
          if (!serverLastModified) return true; // Si pas de date serveur, on garde le cache
          
          const cacheDate = new Date(cachedItem.lastModified).getTime();
          const serverDate = new Date(serverLastModified).getTime();
          
          return cacheDate >= serverDate; // Cache valide si plus r√©cent ou √©gal
        };

        // Synchroniser le cache avec le serveur au d√©marrage
        const syncCacheWithServer = async () => {
          try {
            console.log('üîÑ Starting cache synchronization with server...');
            const cache = loadCache();
            const cachedPaths = Object.keys(cache);
            
            if (cachedPaths.length === 0) {
              console.log('üì≠ No cache to sync');
              return;
            }

            console.log(`üì¶ Cache loaded: ${cachedPaths.length} folders cached`);
            console.log('‚úÖ Cache ready to use (no recalculation needed)');
            
            // Option: Download cache from server if it exists
            // This would sync with other devices/sessions
            // TODO: Implement server-side cache file download here if needed
            
            // For now, just use the local cache as-is
            // The cache will be validated on-demand when folders are accessed
            
          } catch (error) {
            console.error('Error during cache sync:', error);
          }
        };

        // Fonction pour calculer les stats d'un dossier
        const calculateFolderSize = async (folderPath, silent = false, forceRefresh = false) => {
          try {
            // Charger le cache
            const cache = loadCache();
            
            // V√©rifier si on a un cache valide (sauf si forceRefresh)
            if (!forceRefresh && cache[folderPath]) {
              const cachedStats = cache[folderPath];
              
              // Appliquer imm√©diatement le cache aux fichiers
              setFiles((prevFiles) =>
                prevFiles.map((file) => {
                  if (file.path === folderPath && file.type === "directory") {
                    return {
                      ...file,
                      size: cachedStats.totalSize,
                      fileCount: cachedStats.fileCount,
                      videoCount: cachedStats.videoCount,
                      avgSize: cachedStats.avgSize,
                      sizeFormatted: cachedStats.totalSizeFormatted,
                      cached: true,
                      lastModified: cachedStats.lastModified,
                      upToDate: cachedStats.upToDate !== false,
                    };
                  }
                  return file;
                })
              );
              
              // Si le cache existe et est marqu√© comme √† jour, ne pas recalculer
              if (cachedStats.upToDate !== false) {
                if (!silent) {
                  console.log(`‚úÖ Using cached stats for ${folderPath}`);
                }
                return;
              }
            }
            
            // Pas de cache OU cache pas √† jour OU forceRefresh : calculer

            // Mark as calculating (sauf en mode silent)
            if (!silent) {
              setCalculatingSize((prev) => ({ ...prev, [folderPath]: true }));
            }

            const result = await window.electronAPI.webdavGetFolderStats(folderPath);

            if (result.success) {
              // Mettre √† jour le cache avec la date actuelle
              const statsWithDate = {
                ...result.stats,
                lastModified: new Date().toISOString(),
                upToDate: true,
              };
              
              // üî• RECHARGER le cache juste avant de sauvegarder pour √©viter les race conditions
              const latestCache = loadCache();
              latestCache[folderPath] = statsWithDate;
              saveCache(latestCache);

              // Synchroniser avec le serveur si c'est un refresh forc√©
              if (forceRefresh) {
                console.log('üîÑ Forced refresh, syncing cache with server...');
                try {
                  if (window.electronAPI.syncCache) {
                    await window.electronAPI.syncCache();
                    console.log('‚úÖ Cache synced with server after refresh');
                  }
                } catch (syncError) {
                  console.error('Error syncing cache after refresh:', syncError);
                }
              }

              // Update the file in the list with the new size, fileCount and avgSize
              setFiles((prevFiles) =>
                prevFiles.map((file) => {
                  if (file.path === folderPath && file.type === "directory") {
                    return {
                      ...file,
                      size: result.stats.totalSize,
                      fileCount: result.stats.fileCount,
                      videoCount: result.stats.videoCount,
                      avgSize: result.stats.avgSize,
                      sizeFormatted: result.stats.totalSizeFormatted,
                      cached: true,
                      lastModified: statsWithDate.lastModified,
                      upToDate: true,
                    };
                  }
                  return file;
                })
              );

              // üî• UPDATE SESSION CACHE: Mettre √† jour les items en cache avec les nouvelles stats
              const folderDir = folderPath.substring(0, folderPath.lastIndexOf('/')) || '/';
              console.log(`üíæ Updating session cache for folder "${folderPath}" in path "${folderDir}"`);
              
              if (sessionCacheRef.current[folderDir]) {
                const updatedCache = sessionCacheRef.current[folderDir].map((file) => {
                  if (file.path === folderPath && file.type === "directory") {
                    return {
                      ...file,
                      size: result.stats.totalSize,
                      fileCount: result.stats.fileCount,
                      videoCount: result.stats.videoCount,
                      avgSize: result.stats.avgSize,
                      sizeFormatted: result.stats.totalSizeFormatted,
                      cached: true,
                      lastModified: statsWithDate.lastModified,
                      upToDate: true,
                    };
                  }
                  return file;
                });
                
                // Utiliser la forme fonctionnelle pour mettre √† jour UNE CL√â sp√©cifique
                setSessionCache((prevCache) => ({
                  ...prevCache,
                  [folderDir]: updatedCache
                }));
                console.log(`‚úÖ Session cache updated for "${folderDir}" with stats for "${folderPath}"`);
              }
            } else {
              console.error("Failed to calculate folder size:", result.error);
            }
          } catch (error) {
            console.error("Error calculating folder size:", error);
          } finally {
            // Remove from calculating state
            if (!silent) {
              setCalculatingSize((prev) => {
                const newState = { ...prev };
                delete newState[folderPath];
                return newState;
              });
            }
          }
        };

        const loadFiles = useCallback(
          async (path = "/", forceRefresh = false) => {
            setLoading(true);
            try {
              // Normaliser le chemin
              const normalizedPath = path === "/" ? "/" : (path.startsWith('/') ? path : '/' + path);
              console.log(`üîç loadFiles: "${normalizedPath}" (original: "${path}", forceRefresh=${forceRefresh})`);
              console.log(`üìã Current session cache keys:`, Object.keys(sessionCacheRef.current));
              console.log(`üéØ Cache exists for "${normalizedPath}"?`, !!sessionCacheRef.current[normalizedPath]);
              
              // 1. CACHE SESSION - Si on l'a d√©j√†, on l'affiche imm√©diatement
              if (!forceRefresh && sessionCacheRef.current[normalizedPath]) {
                console.log(`‚ö° CACHE HIT: ${normalizedPath}`);
                const cachedItems = sessionCacheRef.current[normalizedPath];
                console.log(`üì¶ Cache contains ${cachedItems.length} items`);
                
                // Log quelques exemples pour voir les m√©tadonn√©es
                const sampleFolder = cachedItems.find(i => i.type === 'directory');
                if (sampleFolder) {
                  console.log(`üìÅ Sample folder:`, { 
                    name: sampleFolder.name, 
                    size: sampleFolder.size,
                    fileCount: sampleFolder.fileCount,
                    sizeFormatted: sampleFolder.sizeFormatted,
                    cached: sampleFolder.cached,
                    upToDate: sampleFolder.upToDate
                  });
                }
                const sampleVideo = cachedItems.find(i => i.isVideo);
                if (sampleVideo) {
                  console.log(`üé¨ Sample video:`, { 
                    name: sampleVideo.name, 
                    codec: sampleVideo.codec, 
                    resolution: sampleVideo.resolution,
                    container: sampleVideo.container 
                  });
                }
                
                // Compter combien de dossiers ont des stats
                const foldersWithStats = cachedItems.filter(i => i.type === 'directory' && i.cached).length;
                const totalFolders = cachedItems.filter(i => i.type === 'directory').length;
                console.log(`üìä Folders with cached stats: ${foldersWithStats}/${totalFolders}`);
                
                setFiles(cachedItems);
                setLoadedFromCache(true);
                setLoading(false);
                if (!connected) setConnected(true);
                return;
              }
              
              // 2. PAS DE CACHE - Charger depuis le serveur
              console.log(`üåê LOADING from server: ${normalizedPath}`);
              setLoadedFromCache(false);
              
              const result = await window.electronAPI.webdavListDirectory(normalizedPath, true);
              
              if (!result.success) {
                console.error("‚ùå Failed:", result.error);
                setLoading(false);
                return;
              }
              
              // R√©cup√©rer le cache des stats
              const statsCache = loadCache();
              console.log(`üìÇ statsCache has ${Object.keys(statsCache).length} entries`);
              
              // Log quelques exemples de cl√©s du cache pour debug
              const sampleKeys = Object.keys(statsCache).slice(0, 5);
              console.log(`üîë Sample statsCache keys:`, sampleKeys);
              
              // Appliquer les stats si disponibles
              const items = (result.items || []).map(item => {
                if (item.type === "directory") {
                  const hasStats = !!statsCache[item.path];
                  if (hasStats) {
                    const cachedStats = statsCache[item.path];
                    return {
                      ...item,
                      size: cachedStats.totalSize,
                      fileCount: cachedStats.fileCount,
                      videoCount: cachedStats.videoCount,
                      avgSize: cachedStats.avgSize,
                      sizeFormatted: cachedStats.totalSizeFormatted,
                      cached: true,
                      upToDate: true, // Marquer comme √† jour
                    };
                  } else {
                    // Log les dossiers SANS stats pour debug
                    if (Object.keys(statsCache).length < 20 || Math.random() < 0.01) {
                      console.log(`‚ùå No stats in cache for: "${item.path}" (name: "${item.name}")`);
                    }
                  }
                }
                return item;
              });
              
              const foldersFromCache = items.filter(i => i.type === 'directory' && i.cached).length;
              const totalFolders = items.filter(i => i.type === 'directory').length;
              console.log(`üìä Applied stats from localStorage: ${foldersFromCache}/${totalFolders} folders have cached stats`);
              
              setFiles(items);
              if (!connected) setConnected(true);
              
              // Sauvegarder dans le session cache avec le chemin normalis√©
              setSessionCache(prev => {
                const updated = { ...prev, [normalizedPath]: items };
                console.log(`üíæ SAVING to session cache: "${normalizedPath}" with ${items.length} items`);
                console.log(`üìã Session cache now has keys:`, Object.keys(updated));
                return updated;
              });
              console.log(`‚úÖ Loaded ${items.length} items (${items.filter(i => i.type === 'directory').length} folders)`);
              
              // Calculer les stats manquantes progressivement par vagues
              // Ne calculer QUE les dossiers qui n'ont pas de stats en cache
              const foldersNeedingStats = items.filter(i => 
                i.type === 'directory' && !i.cached && (!i.size || i.size === 0)
              );
              
              if (foldersNeedingStats.length > 0) {
                // Trier par ordre alphab√©tique
                foldersNeedingStats.sort((a, b) => a.name.localeCompare(b.name));
                
                console.log(`üìä Need to calculate stats for ${foldersNeedingStats.length} folders (sorted alphabetically)`);
                
                // Activer l'indicateur de chargement
                setCalculatingStats({ isCalculating: true, current: 0, total: foldersNeedingStats.length });
                
                // Calculer par vagues de 10 avec d√©lai entre chaque vague
                const batchSize = 10;
                const delayBetweenBatches = 10; // 10ms entre chaque vague
                
                const calculateInBatches = async (folders, startIndex = 0) => {
                  if (startIndex >= folders.length) {
                    console.log(`‚úÖ All folder stats calculated!`);
                    setCalculatingStats({ isCalculating: false, current: 0, total: 0 });
                    return;
                  }
                  
                  const batch = folders.slice(startIndex, startIndex + batchSize);
                  const remaining = folders.length - startIndex - batch.length;
                  
                  console.log(`üî¢ Calculating batch ${Math.floor(startIndex / batchSize) + 1}: ${batch.length} folders (${remaining} remaining)`);
                  
                  // Mettre √† jour le compteur
                  setCalculatingStats({ isCalculating: true, current: startIndex + batch.length, total: folders.length });
                  
                  // üî• ATTENDRE que TOUS les calculs du batch soient termin√©s
                  await Promise.all(batch.map(folder => calculateFolderSize(folder.path, true)));
                  
                  // Continuer avec le prochain batch apr√®s un court d√©lai
                  if (remaining > 0) {
                    setTimeout(() => calculateInBatches(folders, startIndex + batchSize), delayBetweenBatches);
                  } else {
                    // Dernier batch termin√©
                    setCalculatingStats({ isCalculating: false, current: 0, total: 0 });
                  }
                };
                
                // Lancer le calcul par vagues
                calculateInBatches(foldersNeedingStats);
              }
              
            } catch (error) {
              console.error("‚ùå Error loading files:", error);
            } finally {
              setLoading(false);
            }
          },
          [connected]
        );

        // Synchroniser le cache au montage du composant
        React.useEffect(() => {
          const initSync = async () => {
            try {
              // V√©rifier si on est connect√©
              const result = await window.electronAPI.webdavConnect();
              if (result.success) {
                setConnected(true);
                // Synchroniser le cache avec le serveur
                await syncCacheWithServer();
                // Charger les fichiers de la racine
                await loadFiles("/");
              }
            } catch (error) {
              console.error('Error during initial sync:', error);
            }
          };
          
          initSync();

          // Listen for cache sync triggers from main process
          const handleCacheSyncTrigger = async () => {
            console.log('Cache sync triggered by main process');
            await syncCacheWithServer();
          };

          if (window.electronAPI.onWebdavTriggerCacheSync) {
            window.electronAPI.onWebdavTriggerCacheSync(handleCacheSyncTrigger);
          }

          // Cleanup listener on unmount
          return () => {
            // Note: electronAPI cleanup would go here if available
          };
        }, []); // Empty array = run once on mount

        const connectToServer = async () => {
          try {
            const result = await window.electronAPI.webdavConnect();
            if (result.success) {
              setConnected(true);
              await loadFiles("/");
            } else {
              alert("Failed to connect: " + result.error);
            }
          } catch (error) {
            alert("Connection error: " + error.message);
          }
        };

        const navigateToFolder = (folderPath) => {
          // Normaliser le chemin : toujours commencer par /
          const normalizedPath = folderPath.startsWith('/') ? folderPath : '/' + folderPath;
          console.log(`üß≠ Navigating to: ${normalizedPath} (original: ${folderPath})`);
          setCurrentPath(normalizedPath);
          setTimeout(() => loadFiles(normalizedPath), 0);
        };

        const goBack = () => {
          if (currentPath === "/") return;
          console.log(`‚¨ÖÔ∏è goBack called, currentPath="${currentPath}"`);
          const pathParts = currentPath.split("/").filter(p => p);
          console.log(`üìÇ pathParts before pop:`, pathParts);
          pathParts.pop();
          console.log(`üìÇ pathParts after pop:`, pathParts);
          const parentPath = pathParts.length > 0 ? "/" + pathParts.join("/") : "/";
          console.log(`üéØ Calculated parentPath="${parentPath}"`);
          navigateToFolder(parentPath);
        };

        const addToQueue = (file) => {
          onAddToQueue(file.path, file);
        };

        // Charger les m√©tadonn√©es vid√©o d'un fichier sp√©cifique
        const loadVideoInfo = async (filePath) => {
          try {
            setLoadingVideoInfo(prev => ({ ...prev, [filePath]: true }));
            
            const result = await window.electronAPI.webdavGetFileInfo(filePath);
            
            if (result.success && result.fileInfo) {
              // Mettre √† jour le fichier dans la liste
              setFiles(prevFiles => 
                prevFiles.map(f => 
                  f.path === filePath 
                    ? { ...f, ...result.fileInfo }
                    : f
                )
              );
              
              // Mettre √† jour le cache de session
              setSessionCache(prev => {
                const pathFiles = prev[currentPath];
                if (pathFiles) {
                  return {
                    ...prev,
                    [currentPath]: pathFiles.map(f => 
                      f.path === filePath 
                        ? { ...f, ...result.fileInfo }
                        : f
                    )
                  };
                }
                return prev;
              });
            }
          } catch (error) {
            console.error("Error loading video info:", error);
          } finally {
            setLoadingVideoInfo(prev => {
              const newState = { ...prev };
              delete newState[filePath];
              return newState;
            });
          }
        };

        const addFolderToQueue = async (folderPath) => {
          try {
            setLoading(true);
            const result = await window.electronAPI.webdavScanFolderRecursive(folderPath);

            if (result.success && result.files.length > 0) {
              let addedCount = 0;
              for (const file of result.files) {
                if (!isEncoded(file.path)) {
                  await onAddToQueue(file.path, file);
                  addedCount++;
                }
              }
              console.log(`Added ${addedCount} files to queue from folder`);
            } else if (result.success && result.files.length === 0) {
              console.log("No video files found in this folder");
            } else {
              console.error("Failed to scan folder:", result.error);
            }
          } catch (error) {
            console.error("Error scanning folder:", error.message);
          } finally {
            setLoading(false);
          }
        };

        // Fusionn√©: un seul bouton "Add" qui d√©tecte automatiquement si c'est une s√©rie ou un dossier
        const shouldShowAddButton = (folderName, filesList) => {
          // Show button for any directory (series or regular folder)
          return true;
        };

        const addToQueueSmart = async (folderPath, folderName) => {
          try {
            setLoading(true);

            // D√©tecter si c'est une s√©rie (contient plusieurs dossiers Season)
            const seasonFolders = files.filter((f) => f.type === "directory" && f.name.toLowerCase().includes("season"));
            const isSeries = seasonFolders.length >= 2;

            if (isSeries) {
              // Mode s√©rie: ajouter tous les dossiers Season
              let totalAdded = 0;
              let totalSeasons = 0;

              for (const seasonFolder of seasonFolders) {
                const result = await window.electronAPI.webdavScanFolderRecursive(seasonFolder.path);

                if (result.success && result.files.length > 0) {
                  totalSeasons++;
                  for (const file of result.files) {
                    if (!isEncoded(file.path)) {
                      await addToQueue({ path: file.path, ...file });
                      totalAdded++;
                    }
                  }
                }
              }

              if (totalAdded > 0) {
                alert(`‚úÖ Added ${totalAdded} episodes from ${totalSeasons} seasons to queue!`);
              } else {
                alert("No new episodes to add (all already encoded)");
              }
            } else {
              // Mode dossier simple: ajouter tous les fichiers du dossier r√©cursivement
              const result = await window.electronAPI.webdavScanFolderRecursive(folderPath);

              if (result.success && result.files.length > 0) {
                let addedCount = 0;
                for (const file of result.files) {
                  if (!isEncoded(file.path)) {
                    await addToQueue({ path: file.path, ...file });
                    addedCount++;
                  }
                }
                if (addedCount > 0) {
                  alert(`‚úÖ Added ${addedCount} files to queue!`);
                } else {
                  alert("No new files to add (all already encoded)");
                }
              } else if (result.success && result.files.length === 0) {
                alert("No video files found in this folder");
              } else {
                console.error("Failed to scan folder:", result.error);
              }
            }
          } catch (error) {
            alert("Error adding to queue: " + error.message);
          } finally {
            setLoading(false);
          }
        };

        // Fonction pour rafra√Æchir tous les dossiers du r√©pertoire actuel
        const refreshAllFolders = async () => {
          const folders = files.filter(f => f.type === "directory");
          if (folders.length === 0) return;
          
          setLoading(true);
          try {
            // Marquer tous les dossiers comme pas √† jour dans le cache
            const cache = loadCache();
            folders.forEach(folder => {
              if (cache[folder.path]) {
                cache[folder.path].upToDate = false;
              }
            });
            saveCache(cache);
            
            // Recalculer tous les dossiers
            for (const folder of folders) {
              await calculateFolderSize(folder.path, true, true);
            }
            
            console.log(`‚úÖ Refreshed stats for ${folders.length} folders`);
          } catch (error) {
            console.error("Error refreshing folders:", error);
          } finally {
            setLoading(false);
          }
        };

        const isEncoded = (filePath) => {
          return encodedFiles.some((encoded) => encoded.path === filePath);
        };

        const formatSize = (bytes) => {
          if (!bytes || bytes === 0) return "0 B";
          const k = 1024;
          const sizes = ["B", "KB", "MB", "GB", "TB"];
          const i = Math.min(Math.floor(Math.log(bytes) / Math.log(k)), sizes.length - 1);
          return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
        };

        const sortFiles = (filesList) => {
          const sorted = [...filesList];

          if (sortBy === "size") {
            sorted.sort((a, b) => {
              // Directories first
              if (a.type !== b.type) {
                return a.type === "directory" ? -1 : 1;
              }
              // Then by size (largest first)
              return b.size - a.size;
            });
          } else if (sortBy === "fileCount") {
            sorted.sort((a, b) => {
              // Only sort directories, files stay below
              if (a.type !== b.type) {
                return a.type === "directory" ? -1 : 1;
              }
              if (a.type === "directory") {
                // Sort by file count (most files first)
                return (b.fileCount || 0) - (a.fileCount || 0);
              }
              return a.name.localeCompare(b.name);
            });
          } else if (sortBy === "avgSize") {
            sorted.sort((a, b) => {
              // Only sort directories, files stay below
              if (a.type !== b.type) {
                return a.type === "directory" ? -1 : 1;
              }
              if (a.type === "directory") {
                // Sort by average size per file (largest first)
                return (b.avgSize || 0) - (a.avgSize || 0);
              }
              return a.name.localeCompare(b.name);
            });
          } else {
            // Alpha sort
            sorted.sort((a, b) => {
              // Directories first
              if (a.type !== b.type) {
                return a.type === "directory" ? -1 : 1;
              }
              // Then alphabetically
              return a.name.localeCompare(b.name);
            });
          }

          return sorted;
        };

        const filterFiles = (filesList) => {
          if (!searchTerm) return filesList;

          const term = searchTerm.toLowerCase();
          return filesList.filter((file) => file.name.toLowerCase().includes(term));
        };

        const getDisplayFiles = () => {
          let displayFiles = files;
          displayFiles = filterFiles(displayFiles);
          
          // Filter empty folders if option is enabled
          if (userConfig?.ui?.hide_empty_folders !== false) {
            displayFiles = displayFiles.filter(file => {
              // Keep files (not directories)
              if (file.type !== "directory") return true;
              
              // Keep directories that have video files (videoCount > 0)
              if (file.videoCount && file.videoCount > 0) return true;
              
              // Keep directories without cached stats (we don't know if they're empty yet)
              if (!file.cached) return true;
              
              // Hide directories with 0 video files
              return false;
            });
          }
          
          displayFiles = sortFiles(displayFiles);
          return displayFiles;
        };

        return (
          <div className="bg-glass rounded-lg p-4 h-full flex flex-col">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-xl font-bold">Remote Files</h2>
              <div className="flex items-center space-x-2">
                {loading && <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-400"></div>}
                {loadedFromCache && !loading && (
                  <span className="text-xs text-green-400 bg-green-900/30 px-2 py-1 rounded" title="Directory loaded from cache">
                    üì¶ Cached
                  </span>
                )}
                <span className={connected ? "text-green-400" : "text-gray-400"}>‚óè</span>
                <span className="text-sm">{connected ? "Connected" : "Disconnected"}</span>
              </div>
            </div>

            {/* Indicateur de calcul des stats */}
            {calculatingStats.isCalculating && (
              <div className="mb-3 bg-blue-900/30 border border-blue-500/50 rounded-lg p-3 flex items-center space-x-3">
                <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-400"></div>
                <div className="flex-1">
                  <div className="text-sm text-blue-300 font-medium mb-1">
                    üìä Calculating folder statistics... {calculatingStats.current} / {calculatingStats.total}
                  </div>
                  <div className="w-full bg-gray-700 rounded-full h-2">
                    <div 
                      className="bg-blue-500 h-2 rounded-full transition-all duration-300"
                      style={{ width: `${(calculatingStats.current / calculatingStats.total) * 100}%` }}
                    ></div>
                  </div>
                </div>
                <span className="text-xs text-blue-400">
                  {Math.round((calculatingStats.current / calculatingStats.total) * 100)}%
                </span>
              </div>
            )}

            {connected && (
              <>
                {/* Search and Sort Controls */}
                <div className="mb-4 space-y-2">
                  {/* Search Bar */}
                  <div className="relative">
                    <input
                      type="text"
                      placeholder="üîç Search files and folders..."
                      value={searchTerm}
                      onChange={(e) => setSearchTerm(e.target.value)}
                      className="w-full px-4 py-2 bg-gray-800 text-white rounded-lg border border-gray-700 focus:border-blue-500 focus:outline-none"
                    />
                    {searchTerm && (
                      <button onClick={() => setSearchTerm("")} className="absolute right-2 top-2 text-gray-400 hover:text-white">
                        ‚úï
                      </button>
                    )}
                  </div>

                  {/* Sort Controls */}
                  <div className="flex items-center space-x-2">
                    <span className="text-sm text-gray-400">Sort by:</span>
                    <button onClick={() => setSortBy("alpha")} className={`px-3 py-1 rounded text-sm ${sortBy === "alpha" ? "bg-blue-600 text-white" : "bg-gray-700 text-gray-300 hover:bg-gray-600"}`}>
                      üî§ Name
                    </button>
                    <button onClick={() => setSortBy("size")} className={`px-3 py-1 rounded text-sm ${sortBy === "size" ? "bg-blue-600 text-white" : "bg-gray-700 text-gray-300 hover:bg-gray-600"}`}>
                      üìä Size
                    </button>
                    <button
                      onClick={() => setSortBy("fileCount")}
                      className={`px-3 py-1 rounded text-sm ${sortBy === "fileCount" ? "bg-blue-600 text-white" : "bg-gray-700 text-gray-300 hover:bg-gray-600"}`}
                    >
                      üìÅ Files
                    </button>
                    <button
                      onClick={() => setSortBy("avgSize")}
                      className={`px-3 py-1 rounded text-sm ${sortBy === "avgSize" ? "bg-blue-600 text-white" : "bg-gray-700 text-gray-300 hover:bg-gray-600"}`}
                    >
                      ‚öñÔ∏è Avg/File
                    </button>
                    <span className="text-xs text-gray-500">({getDisplayFiles().length} items)</span>
                  </div>
                </div>

                {/* Navigation */}
                <div className="flex items-center justify-between mb-4">
                  <div className="flex items-center space-x-2">
                    {currentPath && currentPath !== "/" && (
                      <button onClick={goBack} className="btn-secondary">
                        ‚Üê Back
                      </button>
                    )}
                    <span className="text-sm text-gray-300">{currentPath || "/"}</span>
                  </div>
                  <div className="flex items-center space-x-2">
                    <button onClick={() => loadFiles(currentPath, true)} className="btn-secondary text-xs" title="Refresh directory from server (clear cache)">
                      üîÑ Refresh Directory
                    </button>
                    <button onClick={refreshAllFolders} className="btn-secondary text-xs" title="Refresh all folder stats in current directory">
                      ÔøΩ Refresh Stats
                    </button>
                  </div>
                </div>

                {/* File List */}
                <div className="flex-1 overflow-y-auto scrollbar-thin">
                  {loading ? (
                    <div className="flex items-center justify-center h-32">
                      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
                    </div>
                  ) : (
                    <div className="space-y-2">
                      {getDisplayFiles().map((file, index) => (
                        <div key={index} className="flex items-center justify-between p-3 bg-gray-800 rounded-lg hover:bg-gray-700 transition-colors">
                          <div className="flex items-center space-x-3 flex-1">
                            <span className="text-lg">{file.type === "directory" ? "üìÅ" : "üé¨"}</span>
                            <div className="flex-1">
                              <div className="font-medium">{file.name}</div>
                              <div className="text-sm text-gray-400">
                                {file.type === "directory" ? (
                                  <>
                                    {file.size > 0 || file.fileCount > 0 ? (
                                      <div className="flex items-center space-x-3">
                                        {file.size > 0 && <span>üì¶ {file.sizeFormatted || formatSize(file.size)}</span>}
                                        {file.videoCount > 0 && <span>üé¨ {file.videoCount} videos</span>}
                                        {file.avgSize > 0 && <span className="text-xs">‚öñÔ∏è {formatSize(file.avgSize)}/file</span>}
                                      </div>
                                    ) : (
                                      <span>üìÇ Folder</span>
                                    )}
                                  </>
                                ) : (
                                  <>
                                    <div className="flex flex-wrap items-center gap-2">
                                      <span>üì¶ {formatSize(file.size)}</span>
                                      {file.container && <span className="bg-indigo-900/40 px-2 py-0.5 rounded text-xs">üì¶ {file.container.toUpperCase()}</span>}
                                      {file.codec && <span className="bg-blue-900/40 px-2 py-0.5 rounded text-xs">üéûÔ∏è {file.codec.toUpperCase()}</span>}
                                      {file.resolution && <span className="bg-cyan-900/40 px-2 py-0.5 rounded text-xs">üì∫ {file.resolution}</span>}
                                      {file.duration && (
                                        <span className="bg-purple-900/40 px-2 py-0.5 rounded text-xs">
                                          ‚è±Ô∏è {Math.floor(file.duration / 60)}:{String(Math.floor(file.duration % 60)).padStart(2, '0')}
                                        </span>
                                      )}
                                      {file.bitrate && file.bitrate > 0 && (
                                        <span className="bg-green-900/40 px-2 py-0.5 rounded text-xs">
                                          üìä {(file.bitrate / 1000000).toFixed(1)} Mbps
                                        </span>
                                      )}
                                      {file.audio > 0 && (
                                        <span className="bg-orange-900/40 px-2 py-0.5 rounded text-xs">
                                          üîä {file.audio} {file.audioCodec ? `(${file.audioCodec.toUpperCase()})` : 'audio'}
                                        </span>
                                      )}
                                      {file.subtitles > 0 && <span className="bg-yellow-900/40 px-2 py-0.5 rounded text-xs">üí¨ {file.subtitles} subs</span>}
                                      {isEncoded(file.path) && <span className="text-green-400 font-semibold">‚úÖ Encoded</span>}
                                    </div>
                                  </>
                                )}
                              </div>
                            </div>
                          </div>
                          <div className="flex space-x-2">
                            {file.type === "directory" ? (
                              <>
                                <button onClick={() => navigateToFolder(file.path)} className="btn-secondary">
                                  ‚ÜòÔ∏è                                
                                </button>
                                {!file.cached && !calculatingSize[file.path] && (
                                  <button onClick={() => calculateFolderSize(file.path, false, false)} className="btn-secondary text-xs" title="Calculate folder size">
                                    üìä 
                                  </button>
                                )}
                                {calculatingSize[file.path] && (
                                  <span className="text-xs text-blue-400 flex items-center">
                                    <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-blue-400 mr-1"></div>
                                    Calculating...
                                  </span>
                                )}
                                {file.cached && file.upToDate !== false && (
                                  <button onClick={() => calculateFolderSize(file.path, false, true)} className="btn-secondary text-xs" title="Force refresh folder stats">
                                    üîÑ
                                  </button>
                                )}
                                {file.cached && file.upToDate === false && (
                                  <button onClick={() => calculateFolderSize(file.path, false, true)} className="bg-yellow-600 hover:bg-yellow-500 text-white px-2 py-1 rounded text-xs" title="Stats may be outdated - click to refresh">
                                    üîÑ
                                  </button>
                                )}
                                <button onClick={() => addToQueueSmart(file.path, file.name)} className="btn-success" title="Add folder to queue (detects series automatically)">
                                  ‚ûï
                                </button>
                              </>
                            ) : (
                              <>
                                <button 
                                  onClick={() => addToQueue(file)} 
                                  disabled={isEncoded(file.path)} 
                                  className={isEncoded(file.path) ? "btn-secondary opacity-50 cursor-not-allowed" : "btn-success"}
                                >
                                  {isEncoded(file.path) ? "Encoded" : "Add to Queue"}
                                </button>
                              </>
                            )}
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              </>
            )}
          </div>
        );
      };

      // Encoder Info Panel Component
      const EncoderInfoPanel = ({ userConfig }) => {
        if (!userConfig || !userConfig.ffmpeg) return null;

        const ffmpegConfig = userConfig.ffmpeg;
        const isGPU = ffmpegConfig.force_gpu || ffmpegConfig.gpu_enabled;

        return (
          <div className="encoder-info-panel">
            <div className="flex items-center justify-between mb-2">
              <div className="flex items-center">
                <span className="text-sm font-semibold text-gray-300 mr-3">‚öôÔ∏è Encoding Settings</span>
                {isGPU ? <span className="encoder-badge encoder-badge-gpu">üéÆ GPU (NVENC)</span> : <span className="encoder-badge encoder-badge-cpu">üñ•Ô∏è CPU (x265)</span>}
              </div>
            </div>
            <div className="flex flex-wrap items-center gap-1">
              <div className="encoder-param">
                <span className="encoder-param-label">Codec:</span>
                <span className="encoder-param-value">{isGPU ? "hevc_nvenc" : "libx265"}</span>
              </div>
              <div className="encoder-param">
                <span className="encoder-param-label">Preset:</span>
                <span className="encoder-param-value">{isGPU ? ffmpegConfig.encode_preset || "p7" : ffmpegConfig.cpu_preset || "medium"}</span>
              </div>
              <div className="encoder-param">
                <span className="encoder-param-label">Quality:</span>
                <span className="encoder-param-value">{isGPU ? `CQ ${ffmpegConfig.cq || 18}` : `CRF ${ffmpegConfig.crf || 23}`}</span>
              </div>
              {isGPU && (
                <>
                  <div className="encoder-param">
                    <span className="encoder-param-label">RC:</span>
                    <span className="encoder-param-value">{ffmpegConfig.rc_mode || "vbr_hq"}</span>
                  </div>
                  <div className="encoder-param">
                    <span className="encoder-param-label">Bitrate:</span>
                    <span className="encoder-param-value">
                      {ffmpegConfig.bitrate || "5M"}/{ffmpegConfig.maxrate || "10M"}
                    </span>
                  </div>
                  <div className="encoder-param">
                    <span className="encoder-param-label">Lookahead:</span>
                    <span className="encoder-param-value">{ffmpegConfig.lookahead || 32}</span>
                  </div>
                  <div className="encoder-param">
                    <span className="encoder-param-label">B-frames:</span>
                    <span className="encoder-param-value">{ffmpegConfig.bframes || 3}</span>
                  </div>
                  <div className="encoder-param">
                    <span className="encoder-param-label">AQ:</span>
                    <span className="encoder-param-value">
                      {ffmpegConfig.spatial_aq !== false ? "S" : ""}
                      {ffmpegConfig.temporal_aq !== false ? "T" : ""}
                      {ffmpegConfig.spatial_aq === false && ffmpegConfig.temporal_aq === false ? "Off" : ""}
                    </span>
                  </div>
                </>
              )}
              <div className="encoder-param">
                <span className="encoder-param-label">Profile:</span>
                <span className="encoder-param-value">{ffmpegConfig.profile || "main"}</span>
              </div>
              <div className="encoder-param">
                <span className="encoder-param-label">Audio:</span>
                <span className="encoder-param-value">{ffmpegConfig.audio_codec === "copy" ? "üìã Copy" : `üîä ${ffmpegConfig.audio_codec} ${ffmpegConfig.audio_bitrate}k`}</span>
              </div>
              {ffmpegConfig.two_pass && (
                <div className="encoder-param">
                  <span className="encoder-param-label">Mode:</span>
                  <span className="encoder-param-value">2-Pass</span>
                </div>
              )}
            </div>
          </div>
        );
      };

      // History Component
      const HistoryTable = ({ jobs }) => {
        const [sortBy, setSortBy] = useState("date"); // 'date', 'filename', 'size'
        const [sortOrder, setSortOrder] = useState("desc"); // 'asc', 'desc'
        const [filterStatus, setFilterStatus] = useState("all"); // 'all', 'completed', 'failed'

        const formatSize = (bytes) => {
          if (!bytes || bytes === 0) return "0 B";
          const k = 1024;
          const sizes = ["B", "KB", "MB", "GB"];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + " " + sizes[i];
        };

        const formatDate = (dateString) => {
          if (!dateString) return "N/A";
          const date = new Date(dateString);
          return date.toLocaleString("fr-FR", {
            day: "2-digit",
            month: "2-digit",
            year: "numeric",
            hour: "2-digit",
            minute: "2-digit",
          });
        };

        const formatDuration = (seconds) => {
          if (!seconds) return "N/A";
          const hours = Math.floor(seconds / 3600);
          const minutes = Math.floor((seconds % 3600) / 60);
          const secs = seconds % 60;
          if (hours > 0) return `${hours}h ${minutes}m ${secs}s`;
          if (minutes > 0) return `${minutes}m ${secs}s`;
          return `${secs}s`;
        };

        // Filter jobs - show only completed and failed
        const historyJobs = jobs.filter((job) => job.status === "completed" || job.status === "failed");

        // Apply status filter
        const filteredJobs = filterStatus === "all" ? historyJobs : historyJobs.filter((job) => job.status === filterStatus);

        // Sort jobs
        const sortedJobs = [...filteredJobs].sort((a, b) => {
          let comparison = 0;
          switch (sortBy) {
            case "date":
              comparison = new Date(b.finished_at || b.created_at) - new Date(a.finished_at || a.created_at);
              break;
            case "filename":
              comparison = (a.filepath || "").localeCompare(b.filepath || "");
              break;
            case "size":
              comparison = (b.size || 0) - (a.size || 0);
              break;
            default:
              comparison = 0;
          }
          return sortOrder === "desc" ? comparison : -comparison;
        });

        // Calculate stats
        const completedJobs = historyJobs.filter((j) => j.status === "completed");
        const totalOriginalSize = completedJobs.reduce((sum, j) => sum + (j.size || 0), 0);
        const totalCompressedSize = completedJobs.reduce((sum, j) => sum + (j.compressed_size || j.size || 0), 0);
        const totalSaved = totalOriginalSize - totalCompressedSize;
        const avgCompressionRatio = completedJobs.length > 0 ? (totalSaved / totalOriginalSize) * 100 : 0;

        return (
          <div className="h-full flex flex-col bg-gray-800 rounded-lg p-4">
            {/* Header */}
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-xl font-bold">üìú Historique des Conversions</h2>
              <div className="flex items-center space-x-2">
                <select value={filterStatus} onChange={(e) => setFilterStatus(e.target.value)} className="bg-gray-700 text-white px-3 py-1 rounded text-sm border border-gray-600">
                  <option value="all">Tous</option>
                  <option value="completed">‚úÖ R√©ussis</option>
                  <option value="failed">‚ùå √âchou√©s</option>
                </select>
                <select value={sortBy} onChange={(e) => setSortBy(e.target.value)} className="bg-gray-700 text-white px-3 py-1 rounded text-sm border border-gray-600">
                  <option value="date">Trier par Date</option>
                  <option value="filename">Trier par Nom</option>
                  <option value="size">Trier par Taille</option>
                </select>
                <button onClick={() => setSortOrder(sortOrder === "asc" ? "desc" : "asc")} className="bg-gray-700 text-white px-3 py-1 rounded text-sm border border-gray-600 hover:bg-gray-600">
                  {sortOrder === "asc" ? "‚Üë" : "‚Üì"}
                </button>
              </div>
            </div>

            {/* Stats Summary */}
            <div className="grid grid-cols-4 gap-2 mb-4 text-sm">
              <div className="bg-gray-700 rounded p-2 text-center">
                <div className="text-gray-400">Total Jobs</div>
                <div className="text-lg font-bold">{historyJobs.length}</div>
              </div>
              <div className="bg-green-900 rounded p-2 text-center">
                <div className="text-gray-400">R√©ussis</div>
                <div className="text-lg font-bold text-green-400">{completedJobs.length}</div>
              </div>
              <div className="bg-red-900 rounded p-2 text-center">
                <div className="text-gray-400">√âchou√©s</div>
                <div className="text-lg font-bold text-red-400">{historyJobs.filter((j) => j.status === "failed").length}</div>
              </div>
              <div className="bg-blue-900 rounded p-2 text-center">
                <div className="text-gray-400">√âconomis√©</div>
                <div className="text-lg font-bold text-blue-400">{formatSize(totalSaved)}</div>
                <div className="text-xs text-gray-400">{avgCompressionRatio.toFixed(1)}%</div>
              </div>
            </div>

            {/* History Table */}
            <div className="flex-1 overflow-y-auto scrollbar-thin">
              {sortedJobs.length === 0 ? (
                <div className="text-center py-12 text-gray-400">
                  <div className="text-4xl mb-2">üì≠</div>
                  <p>Aucun historique disponible</p>
                </div>
              ) : (
                <table className="w-full text-sm">
                  <thead className="sticky top-0 bg-gray-700 text-gray-300">
                    <tr>
                      <th className="text-left p-2">Fichier</th>
                      <th className="text-center p-2 w-24">Statut</th>
                      <th className="text-center p-2 w-28">Taille</th>
                      <th className="text-center p-2 w-28">√âconomie</th>
                      <th className="text-center p-2 w-24">Dur√©e</th>
                      <th className="text-center p-2 w-32">Date</th>
                    </tr>
                  </thead>
                  <tbody>
                    {sortedJobs.map((job) => {
                      const compressionRatio = job.size && job.compressed_size ? ((job.size - job.compressed_size) / job.size) * 100 : 0;
                      const encodingTime = job.started_at && job.finished_at ? Math.floor((new Date(job.finished_at) - new Date(job.started_at)) / 1000) : null;

                      return (
                        <tr key={job.id} className="border-b border-gray-700 hover:bg-gray-750">
                          <td className="p-2">
                            <div className="truncate max-w-xs" title={job.filepath}>
                              {job.filepath ? job.filepath.split("/").pop() : "Unknown"}
                            </div>
                            {job.codec_before && job.codec_after && (
                              <div className="text-xs text-gray-500">
                                {job.codec_before} ‚Üí {job.codec_after}
                              </div>
                            )}
                          </td>
                          <td className="p-2 text-center">
                            {job.status === "completed" ? (
                              <span className="px-2 py-1 rounded text-xs bg-green-900 text-green-300">‚úÖ OK</span>
                            ) : (
                              <span className="px-2 py-1 rounded text-xs bg-red-900 text-red-300" title={job.error}>
                                ‚ùå √âchec
                              </span>
                            )}
                          </td>
                          <td className="p-2 text-center">
                            <div>{formatSize(job.size)}</div>
                            {job.compressed_size && <div className="text-xs text-gray-500">‚Üí {formatSize(job.compressed_size)}</div>}
                          </td>
                          <td className="p-2 text-center">
                            {job.status === "completed" && compressionRatio > 0 ? (
                              <span className="text-green-400 font-bold">-{compressionRatio.toFixed(1)}%</span>
                            ) : (
                              <span className="text-gray-500">-</span>
                            )}
                          </td>
                          <td className="p-2 text-center text-gray-400">{encodingTime ? formatDuration(encodingTime) : "-"}</td>
                          <td className="p-2 text-center text-xs text-gray-400">{formatDate(job.finished_at || job.created_at)}</td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              )}
            </div>
          </div>
        );
      };

      // Queue Table Component
      const QueueTable = ({ jobs, onRemoveJob, onRetryJob, progressData, queueStatus, userConfig, setQueueStatus, loadJobs, loadQueueStatus, addLog, setJobs, loadStats }) => {
        const formatSize = (bytes) => {
          if (!bytes || bytes === 0) return "0 B";
          const k = 1024;
          const sizes = ["B", "KB", "MB", "GB", "TB"];
          const i = Math.min(Math.floor(Math.log(bytes) / Math.log(k)), sizes.length - 1);
          return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
        };

        const getJobProgress = (jobId) => {
          return progressData[jobId] || { progress: 0, type: null, eta: null };
        };

        const formatDuration = (seconds) => {
          if (!seconds) return "";
          const hours = Math.floor(seconds / 3600);
          const minutes = Math.floor((seconds % 3600) / 60);
          if (hours > 0) {
            return `${hours}h ${minutes}m`;
          } else {
            return `${minutes}m`;
          }
        };

        return (
          <div className="bg-glass rounded-lg p-4 h-full flex flex-col">
            {/* Queue Control Panel */}
            <div className="bg-gray-800 rounded-lg p-4 mb-4 border-2 border-gray-700">
              {/* Status and Control */}
              <div className="flex items-center justify-between">
                <div className="flex items-center space-x-3">
                  {/* Status Indicator */}
                  <div className={`text-lg font-bold px-3 py-1.5 rounded-lg ${!queueStatus.isRunning ? "bg-gray-700 text-gray-400" : "bg-green-600 text-white animate-pulse"}`}>
                    {!queueStatus.isRunning ? "‚èπÔ∏è ARR√äT√âE" : "‚ñ∂Ô∏è EN MARCHE"}
                  </div>

                  {/* Start/Stop Button */}
                  <button
                    onClick={async () => {
                      try {
                        setQueueStatus((prev) => ({ ...prev, loading: true }));

                        if (queueStatus.isRunning) {
                          // Arr√™ter : annuler tout et remettre √† z√©ro
                          const result = await window.electronAPI.queueStop();
                          if (result.success) {
                            // Recharger tous les jobs pour remettre ceux en cours √† "waiting"
                            await loadJobs();
                            await loadQueueStatus();
                            addLog("Queue arr√™t√©e - Jobs en cours remis √† z√©ro", "info");
                          }
                        } else {
                          // D√©marrer
                          const result = await window.electronAPI.queueStart();
                          if (result.success) {
                            await loadQueueStatus();
                            addLog("Queue d√©marr√©e", "success");
                          }
                        }
                      } catch (error) {
                        console.error("Toggle queue error:", error);
                        addLog(`Erreur: ${error.message}`, "error");
                      } finally {
                        setQueueStatus((prev) => ({ ...prev, loading: false }));
                      }
                    }}
                    className={`font-semibold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center space-x-2 ${
                      !queueStatus.isRunning ? "bg-green-600 hover:bg-green-700 text-white" : "bg-red-600 hover:bg-red-700 text-white"
                    }`}
                    disabled={queueStatus.loading || (!queueStatus.isRunning && jobs.length === 0)}
                    title={!queueStatus.isRunning ? "D√©marrer" : "Arr√™ter et remettre √† z√©ro"}
                  >
                    <span className="text-xl">{!queueStatus.isRunning ? "‚ñ∂Ô∏è" : "‚èπÔ∏è"}</span>
                    <span>{queueStatus.loading ? (queueStatus.isRunning ? "Arr√™t..." : "D√©marrage...") : queueStatus.isRunning ? "ARR√äTER" : "D√âMARRER"}</span>
                  </button>

                  {/* Current Job Info */}
                  {queueStatus.isRunning && queueStatus.currentJob && (
                    <div className="text-sm text-gray-300">
                      <span className="text-gray-500">‚Üí</span> {queueStatus.currentJob.filepath?.split("/").pop() || "Processing..."}
                    </div>
                  )}
                </div>

                <div className="flex items-center gap-2">
                  <span className="text-sm text-gray-400">
                    {jobs.length} fichier{jobs.length > 1 ? "s" : ""}
                  </span>

                  {/* Clear Queue Button */}
                  {jobs.length > 0 && (
                    <button
                      onClick={async () => {
                        if (window.confirm(`√ätes-vous s√ªr de vouloir effacer les ${jobs.length} fichiers de la queue ?`)) {
                          try {
                            setQueueStatus((prev) => ({ ...prev, loading: true }));
                            const result = await window.electronAPI.queueClear();
                            if (result.success) {
                              addLog(`${result.count} jobs supprim√©s`, "info");
                              setJobs([]);
                              await loadJobs();
                              await loadQueueStatus();
                              await loadStats();
                            } else {
                              addLog(`Erreur: ${result.error}`, "error");
                            }
                          } catch (error) {
                            console.error("Failed to clear queue:", error);
                            addLog(`Erreur: ${error.message}`, "error");
                          } finally {
                            setQueueStatus((prev) => ({ ...prev, loading: false }));
                          }
                        }
                      }}
                      className="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                      disabled={queueStatus.loading}
                      title="Vider la queue"
                    >
                      üóëÔ∏è Vider
                    </button>
                  )}
                </div>
              </div>
            </div>

            {/* Encoder Info Panel */}
            <EncoderInfoPanel userConfig={userConfig} />

            {/* Queue Status Indicator */}
            {queueStatus.isRunning && queueStatus.currentJob && (
              <div className="mb-3 p-3 bg-blue-900 bg-opacity-50 rounded-lg">
                <div className="flex items-center justify-between">
                  <div className="flex items-center">
                    <div className={`rounded-full h-2 w-2 mr-2 ${queueStatus.isPaused ? "bg-yellow-400" : "animate-pulse bg-blue-400"}`}></div>
                    <span className="text-sm text-blue-300">
                      {queueStatus.isPaused ? "‚è∏Ô∏è Paused: " : "üé¨ Encoding: "}
                      {queueStatus.currentJob.filepath?.split("/").pop() || "Processing..."}
                    </span>
                  </div>
                  {queueStatus.currentJob.started_at && <span className="text-xs text-blue-400">Started: {new Date(queueStatus.currentJob.started_at).toLocaleTimeString()}</span>}
                </div>
              </div>
            )}

            <div className="flex-1 overflow-y-auto scrollbar-thin">
              {jobs.length === 0 ? (
                <div className="flex items-center justify-center h-32 text-gray-400">No jobs in queue</div>
              ) : (
                <div className="space-y-3">
                  {[...jobs]
                    .sort((a, b) => {
                      // Sort by status first: encoding > downloading > ready_encode > uploading > ready_upload > waiting > paused > completed > failed
                      const statusOrder = {
                        encoding: 0,
                        downloading: 1,
                        ready_encode: 2,
                        uploading: 3,
                        ready_upload: 4,
                        waiting: 5,
                        paused: 6,
                        completed: 7,
                        failed: 8,
                      };
                      const statusDiff = (statusOrder[a.status] || 99) - (statusOrder[b.status] || 99);
                      if (statusDiff !== 0) return statusDiff;

                      // Then sort alphabetically by filename
                      const nameA = a.filepath.split("/").pop().toLowerCase();
                      const nameB = b.filepath.split("/").pop().toLowerCase();
                      return nameA.localeCompare(nameB);
                    })
                    .map((job) => {
                      const progress = getJobProgress(job.id);
                      return (
                        <div key={job.id} className="bg-gray-800 rounded-lg p-4">
                          <div className="flex items-start justify-between mb-3">
                            <div className="flex-1">
                              <div className="font-medium text-white mb-1">{job.filepath}</div>
                              <div className="flex flex-wrap items-center gap-2 text-xs">
                                <span className="bg-gray-700 px-2 py-0.5 rounded">üì¶ {formatSize(job.size)}</span>
                                {job.container && <span className="bg-indigo-900/40 px-2 py-0.5 rounded">üì¶ {job.container.toUpperCase()}</span>}
                                {job.codec_before && <span className="bg-blue-900/40 px-2 py-0.5 rounded">üéûÔ∏è {job.codec_before.toUpperCase()}</span>}
                                {job.resolution && <span className="bg-cyan-900/40 px-2 py-0.5 rounded">üì∫ {job.resolution}</span>}
                                {job.duration && (
                                  <span className="bg-purple-900/40 px-2 py-0.5 rounded">
                                    ‚è±Ô∏è {Math.floor(job.duration / 60)}:{String(Math.floor(job.duration % 60)).padStart(2, '0')}
                                  </span>
                                )}
                                {job.bitrate && job.bitrate > 0 && (
                                  <span className="bg-green-900/40 px-2 py-0.5 rounded">
                                    üìä {(job.bitrate / 1000000).toFixed(1)} Mbps
                                  </span>
                                )}
                                {job.audio > 0 && (
                                  <span className="bg-orange-900/40 px-2 py-0.5 rounded">
                                    üîä {job.audio} {job.audioCodec ? `(${job.audioCodec.toUpperCase()})` : 'audio'}
                                  </span>
                                )}
                                {job.subtitles > 0 && <span className="bg-yellow-900/40 px-2 py-0.5 rounded">üí¨ {job.subtitles} subs</span>}
                                {job.started_at && <span className="bg-gray-700 px-2 py-0.5 rounded">üïê {new Date(job.started_at).toLocaleTimeString()}</span>}
                              </div>
                            </div>
                            <div className="flex items-center space-x-3">
                              {/* Only show status badge if not in processing state (processing states show their own indicator) */}
                              {!(job.status === "downloading" || job.status === "encoding" || job.status === "uploading") && <StatusBadge status={job.status} />}

                              {/* Action buttons */}
                              <div className="flex space-x-2">
                                {/* Completed jobs - Play buttons */}
                                {job.status === "completed" && (
                                  <>
                                    <button
                                      onClick={() => window.electronAPI.playFile(job.filepath)}
                                      className="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1.5 rounded text-sm transition-colors"
                                      title="Lire le fichier compress√©"
                                    >
                                      ‚ñ∂Ô∏è Compress√©
                                    </button>
                                    <button
                                      onClick={() => window.electronAPI.playOriginalFile(job.filepath.split("/").pop())}
                                      className="bg-gray-600 hover:bg-gray-700 text-white px-3 py-1.5 rounded text-sm transition-colors"
                                      title="Lire le fichier original depuis le backup local"
                                    >
                                      ‚ñ∂Ô∏è Original
                                    </button>
                                  </>
                                )}

                                {/* Failed or ready jobs - Retry button */}
                                {/* Only show retry for failed jobs if they at least started downloading (have started_at) */}
                                {/* Show for ready_encode, ready_upload, paused states (but NOT waiting) */}
                                {((job.status === "failed" && job.started_at) || job.status === "ready_encode" || job.status === "ready_upload" || job.status === "paused") && (
                                  <button onClick={() => onRetryJob(job.id)} className="bg-green-600 hover:bg-green-700 text-white px-3 py-1.5 rounded text-sm transition-colors" title="R√©essayer">
                                    üîÑ R√©essayer
                                  </button>
                                )}

                                {/* Processing jobs - Status indicator */}
                                {(job.status === "downloading" || job.status === "encoding" || job.status === "uploading") && (
                                  <div className="bg-blue-600 text-white px-3 py-1.5 rounded text-sm flex items-center space-x-2">
                                    <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-white"></div>
                                    <span>{job.status === "downloading" ? "T√©l√©chargement..." : job.status === "encoding" ? "Encodage..." : "Upload..."}</span>
                                  </div>
                                )}

                                {/* Remove button - always available */}
                                <button onClick={() => onRemoveJob(job.id)} className="bg-red-600 hover:bg-red-700 text-white px-3 py-1.5 rounded text-sm transition-colors" title="Supprimer">
                                  üóëÔ∏è
                                </button>
                              </div>
                            </div>
                          </div>{" "}
                          {/* Progress Bar */}
                          {(job.status === "downloading" || job.status === "encoding" || job.status === "uploading") && (
                            <div className="mb-2">
                              <ProgressBar
                                progress={progress.progress || job.progress || 0}
                                type={progress.type}
                                eta={progress.eta}
                                fps={progress.fps}
                                speed={progress.speed}
                                elapsedTime={progress.elapsedTime}
                                currentTime={progress.currentTime}
                                totalDuration={progress.totalDuration}
                              />
                            </div>
                          )}
                          {/* Error Message */}
                          {job.error && <div className="mt-2 p-2 bg-red-900 rounded text-red-200 text-sm">{job.error}</div>}
                        </div>
                      );
                    })}
                </div>
              )}
            </div>
          </div>
        );
      };

      // Status Bar Component
      const StatusBar = ({ stats, isConnected }) => {
        return (
          <div className="bg-gray-900 px-4 py-2 flex items-center justify-between text-sm">
            <div className="flex items-center space-x-6">
              <div className="flex items-center space-x-2">
                <span className={`w-2 h-2 rounded-full ${isConnected ? "bg-green-500" : "bg-red-500"}`}></span>
                <span>{isConnected ? "Connected" : "Disconnected"}</span>
              </div>
              <span>
                Queue: {stats.waiting || 0} waiting, {stats.processing || 0} processing
              </span>
              <span>Completed: {stats.completed || 0}</span>
              {stats.failed > 0 && <span className="text-red-400">Failed: {stats.failed}</span>}
            </div>
            <div className="text-gray-400">Sharkoder v1.0.0</div>
          </div>
        );
      };

      // Settings Component
      const SettingsPanel = ({ userConfig, onSave, onClose }) => {
        // Initialize with default values if userConfig is incomplete
        const defaultConfig = {
          encode_preset: "p7",
          cq: 18,
          cpu_preset: "medium",
          cpu_crf: 23,
          remote_host: "",
          remote_user: "",
          remote_password: "",
          remote_path: "",
          local_temp: "",
          local_backup: "",
          webdav_enabled: false,
          webdav_url: "",
          webdav_username: "",
          webdav_password: "",
          webdav_path: "/",
          webdav_transfer_mode: "auto",
          max_concurrent_downloads: 2,
          max_prefetch_files: 3,
          retry_attempts: 2,
          connection_timeout: 30000,
          cleanup_old_jobs_days: 30,
          cleanup_old_progress_days: 365,
          ffmpeg_options: {
            hwaccel: "cuda",
            video_codec: "hevc_nvenc",
            audio_codec: "copy",
            audio_bitrate: 192,
            profile: "main",
            two_pass: false,
            extra_options: [],
          },
          notification_settings: {
            show_completion_notifications: true,
            show_error_notifications: true,
            minimize_to_tray: true,
          },
          advanced: {
            log_level: "info",
            auto_start_queue: false,
            verify_checksums: true,
            create_backups: true,
          },
        };

        const [config, setConfig] = useState({ ...defaultConfig, ...userConfig });
        const [activeTab, setActiveTab] = useState("ffmpeg");
        const [connectionStatus, setConnectionStatus] = useState({ testing: false, message: "", success: null });
        const [webdavConnectionStatus, setWebdavConnectionStatus] = useState({ testing: false, message: "", success: null });

        const updateConfig = (path, value) => {
          const newConfig = { ...config };
          const keys = path.split(".");
          let current = newConfig;
          for (let i = 0; i < keys.length - 1; i++) {
            if (!current[keys[i]]) current[keys[i]] = {};
            current = current[keys[i]];
          }
          current[keys[keys.length - 1]] = value;
          setConfig(newConfig);
        };

        const updateConfigNested = (parent, key, value) => {
          const newConfig = { ...config };
          if (!newConfig[parent]) newConfig[parent] = {};
          newConfig[parent] = { ...newConfig[parent], [key]: value };
          setConfig(newConfig);
        };

        const handleSave = () => {
          onSave(config);
          onClose();
        };

        const testConnection = async () => {
          setConnectionStatus({ testing: true, message: "Testing connection...", success: null });

          try {
            // Save config first to test with latest values
            await window.electronAPI.configSaveUserConfig(config);

            // Try to connect
            const result = await window.electronAPI.sftpConnect();

            if (result.success) {
              setConnectionStatus({
                testing: false,
                message: "‚úÖ Connection successful!",
                success: true,
              });
            } else {
              setConnectionStatus({
                testing: false,
                message: `‚ùå Connection failed: ${result.error}`,
                success: false,
              });
            }
          } catch (error) {
            setConnectionStatus({
              testing: false,
              message: `‚ùå Error: ${error.message}`,
              success: false,
            });
          }

          // Clear message after 5 seconds
          setTimeout(() => {
            setConnectionStatus({ testing: false, message: "", success: null });
          }, 5000);
        };

        return (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-gray-800 rounded-lg w-3/4 max-h-[90vh] overflow-hidden flex flex-col">
              {/* Header */}
              <div className="px-6 py-4 border-b border-gray-700 flex items-center justify-between">
                <h2 className="text-xl font-bold">‚öôÔ∏è Settings</h2>
                <button onClick={onClose} className="text-gray-400 hover:text-white">
                  ‚úï
                </button>
              </div>

              {/* Tabs */}
              <div className="flex border-b border-gray-700 overflow-x-auto">
                <button onClick={() => setActiveTab("ffmpeg")} className={`px-6 py-3 whitespace-nowrap ${activeTab === "ffmpeg" ? "border-b-2 border-blue-500 text-blue-500" : "text-gray-400"}`}>
                  üé¨ FFmpeg
                </button>
                <button onClick={() => setActiveTab("remote")} className={`px-6 py-3 whitespace-nowrap ${activeTab === "remote" ? "border-b-2 border-blue-500 text-blue-500" : "text-gray-400"}`}>
                  üåê Remote Server
                </button>
                <button onClick={() => setActiveTab("storage")} className={`px-6 py-3 whitespace-nowrap ${activeTab === "storage" ? "border-b-2 border-blue-500 text-blue-500" : "text-gray-400"}`}>
                  üíæ Storage
                </button>
                <button onClick={() => setActiveTab("advanced")} className={`px-6 py-3 whitespace-nowrap ${activeTab === "advanced" ? "border-b-2 border-blue-500 text-blue-500" : "text-gray-400"}`}>
                  ‚öôÔ∏è Advanced
                </button>
                <button onClick={() => setActiveTab("ui")} className={`px-6 py-3 whitespace-nowrap ${activeTab === "ui" ? "border-b-2 border-blue-500 text-blue-500" : "text-gray-400"}`}>
                  üé® UI
                </button>
                <button onClick={() => setActiveTab("cache")} className={`px-6 py-3 whitespace-nowrap ${activeTab === "cache" ? "border-b-2 border-blue-500 text-blue-500" : "text-gray-400"}`}>
                  üóÑÔ∏è Cache
                </button>
              </div>

              {/* Content */}
              <div className="h-[650px] overflow-y-auto p-6 space-y-6">
                {activeTab === "ffmpeg" && (
                  <>
                    {/* GPU Settings */}
                    <div className="space-y-4">
                      <h3 className="text-lg font-semibold text-white">GPU Settings (NVENC)</h3>

                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm text-gray-300 mb-2">GPU Encode Preset</label>
                          <select
                            value={config.encode_preset}
                            onChange={(e) => updateConfig("encode_preset", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          >
                            <option value="p1">P1 (Fastest)</option>
                            <option value="p2">P2</option>
                            <option value="p3">P3</option>
                            <option value="p4">P4</option>
                            <option value="p5">P5</option>
                            <option value="p6">P6</option>
                            <option value="p7">P7 (Best Quality)</option>
                          </select>
                          <p className="text-xs text-gray-400 mt-1">P7 = tr√®s lent, meilleure compression</p>
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">CQ (Constant Quality)</label>
                          <input
                            type="number"
                            min="0"
                            max="51"
                            value={config.cq}
                            onChange={(e) => updateConfig("cq", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                          <p className="text-xs text-gray-400 mt-1">18-22 = haute qualit√©, 24-28 = moyenne, 30+ = compress√©</p>
                        </div>
                      </div>

                      {/* Advanced NVENC Settings */}
                      <div className="pt-4 border-t border-gray-700">
                        <h4 className="text-md font-semibold text-white mb-3">‚öôÔ∏è Param√®tres Avanc√©s NVENC</h4>

                        <div className="grid grid-cols-2 gap-4">
                          <div>
                            <label className="block text-sm text-gray-300 mb-2">Mode de Contr√¥le RC</label>
                            <select
                              value={config.ffmpeg?.rc_mode || "vbr_hq"}
                              onChange={(e) => updateConfigNested("ffmpeg", "rc_mode", e.target.value)}
                              className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            >
                              <option value="constqp">CQP (Constant QP)</option>
                              <option value="vbr">VBR (Variable Bitrate)</option>
                              <option value="vbr_hq">VBR HQ (Recommand√©)</option>
                              <option value="cbr">CBR (Constant Bitrate)</option>
                            </select>
                            <p className="text-xs text-gray-400 mt-1">VBR HQ = meilleur compromis qualit√©/taille</p>
                          </div>

                          <div>
                            <label className="block text-sm text-gray-300 mb-2">Bitrate Moyen</label>
                            <input
                              type="text"
                              value={config.ffmpeg?.bitrate || "5M"}
                              onChange={(e) => updateConfigNested("ffmpeg", "bitrate", e.target.value)}
                              className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                              placeholder="5M"
                            />
                            <p className="text-xs text-gray-400 mt-1">Ex: 3M, 5M, 10M (Mb/s)</p>
                          </div>

                          <div>
                            <label className="block text-sm text-gray-300 mb-2">Maxrate (Pic autoris√©)</label>
                            <input
                              type="text"
                              value={config.ffmpeg?.maxrate || "10M"}
                              onChange={(e) => updateConfigNested("ffmpeg", "maxrate", e.target.value)}
                              className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                              placeholder="10M"
                            />
                            <p className="text-xs text-gray-400 mt-1">D√©bit maximum autoris√©</p>
                          </div>

                          <div>
                            <label className="block text-sm text-gray-300 mb-2">Lookahead Frames</label>
                            <input
                              type="number"
                              min="0"
                              max="32"
                              value={config.ffmpeg?.lookahead || 32}
                              onChange={(e) => updateConfigNested("ffmpeg", "lookahead", parseInt(e.target.value))}
                              className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            />
                            <p className="text-xs text-gray-400 mt-1">0-32, analyse frames √† l'avance (32 recommand√©)</p>
                          </div>

                          <div>
                            <label className="block text-sm text-gray-300 mb-2">B-Frames</label>
                            <input
                              type="number"
                              min="0"
                              max="4"
                              value={config.ffmpeg?.bframes || 3}
                              onChange={(e) => updateConfigNested("ffmpeg", "bframes", parseInt(e.target.value))}
                              className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            />
                            <p className="text-xs text-gray-400 mt-1">0-4, augmente compression (3 recommand√©)</p>
                          </div>

    

                          <div>
                            <label className="block text-sm text-gray-300 mb-2">AQ Strength</label>
                            <input
                              type="number"
                              min="1"
                              max="15"
                              value={config.ffmpeg?.aq_strength || 8}
                              onChange={(e) => updateConfigNested("ffmpeg", "aq_strength", parseInt(e.target.value))}
                              className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            />
                            <p className="text-xs text-gray-400 mt-1">1-15, force de quantification adaptative (8 recommand√©)</p>
                          </div>




                          <div>
                            <label className="block text-sm text-gray-300 mb-2">B-Frame Ref Mode</label>
                            <select
                              value={config.ffmpeg?.b_ref_mode || "middle"}
                              onChange={(e) => updateConfigNested("ffmpeg", "b_ref_mode", e.target.value)}
                              className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            >
                              <option value="disabled">Disabled</option>
                              <option value="each">Each (r√©f√©rence tous)</option>
                              <option value="middle">Middle (r√©f√©rence milieu) - Recommand√©</option>
                            </select>
                            <p className="text-xs text-gray-400 mt-1">Comment B-frames sont r√©f√©renc√©s</p>
                          </div>

                          <div>
                            <label className="block text-sm text-gray-300 mb-2">Multipass Mode</label>
                            <select
                              value={config.ffmpeg?.multipass || "fullres"}
                              onChange={(e) => updateConfigNested("ffmpeg", "multipass", e.target.value)}
                              className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            >
                              <option value="disabled">Disabled</option>
                              <option value="qres">Quarter Resolution (plus rapide)</option>
                              <option value="fullres">Full Resolution (meilleure qualit√©) - Recommand√©</option>
                            </select>
                            <p className="text-xs text-gray-400 mt-1">Mode multi-passes pour meilleure qualit√©</p>
                          </div>

                          <div>
                            <label className="flex items-center space-x-2 cursor-pointer">
                              <input
                                type="checkbox"
                                checked={config.ffmpeg?.temporal_aq !== false}
                                onChange={(e) => updateConfigNested("ffmpeg", "temporal_aq", e.target.checked)}
                                className="form-checkbox h-5 w-5 text-blue-600"
                              />
                              <span className="text-sm text-gray-300">Temporal AQ</span>
                            </label>
                            <p className="text-xs text-gray-400 mt-1">Adapte d√©bit selon complexit√© temporelle</p>
                          </div>
                           <div>
                            <label className="flex items-center space-x-2 cursor-pointer">
                              <input
                                type="checkbox"
                                checked={config.ffmpeg?.spatial_aq !== false}
                                onChange={(e) => updateConfigNested("ffmpeg", "spatial_aq", e.target.checked)}
                                className="form-checkbox h-5 w-5 text-blue-600"
                              />
                              <span className="text-sm text-gray-300">Spatial AQ (Adaptive Quantization)</span>
                            </label>
                            <p className="text-xs text-gray-400 mt-1">Adapte d√©bit selon complexit√© spatiale</p>
                          </div>
                        </div>

                        {/* Command Preview */}
                        <div className="mt-4 p-3 bg-gray-800 rounded border border-gray-600">
                          <div className="text-xs text-gray-400 mb-1">Commande FFmpeg (aper√ßu):</div>
                          <div className="text-xs text-green-400 font-mono break-all">
                            ffmpeg -i input.mkv -c:v hevc_nvenc -preset {config.encode_preset || "p7"} -rc {config.ffmpeg?.rc_mode || "vbr_hq"} -cq {config.cq || 24} -b:v{" "}
                            {config.ffmpeg?.bitrate || "3M"} -maxrate {config.ffmpeg?.maxrate || "6M"} -profile:v main10 -pix_fmt p010le -spatial-aq {config.ffmpeg?.spatial_aq !== false ? "1" : "0"}{" "}
                            -temporal-aq {config.ffmpeg?.temporal_aq !== false ? "1" : "0"} -aq-strength {config.ffmpeg?.aq_strength || 8} -bf {config.ffmpeg?.bframes || 3} -b_ref_mode{" "}
                            {config.ffmpeg?.b_ref_mode || "middle"} -rc-lookahead {config.ffmpeg?.lookahead || 32} -multipass {config.ffmpeg?.multipass || "fullres"} -c:a copy output.mkv
                          </div>
                        </div>
                      </div>
                    </div>

                    {/* CPU Settings */}
                    <div className="space-y-4 pt-4 border-t border-gray-700">
                      <h3 className="text-lg font-semibold text-white">CPU Settings (x265 Fallback)</h3>

                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm text-gray-300 mb-2">CPU Preset (Fallback)</label>
                          <select
                            value={config.cpu_preset}
                            onChange={(e) => updateConfig("cpu_preset", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          >
                            <option value="ultrafast">Ultrafast</option>
                            <option value="superfast">Superfast</option>
                            <option value="veryfast">Veryfast</option>
                            <option value="faster">Faster</option>
                            <option value="fast">Fast</option>
                            <option value="medium">Medium</option>
                            <option value="slow">Slow</option>
                            <option value="slower">Slower</option>
                            <option value="veryslow">Veryslow</option>
                          </select>
                          <p className="text-xs text-gray-400 mt-1">Used when GPU not available</p>
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">CPU CRF (Constant Rate Factor)</label>
                          <input
                            type="number"
                            min="0"
                            max="51"
                            value={config.cpu_crf}
                            onChange={(e) => updateConfig("cpu_crf", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                          <p className="text-xs text-gray-400 mt-1">0-51, lower = better quality (23 recommended)</p>
                        </div>
                      </div>
                    </div>

                    {/* Audio Settings */}
                    <div className="space-y-4 pt-4 border-t border-gray-700">
                      <h3 className="text-lg font-semibold text-white">Audio Settings</h3>

                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm text-gray-300 mb-2">Audio Codec</label>
                          <select
                            value={config.ffmpeg_options?.audio_codec || "copy"}
                            onChange={(e) => updateConfig("ffmpeg_options.audio_codec", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          >
                            <option value="copy">Copy (No Re-encode)</option>
                            <option value="aac">AAC</option>
                            <option value="ac3">AC3</option>
                            <option value="opus">Opus</option>
                          </select>
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">Audio Bitrate (if re-encoding)</label>
                          <input
                            type="number"
                            min="64"
                            max="320"
                            step="32"
                            value={config.ffmpeg_options?.audio_bitrate || 192}
                            onChange={(e) => updateConfig("ffmpeg_options.audio_bitrate", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            disabled={config.ffmpeg_options?.audio_codec === "copy"}
                          />
                          <p className="text-xs text-gray-400 mt-1">kbps (192 recommended)</p>
                        </div>
                      </div>
                    </div>

                    {/* Advanced Settings */}
                    <div className="space-y-4 pt-4 border-t border-gray-700">
                      <h3 className="text-lg font-semibold text-white">Advanced</h3>

                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm text-gray-300 mb-2">Profile</label>
                          <select
                            value={config.ffmpeg_options?.profile || "main"}
                            onChange={(e) => updateConfig("ffmpeg_options.profile", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          >
                            <option value="main">Main</option>
                            <option value="main10">Main10 (10-bit)</option>
                          </select>
                        </div>

                        <div className="flex items-center">
                          <label className="flex items-center cursor-pointer">
                            <input type="checkbox" checked={config.ffmpeg_options?.two_pass || false} onChange={(e) => updateConfig("ffmpeg_options.two_pass", e.target.checked)} className="mr-2" />
                            <span className="text-sm text-gray-300">Enable Two-Pass Encoding</span>
                          </label>
                        </div>
                      </div>
                    </div>
                  </>
                )}

                {activeTab === "remote" && (
                  <>
                    <div className="space-y-4">
                      <h3 className="text-lg font-semibold text-white">Remote Server Configuration</h3>
                      
                      {/* Transfer Mode at Top */}
                      <div>
                        <label className="block text-sm text-gray-300 mb-2">Transfer Mode</label>
                        <select
                          value={config.webdav_transfer_mode || "auto"}
                          onChange={(e) => updateConfig("webdav_transfer_mode", e.target.value)}
                          className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                        >
                          <option value="prefer_webdav">Prefer WebDAV with SFTP fallback</option> 
                          <option value="auto">Mixed (WebDAV download, SFTP upload)</option>
                          <option value="webdav">WebDAV only</option>
                          <option value="sftp">SFTP only</option>
                        </select>
                        <p className="text-xs text-gray-400 mt-1">
                          <span className="font-semibold">Prefer WebDAV with SFTP fallback (recommended):</span> Uses WebDAV for fast downloads and SFTP for backup protection
                        </p>
                      </div>

                      {/* WebDAV Configuration */}
                      <div className="pt-4 border-t border-gray-700">
                        <h4 className="text-md font-semibold text-white mb-3">WebDAV Settings</h4>
                        
                        <div>
                          <label className="block text-sm text-gray-300 mb-2">WebDAV URL</label>
                          <input
                            type="text"
                            value={config.webdav_url || ""}
                            onChange={(e) => updateConfig("webdav_url", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            placeholder="http://your-server.com:port"
                          />
                          <p className="text-xs text-gray-400 mt-1">Full URL including protocol and port (e.g., http://192.168.1.100:8080)</p>
                        </div>

                        <div className="grid grid-cols-2 gap-4 mt-4">
                          <div>
                            <label className="block text-sm text-gray-300 mb-2">Username</label>
                            <input
                              type="text"
                              value={config.webdav_username || ""}
                              onChange={(e) => updateConfig("webdav_username", e.target.value)}
                              className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            />
                          </div>

                          <div>
                            <label className="block text-sm text-gray-300 mb-2">Password</label>
                            <input
                              type="password"
                              value={config.webdav_password || ""}
                              onChange={(e) => updateConfig("webdav_password", e.target.value)}
                              className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            />
                          </div>
                        </div>

                        <div className="mt-4">
                          <label className="block text-sm text-gray-300 mb-2">WebDAV Base Path</label>
                          <input
                            type="text"
                            value={config.webdav_path || "/"}
                            onChange={(e) => updateConfig("webdav_path", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            placeholder="/"
                          />
                          <p className="text-xs text-gray-400 mt-1">Base path on WebDAV server (usually "/" for root)</p>
                        </div>

                        {/* Test WebDAV Connection Button */}
                        <div className="pt-4">
                          <button 
                            onClick={async () => {
                              setWebdavConnectionStatus({ testing: true, message: "Testing WebDAV connection...", success: null });
                              try {
                                // Save config first
                                await window.electronAPI.configSaveUserConfig(config);
                                
                                // Test WebDAV connection
                                const result = await window.electronAPI.testWebdavConnection();
                                
                                if (result.success) {
                                  setWebdavConnectionStatus({
                                    testing: false,
                                    message: "‚úÖ WebDAV connection successful!",
                                    success: true,
                                  });
                                } else {
                                  setWebdavConnectionStatus({
                                    testing: false,
                                    message: `‚ùå WebDAV connection failed: ${result.error}`,
                                    success: false,
                                  });
                                }
                              } catch (error) {
                                setWebdavConnectionStatus({
                                  testing: false,
                                  message: `‚ùå Error: ${error.message}`,
                                  success: false,
                                });
                              }
                              
                              setTimeout(() => {
                                setWebdavConnectionStatus({ testing: false, message: "", success: null });
                              }, 5000);
                            }}
                            disabled={webdavConnectionStatus.testing} 
                            className={`btn-primary w-full ${webdavConnectionStatus.testing ? "opacity-50 cursor-not-allowed" : ""}`}
                          >
                            {webdavConnectionStatus.testing ? "üîÑ Testing..." : "üåê Test WebDAV Connection"}
                          </button>
                          {webdavConnectionStatus.message && (
                            <p className={`mt-2 text-sm ${webdavConnectionStatus.success ? "text-green-400" : webdavConnectionStatus.success === false ? "text-red-400" : "text-gray-400"}`}>
                              {webdavConnectionStatus.message}
                            </p>
                          )}
                        </div>
                      </div>

                      {/* SFTP Configuration (for upload in auto mode) */}
                      <div className="pt-4 border-t border-gray-700">
                        <h4 className="text-md font-semibold text-white mb-3">SFTP Settings</h4>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">SFTP Host</label>
                          <input
                            type="text"
                            value={config.remote_host || ""}
                            onChange={(e) => updateConfig("remote_host", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            placeholder="ds10256.seedhost.eu"
                          />
                        </div>

                        <div className="grid grid-cols-2 gap-4 mt-4">
                          <div>
                            <label className="block text-sm text-gray-300 mb-2">Username</label>
                            <input
                              type="text"
                              value={config.remote_user || ""}
                              onChange={(e) => updateConfig("remote_user", e.target.value)}
                              className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            />
                          </div>

                          <div>
                            <label className="block text-sm text-gray-300 mb-2">Password</label>
                            <input
                              type="password"
                              value={config.remote_password || ""}
                              onChange={(e) => updateConfig("remote_password", e.target.value)}
                              className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            />
                          </div>
                        </div>

                        <div className="mt-4">
                          <label className="block text-sm text-gray-300 mb-2">Remote Library Path</label>
                          <input
                            type="text"
                            value={config.remote_path || ""}
                            onChange={(e) => updateConfig("remote_path", e.target.value)}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            placeholder="/home/user/library"
                          />
                        </div>

                        {/* Test SFTP Connection Button */}
                        <div className="pt-4">
                          <button 
                            onClick={testConnection} 
                            disabled={connectionStatus.testing} 
                            className={`btn-primary w-full ${connectionStatus.testing ? "opacity-50 cursor-not-allowed" : ""}`}
                          >
                            {connectionStatus.testing ? "üîÑ Testing..." : "üîå Test SFTP Connection"}
                          </button>
                        </div>
                      </div>
                    </div>
                  </>
                )}

                {activeTab === "storage" && (
                  <>
                    <div className="space-y-4">
                      <h3 className="text-lg font-semibold text-white">File Retention Options</h3>

                      <div className="space-y-3">
                        <label className="flex items-center cursor-pointer">
                          <input type="checkbox" checked={config.advanced?.keep_original || false} onChange={(e) => updateConfig("advanced.keep_original", e.target.checked)} className="mr-2" />
                          <span className="text-sm text-gray-300">Keep original source files locally</span>
                        </label>
                        <p className="text-xs text-gray-400 ml-6">Original files will be kept in backup directory after encoding</p>

                        <label className="flex items-center cursor-pointer">
                          <input type="checkbox" checked={config.advanced?.keep_encoded || false} onChange={(e) => updateConfig("advanced.keep_encoded", e.target.checked)} className="mr-2" />
                          <span className="text-sm text-gray-300">Keep encoded files locally</span>
                        </label>
                        <p className="text-xs text-gray-400 ml-6">Encoded files will be kept in temp directory after upload</p>

                        <label className="flex items-center cursor-pointer">
                          <input type="checkbox" checked={config.advanced?.create_backups !== false} onChange={(e) => updateConfig("advanced.create_backups", e.target.checked)} className="mr-2" />
                          <span className="text-sm text-gray-300">Create backups on server before replacing</span>
                        </label>
                        <p className="text-xs text-gray-400 ml-6">Original file on server will be renamed with .bak extension</p>

                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={config.advanced?.skip_hevc_reencode || false}
                            onChange={(e) => updateConfig("advanced.skip_hevc_reencode", e.target.checked)}
                            className="mr-2"
                          />
                          <span className="text-sm text-gray-300">Skip re-encoding HEVC/x265 files</span>
                        </label>
                        <p className="text-xs text-gray-400 ml-6">Files already in HEVC format will be copied without re-encoding (faster but no size reduction)</p>
                      </div>
                    </div>

                    <div className="space-y-4 pt-4 border-t border-gray-700">
                      <h3 className="text-lg font-semibold text-white">Cleanup Settings</h3>

                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm text-gray-300 mb-2">Auto-cleanup old jobs (days)</label>
                          <input
                            type="number"
                            min="1"
                            max="365"
                            value={config.cleanup_old_jobs_days || 30}
                            onChange={(e) => updateConfig("cleanup_old_jobs_days", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">Auto-cleanup progress history (days)</label>
                          <input
                            type="number"
                            min="1"
                            max="999"
                            value={config.cleanup_old_progress_days || 365}
                            onChange={(e) => updateConfig("cleanup_old_progress_days", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                        </div>
                      </div>
                    </div>

                    <div className="space-y-4 pt-4 border-t border-gray-700">
                      <h3 className="text-lg font-semibold text-white">Local Paths</h3>

                      <div>
                        <label className="block text-sm text-gray-300 mb-2">Local Temp Directory</label>
                        <div className="flex gap-2">
                          <input
                            type="text"
                            value={config.local_temp || ""}
                            onChange={(e) => updateConfig("local_temp", e.target.value)}
                            className="flex-1 bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            placeholder="C:/Users/Zed/AppData/Local/Temp/Sharkoder/cache"
                          />
                          <button
                            onClick={async () => {
                              console.log("[DEBUG] Open folder clicked:", config.local_temp);
                              try {
                                const result = await window.electronAPI.openFolder(config.local_temp);
                                console.log("[DEBUG] Open folder result:", result);
                                if (!result.success) {
                                  alert("Failed to open folder: " + result.error);
                                }
                              } catch (error) {
                                console.error("[DEBUG] Open folder error:", error);
                                alert("Error: " + error.message);
                              }
                            }}
                            className="btn-secondary px-4 py-2 whitespace-nowrap"
                            title="Open folder in File Explorer"
                          >
                            üìÅ Open
                          </button>
                        </div>
                        <p className="text-xs text-gray-400 mt-1">Where files are downloaded for encoding</p>
                      </div>

                      <div>
                        <label className="block text-sm text-gray-300 mb-2">Local Backup Directory</label>
                        <div className="flex gap-2">
                          <input
                            type="text"
                            value={config.local_backup || ""}
                            onChange={(e) => updateConfig("local_backup", e.target.value)}
                            className="flex-1 bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                            placeholder="C:/Users/Zed/AppData/Local/Temp/Sharkoder/backups"
                          />
                          <button
                            onClick={async () => {
                              console.log("[DEBUG] Open backup folder clicked:", config.local_backup);
                              try {
                                const result = await window.electronAPI.openFolder(config.local_backup);
                                console.log("[DEBUG] Open backup folder result:", result);
                                if (!result.success) {
                                  alert("Failed to open folder: " + result.error);
                                }
                              } catch (error) {
                                console.error("[DEBUG] Open backup folder error:", error);
                                alert("Error: " + error.message);
                              }
                            }}
                            className="btn-secondary px-4 py-2 whitespace-nowrap"
                            title="Open folder in File Explorer"
                          >
                            üìÅ Open
                          </button>
                        </div>
                        <p className="text-xs text-gray-400 mt-1">Where original files are backed up</p>
                      </div>
                    </div>
                  </>
                )}

                {activeTab === "advanced" && (
                  <>
                    <div className="space-y-4">
                      <h3 className="text-lg font-semibold text-white">Connection Settings</h3>

                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm text-gray-300 mb-2">Max Concurrent Downloads</label>
                          <input
                            type="number"
                            min="1"
                            max="5"
                            value={config.max_concurrent_downloads || 2}
                            onChange={(e) => updateConfig("max_concurrent_downloads", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">Max Prefetch Files</label>
                          <input
                            type="number"
                            min="1"
                            max="10"
                            value={config.max_prefetch_files || 3}
                            onChange={(e) => updateConfig("max_prefetch_files", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">Retry Attempts</label>
                          <input
                            type="number"
                            min="0"
                            max="5"
                            value={config.retry_attempts || 2}
                            onChange={(e) => updateConfig("retry_attempts", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                        </div>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">Connection Timeout (ms)</label>
                          <input
                            type="number"
                            min="5000"
                            max="120000"
                            step="1000"
                            value={config.connection_timeout || 30000}
                            onChange={(e) => updateConfig("connection_timeout", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                        </div>
                      </div>
                    </div>

                    <div className="space-y-4 pt-4 border-t border-gray-700">
                      <h3 className="text-lg font-semibold text-white">Behavior</h3>

                      <div className="space-y-3">
                        <label className="flex items-center cursor-pointer">
                          <input type="checkbox" checked={config.advanced?.verify_checksums || true} onChange={(e) => updateConfig("advanced.verify_checksums", e.target.checked)} className="mr-2" />
                          <span className="text-sm text-gray-300">Verify file integrity with checksums</span>
                        </label>

                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={config.notification_settings?.show_completion_notifications !== false}
                            onChange={(e) => updateConfig("notification_settings.show_completion_notifications", e.target.checked)}
                            className="mr-2"
                          />
                          <span className="text-sm text-gray-300">Show completion notifications</span>
                        </label>

                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={config.notification_settings?.show_error_notifications !== false}
                            onChange={(e) => updateConfig("notification_settings.show_error_notifications", e.target.checked)}
                            className="mr-2"
                          />
                          <span className="text-sm text-gray-300">Show error notifications</span>
                        </label>

                        <label className="flex items-center cursor-pointer">
                          <input
                            type="checkbox"
                            checked={config.notification_settings?.minimize_to_tray !== false}
                            onChange={(e) => updateConfig("notification_settings.minimize_to_tray", e.target.checked)}
                            className="mr-2"
                          />
                          <span className="text-sm text-gray-300">Minimize to system tray</span>
                        </label>
                      </div>
                    </div>

                    <div className="space-y-4 pt-4 border-t border-gray-700">
                      <h3 className="text-lg font-semibold text-white">Logging</h3>

                      <div>
                        <label className="block text-sm text-gray-300 mb-2">Log Level</label>
                        <select
                          value={config.advanced?.log_level || "info"}
                          onChange={(e) => updateConfig("advanced.log_level", e.target.value)}
                          className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                        >
                          <option value="error">Error</option>
                          <option value="warn">Warning</option>
                          <option value="info">Info</option>
                          <option value="debug">Debug</option>
                        </select>
                      </div>
                    </div>
                  </>
                )}

                {activeTab === "ui" && (
                  <>
                    <div className="space-y-4">
                      <h3 className="text-lg font-semibold text-white">UI Preferences</h3>

                      <div className="space-y-3">
                        <label className="flex items-center cursor-pointer">
                          <input type="checkbox" checked={config.ui.show_notifications} onChange={(e) => updateConfig("ui.show_notifications", e.target.checked)} className="mr-2" />
                          <span className="text-sm text-gray-300">Show completion notifications</span>
                        </label>

                        <label className="flex items-center cursor-pointer">
                          <input 
                            type="checkbox" 
                            checked={config.ui?.hide_empty_folders !== false} 
                            onChange={(e) => updateConfig("ui.hide_empty_folders", e.target.checked)} 
                            className="mr-2" 
                          />
                          <span className="text-sm text-gray-300">Hide empty folders (no video files)</span>
                        </label>

                        <div>
                          <label className="block text-sm text-gray-300 mb-2">Auto-refresh interval (ms)</label>
                          <input
                            type="number"
                            min="1000"
                            max="30000"
                            step="1000"
                            value={config.ui.auto_refresh_interval}
                            onChange={(e) => updateConfig("ui.auto_refresh_interval", parseInt(e.target.value))}
                            className="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white"
                          />
                        </div>
                      </div>
                    </div>
                  </>
                )}

                {activeTab === "cache" && (
                  <>
                    <CacheManager onClose={onClose} />
                  </>
                )}
              </div>

              {/* Footer */}
              <div className="px-6 py-4 border-t border-gray-700 flex justify-between items-center">
                <div className="text-xs text-gray-400">Settings saved to server: {config.last_update ? new Date(config.last_update).toLocaleString() : "Never"}</div>
                <div className="flex space-x-3">
                  <button onClick={onClose} className="btn-secondary">
                    Cancel
                  </button>
                  <button onClick={handleSave} className="btn-success">
                    üíæ Save Settings
                  </button>
                </div>
              </div>
            </div>
          </div>
        );
      };

      // Main App Component
      const App = () => {
        const [jobs, setJobs] = useState([]);
        const [stats, setStats] = useState({});
        const [progressData, setProgressData] = useState({});
        const [encodedFiles, setEncodedFiles] = useState([]);
        const [isConnected, setIsConnected] = useState(false);
        const [logs, setLogs] = useState([]);
        const [backendLogs, setBackendLogs] = useState([]);
        const [queueStatus, setQueueStatus] = useState({ isRunning: false, isPaused: false, loading: false });
        const [showSettings, setShowSettings] = useState(false);
        const [userConfig, setUserConfig] = useState(null);
        const [isLoading, setIsLoading] = useState(true);
        const [shutdownWhenFinished, setShutdownWhenFinished] = useState(false);
        const [rightPanelTab, setRightPanelTab] = useState("queue"); // 'queue', 'history', or 'logs'

        // Use ref to track shutdown state in event handlers
        const shutdownWhenFinishedRef = React.useRef(shutdownWhenFinished);
        React.useEffect(() => {
          shutdownWhenFinishedRef.current = shutdownWhenFinished;
        }, [shutdownWhenFinished]);

        useEffect(() => {
          // Hide the initial HTML loader when React starts
          const initialLoader = document.getElementById("initial-loader");
          if (initialLoader) {
            initialLoader.style.display = "none";
          }

          // Load initial data
          const initializeApp = async () => {
            try {
              await Promise.all([loadJobs(), loadStats(), loadEncodedFiles(), loadQueueStatus(), loadUserConfig()]);

              // Auto-connect to SFTP server on startup
              try {
                const connectResult = await window.electronAPI.sftpConnect();
                if (connectResult.success) {
                  setIsConnected(true);
                  addLog("Connected to SFTP server", "success");
                } else {
                  addLog(`SFTP connection failed: ${connectResult.error}`, "warning");
                }
              } catch (error) {
                addLog(`SFTP connection error: ${error.message}`, "warning");
              }

              // WebDAV connection is handled by FileTree component
              // No need to connect here to avoid duplicate connections

              // Small delay to show the loading animation
              setTimeout(() => setIsLoading(false), 1000);
            } catch (error) {
              console.error("Failed to initialize app:", error);
              setIsLoading(false);
            }
          };

          initializeApp();

          // Setup event listeners
          window.electronAPI.onQueueProgress((data) => {
            setProgressData((prev) => ({
              ...prev,
              [data.jobId]: data,
            }));
          });

          window.electronAPI.onQueueStatusChange((data) => {
            console.log("Queue status changed:", data);
            setQueueStatus((prev) => ({
              ...prev,
              isRunning: data.isRunning,
              isPaused: data.isPaused,
            }));
          });

          // Listen for backend logs
          window.electronAPI.onLog((logData) => {
            setBackendLogs(prev => {
              const newLogs = [...prev, logData];
              // Keep only last 500 logs to prevent memory issues
              return newLogs.slice(-500);
            });
          });

          window.electronAPI.onJobUpdate(async (data) => {
            console.log("Job update received:", data);
            if (data.status === "failed") {
              addLog(`‚ùå Job ${data.id} failed: ${data.error || "Unknown error"}`, "error");
            } else if (data.status === "ready_upload") {
              addLog(`‚úÖ Job ${data.id} ready for upload`, "success");
            }
            // Reload jobs to update UI
            await loadJobs();
          });

          window.electronAPI.onJobComplete(async (data) => {
            addLog(`Job completed: ${data.filepath}`, "success");
            await loadJobs();
            await loadStats();
            await loadEncodedFiles();

            // Sync cache after upload completion
            try {
              console.log('Job completed, syncing cache...');
              // Wait a moment for the file to be fully uploaded
              await new Promise(resolve => setTimeout(resolve, 1000));
              // Trigger cache sync via main process to ensure it happens in FileTree
              await window.electronAPI.webdavConnect(); // Ensure connected
              if (window.electronAPI.syncCache) {
                await window.electronAPI.syncCache();
              }
            } catch (error) {
              console.error('Error syncing cache after job completion:', error);
            }

            // Check if shutdown is enabled and queue is finished
            if (shutdownWhenFinishedRef.current) {
              const result = await window.electronAPI.queueGetJobs();
              if (result.success) {
                const remainingJobs = result.jobs.filter(
                  (job) =>
                    job.status === "waiting" ||
                    job.status === "downloading" ||
                    job.status === "encoding" ||
                    job.status === "uploading" ||
                    job.status === "ready_encode" ||
                    job.status === "ready_upload"
                );

                if (remainingJobs.length === 0) {
                  addLog("üîå All jobs completed! Shutting down computer in 30 seconds...", "success");
                  setTimeout(async () => {
                    try {
                      await window.electronAPI.systemShutdown();
                    } catch (error) {
                      addLog(`Failed to shutdown: ${error.message}`, "error");
                    }
                  }, 2000); // Wait 2 seconds before initiating shutdown
                }
              }
            }
          });

          window.electronAPI.onQueueError((error) => {
            console.error("Queue error:", error);
            addLog(`‚ùå Queue error: ${error.message || JSON.stringify(error)}`, "error");
          });

          // Poll queue status every 5 seconds
          const statusInterval = setInterval(loadQueueStatus, 5000);

          // Poll job list every 2 seconds to see status updates
          const jobsInterval = setInterval(loadJobs, 2000);

          return () => {
            window.electronAPI.removeAllListeners("queue:progress");
            window.electronAPI.removeAllListeners("queue:statusChange");
            window.electronAPI.removeAllListeners("queue:jobComplete");
            window.electronAPI.removeAllListeners("queue:jobUpdate");
            window.electronAPI.removeAllListeners("queue:error");
            clearInterval(statusInterval);
            clearInterval(jobsInterval);
          };
        }, []);

        const loadJobs = async () => {
          try {
            const result = await window.electronAPI.queueGetJobs();
            if (result.success) {
              setJobs(result.jobs);
            }
          } catch (error) {
            console.error("Failed to load jobs:", error);
          }
        };

        const loadStats = async () => {
          try {
            const result = await window.electronAPI.queueGetStats();
            if (result.success) {
              setStats(result.stats);
            }
          } catch (error) {
            console.error("Failed to load stats:", error);
          }
        };

        const loadEncodedFiles = async () => {
          try {
            const result = await window.electronAPI.progressGetEncodedFiles();
            if (result.success) {
              setEncodedFiles(result.encodedFiles);
            }
          } catch (error) {
            console.error("Failed to load encoded files:", error);
          }
        };

        const addLog = (message, type = "info") => {
          const log = {
            id: Date.now(),
            message,
            type,
            timestamp: new Date().toLocaleTimeString(),
          };
          setLogs((prev) => [log, ...prev.slice(0, 99)]);
        };

        const loadQueueStatus = async () => {
          try {
            const result = await window.electronAPI.queueGetStatus();
            if (result.success) {
              setQueueStatus((prev) => ({
                ...prev,
                isRunning: result.isRunning,
                isPaused: result.isPaused,
                currentJob: result.currentJob,
              }));
            }
          } catch (error) {
            console.error("Failed to load queue status:", error);
          }
        };

        const toggleQueueProcessing = async () => {
          try {
            console.log("[DEBUG] toggleQueueProcessing called, current state:", queueStatus);
            setQueueStatus((prev) => ({ ...prev, loading: true }));

            if (queueStatus.isRunning) {
              console.log("[DEBUG] Stopping queue...");
              const result = await window.electronAPI.queueStop();
              console.log("[DEBUG] Stop result:", result);
              if (result.success) {
                addLog("Queue processing stopped", "info");
                await loadQueueStatus();
                await loadJobs();
                await loadStats();
              } else {
                addLog(`Failed to stop queue: ${result.error}`, "error");
              }
            } else {
              console.log("[DEBUG] Starting queue...");
              const result = await window.electronAPI.queueStart();
              console.log("[DEBUG] Start result:", result);
              if (result.success) {
                addLog("Queue processing started", "success");
                await loadQueueStatus();
                await loadJobs();
                await loadStats();
              } else {
                addLog(`Failed to start queue: ${result.error}`, "error");
              }
            }
          } catch (error) {
            console.error("[DEBUG] toggleQueueProcessing error:", error);
            addLog(`Error: ${error.message}`, "error");
          } finally {
            setQueueStatus((prev) => ({ ...prev, loading: false }));
          }
        };

        const loadUserConfig = async () => {
          try {
            const result = await window.electronAPI.configLoadUserConfig();
            if (result.success && result.config) {
              // Ensure UI preferences have default values
              const configWithDefaults = {
                ...result.config,
                ui: {
                  show_notifications: true,
                  auto_refresh_interval: 5000,
                  hide_empty_folders: true, // Default to hiding empty folders
                  ...result.config.ui
                }
              };
              setUserConfig(configWithDefaults);
            } else {
              // Fallback to default config if loading fails
              const localConfig = await window.electronAPI.configGet();
              if (localConfig.success) {
                const configWithDefaults = {
                  ...localConfig.config,
                  ui: {
                    show_notifications: true,
                    auto_refresh_interval: 5000,
                    hide_empty_folders: true,
                    ...localConfig.config.ui
                  }
                };
                setUserConfig(configWithDefaults);
              }
            }
          } catch (error) {
            console.error("Failed to load user config:", error);
            // Try to load local config as fallback
            try {
              const localConfig = await window.electronAPI.configGet();
              if (localConfig.success) {
                const configWithDefaults = {
                  ...localConfig.config,
                  ui: {
                    show_notifications: true,
                    auto_refresh_interval: 5000,
                    hide_empty_folders: true,
                    ...localConfig.config.ui
                  }
                };
                setUserConfig(configWithDefaults);
              }
            } catch (e) {
              console.error("Failed to load local config:", e);
            }
          }
        };

        const saveUserConfig = async (newConfig) => {
          try {
            const result = await window.electronAPI.configSaveUserConfig(newConfig);
            if (result.success) {
              setUserConfig(newConfig);
              addLog("Settings saved successfully", "success");
            } else {
              addLog(`Failed to save settings: ${result.error}`, "error");
            }
          } catch (error) {
            addLog(`Error: ${error.message}`, "error");
          }
        };

        const handleAddToQueue = async (filePath, fileInfo) => {
          try {
            const result = await window.electronAPI.queueAddJob(filePath, fileInfo);
            if (result.success) {
              addLog(`Added to queue: ${filePath}`, "success");
              loadJobs();
              loadStats();
            } else {
              addLog(`Failed to add to queue: ${result.error}`, "error");
            }
          } catch (error) {
            addLog(`Error: ${error.message}`, "error");
          }
        };

        const handleRemoveJob = async (jobId) => {
          try {
            const result = await window.electronAPI.queueRemoveJob(jobId);
            if (result.success) {
              addLog("Job removed from queue", "info");
              loadJobs();
              loadStats();
            }
          } catch (error) {
            addLog(`Error: ${error.message}`, "error");
          }
        };

        const handlePauseJob = async (jobId) => {
          try {
            const result = await window.electronAPI.queuePauseJob(jobId);
            if (result.success) {
              addLog("Job paused", "info");
              loadJobs();
            }
          } catch (error) {
            addLog(`Error: ${error.message}`, "error");
          }
        };

        const handleResumeJob = async (jobId) => {
          try {
            const result = await window.electronAPI.queueResumeJob(jobId);
            if (result.success) {
              addLog("Job resumed", "info");
              loadJobs();
            }
          } catch (error) {
            addLog(`Error: ${error.message}`, "error");
          }
        };

        const handleRetryJob = async (jobId) => {
          try {
            const result = await window.electronAPI.queueRetryJob(jobId);
            if (result.success) {
              addLog("Job queued for retry", "info");
              loadJobs();
            }
          } catch (error) {
            addLog(`Error: ${error.message}`, "error");
          }
        };

        // Show loading screen while initializing
        if (isLoading) {
          return <LoadingScreen message="Initializing Sharkoder..." />;
        }

        return (
          <div className="h-screen flex flex-col">
            {/* Header */}
            <div className="bg-gray-900 px-6 py-4 border-b border-gray-700 flex items-center justify-between">
              <h1 className="text-2xl font-bold text-white flex items-center">
                ü¶à Sharkoder
                <span className="ml-3 text-sm text-gray-400 font-normal">GPU-Accelerated Video Encoder</span>
              </h1>
              <div className="flex items-center space-x-3">
                <button
                  onClick={() => {
                    // Toggle DevTools
                    if (window.electronAPI && window.electronAPI.toggleDevTools) {
                      window.electronAPI.toggleDevTools();
                    }
                  }}
                  className="btn-secondary flex items-center space-x-2"
                  title="Toggle Developer Tools"
                >
                  <span>üîß</span>
                  <span>DevTools</span>
                </button>
                <button onClick={() => setShowSettings(true)} className="btn-secondary flex items-center space-x-2">
                  <span>‚öôÔ∏è</span>
                  <span>Settings</span>
                </button>
              </div>
            </div>

            {/* Settings Panel - Show with loading if userConfig is not loaded yet */}
            {showSettings &&
              (userConfig ? (
                <SettingsPanel userConfig={userConfig} onSave={saveUserConfig} onClose={() => setShowSettings(false)} />
              ) : (
                <div
                  className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
                  onClick={(e) => {
                    // Close if clicking on backdrop
                    if (e.target === e.currentTarget) {
                      setShowSettings(false);
                    }
                  }}
                >
                  <div className="bg-gray-800 rounded-lg p-12">
                    <LoadingScreen message="Loading settings..." />
                    <button onClick={() => setShowSettings(false)} className="mt-4 btn-secondary w-full">
                      Close
                    </button>
                  </div>
                </div>
              ))}

            {/* Main Content */}
            <div className="flex-1 flex overflow-hidden">
              {/* Left Panel - File Tree */}
              <div className="w-1/2 p-4">
                <FileTree onAddToQueue={handleAddToQueue} encodedFiles={encodedFiles} userConfig={userConfig} />
              </div>

              {/* Right Panel - Queue / History with Tabs */}
              <div className="w-1/2 p-4 flex flex-col">
                {/* Tab Headers */}
                <div className="flex space-x-2 mb-3">
                  <button
                    onClick={() => setRightPanelTab("queue")}
                    className={`flex-1 py-2 px-4 rounded-t-lg font-semibold transition-colors ${
                      rightPanelTab === "queue" ? "bg-gray-800 text-white border-b-2 border-blue-500" : "bg-gray-700 text-gray-400 hover:bg-gray-650"
                    }`}
                  >
                    üìã Queue
                  </button>
                  <button
                    onClick={() => setRightPanelTab("history")}
                    className={`flex-1 py-2 px-4 rounded-t-lg font-semibold transition-colors ${
                      rightPanelTab === "history" ? "bg-gray-800 text-white border-b-2 border-blue-500" : "bg-gray-700 text-gray-400 hover:bg-gray-650"
                    }`}
                  >
                    üìú Historique
                  </button>
                  <button
                    onClick={() => setRightPanelTab("logs")}
                    className={`flex-1 py-2 px-4 rounded-t-lg font-semibold transition-colors ${
                      rightPanelTab === "logs" ? "bg-gray-800 text-white border-b-2 border-blue-500" : "bg-gray-700 text-gray-400 hover:bg-gray-650"
                    }`}
                  >
                    üìù Logs
                  </button>
                </div>

                {/* Tab Content */}
                <div className="flex-1 overflow-hidden">
                  {rightPanelTab === "queue" ? (
                    <QueueTable
                      jobs={jobs}
                      progressData={progressData}
                      onRemoveJob={handleRemoveJob}
                      onRetryJob={handleRetryJob}
                      queueStatus={queueStatus}
                      userConfig={userConfig}
                      setQueueStatus={setQueueStatus}
                      loadJobs={loadJobs}
                      loadQueueStatus={loadQueueStatus}
                      addLog={addLog}
                      setJobs={setJobs}
                      loadStats={loadStats}
                    />
                  ) : rightPanelTab === "history" ? (
                    <HistoryTable jobs={jobs} />
                  ) : rightPanelTab === "logs" ? (
                    <div className="bg-gray-900 border border-gray-700 rounded-lg h-full overflow-hidden flex flex-col">
                      <div className="p-3 border-b border-gray-700 flex justify-between items-center">
                        <h3 className="text-sm font-semibold">Backend Logs</h3>
                        <button 
                          onClick={() => setBackendLogs([])} 
                          className="text-xs px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded"
                        >
                          Clear
                        </button>
                      </div>
                      <div 
                        className="flex-1 overflow-y-auto scrollbar-thin p-3"
                        ref={(el) => {
                          if (el && backendLogs.length > 0) {
                            // Auto-scroll to bottom when new logs arrive
                            el.scrollTop = el.scrollHeight;
                          }
                        }}
                      >
                        <div className="space-y-1 font-mono text-xs">
                          {backendLogs.map((log, index) => (
                            <div 
                              key={index} 
                              className={`flex space-x-2 ${
                                log.level === 'error' ? 'text-red-400' : 
                                log.level === 'warn' ? 'text-yellow-400' : 
                                'text-gray-300'
                              }`}
                            >
                              <span className="text-gray-500">{new Date(log.timestamp).toLocaleTimeString()}</span>
                              <span className={`font-semibold ${
                                log.level === 'error' ? 'text-red-500' : 
                                log.level === 'warn' ? 'text-yellow-500' : 
                                'text-blue-500'
                              }`}>[{log.level.toUpperCase()}]</span>
                              <span className="flex-1">{log.message}</span>
                            </div>
                          ))}
                          {backendLogs.length === 0 && (
                            <div className="text-gray-500 text-center py-8">No logs yet</div>
                          )}
                        </div>
                      </div>
                    </div>
                  ) : null}
                </div>
              </div>
            </div>

            {/* Bottom Panel - Logs */}
            <div className="bg-gray-900 border-t border-gray-700">
              <div className="h-32 p-4 pb-2">
                <div className="h-full overflow-y-auto scrollbar-thin">
                  <div className="space-y-1">
                    {logs.map((log) => (
                      <div key={log.id} className={`text-sm flex items-center space-x-2 ${log.type === "error" ? "text-red-400" : log.type === "success" ? "text-green-400" : "text-gray-300"}`}>
                        <span className="text-gray-500">{log.timestamp}</span>
                        <span>{log.message}</span>
                      </div>
                    ))}
                  </div>
                </div>
              </div>

              {/* Shutdown Checkbox */}
              <div className="px-4 pb-2 flex items-center justify-between border-t border-gray-800 pt-2">
                <label className="flex items-center space-x-2 cursor-pointer group">
                  <input
                    type="checkbox"
                    checked={shutdownWhenFinished}
                    onChange={(e) => setShutdownWhenFinished(e.target.checked)}
                    className="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500 focus:ring-2"
                  />
                  <span className="text-sm text-gray-300 group-hover:text-white transition-colors">üîå Shutdown computer when queue is finished</span>
                </label>
                {shutdownWhenFinished && (
                  <span className="text-xs text-yellow-400 flex items-center space-x-1">
                    <span>‚ö†Ô∏è</span>
                    <span>Computer will shutdown after all jobs complete</span>
                  </span>
                )}
              </div>
            </div>

            {/* Status Bar */}
            <StatusBar stats={stats} isConnected={isConnected} />
          </div>
        );
      };

      // Render the app (React 18 API)
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
